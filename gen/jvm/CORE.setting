# This file automatically generated by tools/build/gen-cat.nqp

# From 'src/core/core_prologue.pm'

use Perl6::BOOTSTRAP;

my class Pair { ... }
my class Whatever { ... }
my class HyperWhatever { ... }
my class WhateverCode { ... }
my class Cursor { ... }

my role Positional { ... }
my role Associative { ... }
my role Callable { ... }

# From 'src/core/traits.pm'

my class X::Inheritance::Unsupported { ... }
my class X::Inheritance::UnknownParent { ... }
my class X::Export::NameClash        { ... }
my class X::Composition::NotComposable { ... }
my class X::Import::MissingSymbols   { ... }
my class X::Redeclaration { ... }
my class X::Inheritance::SelfInherit { ... }
my class X::Comp::Trait::Unknown { ... }
my class Pod::Block::Declarator { ... }

sub SET_LEADING_DOCS($obj, $docs) {
    my $current_why := $obj.WHY;

    if $current_why {
        my $end := nqp::elems($*POD_BLOCKS) - 1;
        my $i   := $end;

        while $i >= 0 {
            if $docs === nqp::atpos($*POD_BLOCKS, $i) {
                nqp::splice($*POD_BLOCKS, nqp::list(), $i, 1);
                last;
            }
            $i := $i - 1;
        }

        $current_why._add_leading(~$docs);
    } else {
        $obj.set_why($docs);
    }
}

sub SET_TRAILING_DOCS($obj, $docs) {
    my $current_why := $obj.WHY;

    if $current_why {
        $current_why._add_trailing(~$docs);
    } else {
        $obj.set_why($docs);
        $*POD_BLOCKS.push($docs);
    }
}

proto sub trait_mod:<is>(|) { * }
multi sub trait_mod:<is>(Mu:U $child, Mu:U $parent) {
    if $parent.HOW.archetypes.inheritable() {
        $child.^add_parent($parent);
    }
    elsif $parent.HOW.archetypes.inheritalizable() {
        $child.^add_parent($parent.^inheritalize)
    }
    else {
        X::Inheritance::Unsupported.new(
            :child-typename($child.^name),
            :$parent,
        ).throw;
    }
}
multi sub trait_mod:<is>(Mu:U $child, :$DEPRECATED!) {
}
multi sub trait_mod:<is>(Mu:U $type, :$rw!) {
    $type.^set_rw;
}
multi sub trait_mod:<is>(Mu:U $type, :$nativesize!) {
    $type.^set_nativesize($nativesize);
}
multi sub trait_mod:<is>(Mu:U $type, :$ctype!) {
    $type.^set_ctype($ctype);
}
multi sub trait_mod:<is>(Mu:U $type, :$unsigned!) {
    $type.^set_unsigned($unsigned);
}
multi sub trait_mod:<is>(Mu:U $type, :$hidden!) {
    $type.^set_hidden;
}
multi sub trait_mod:<is>(Mu:U $type, Mu :$array_type!) {
    $type.^set_array_type($array_type);
}
multi sub trait_mod:<is>(Mu:U $type, *%fail) {
    if %fail.keys[0] !eq $type.^name {
        X::Inheritance::UnknownParent.new(
            :child($type.^name),
            :parent(%fail.keys[0]),
            :suggestions([])
        ).throw;
    } else {
        X::Inheritance::SelfInherit.new(
            :name(%fail.keys[0])
        ).throw;
    }
}

multi sub trait_mod:<is>(Attribute:D $attr, |c ) {
    X::Comp::Trait::Unknown.new(
      file       => $?FILE,
      line       => $?LINE,
      type       => 'is',
      subtype    => c.hash.keys[0],
      declaring  => 'n attribute',
      highexpect => <rw readonly box_target leading_docs trailing_docs>,
    ).throw;
}
multi sub trait_mod:<is>(Attribute:D $attr, :$rw!) {
    $attr.set_rw();
    warn "useless use of 'is rw' on $attr.name()" unless $attr.has_accessor;
}
multi sub trait_mod:<is>(Attribute:D $attr, :$readonly!) {
    $attr.set_readonly();
    warn "useless use of 'is readonly' on $attr.name()" unless $attr.has_accessor;
}
multi sub trait_mod:<is>(Attribute:D $attr, :$box_target!) {
    $attr.set_box_target();
}
multi sub trait_mod:<is>(Attribute:D $attr, :$DEPRECATED!) {
}
multi sub trait_mod:<is>(Attribute:D $attr, :$leading_docs!) {
    SET_LEADING_DOCS($attr, $leading_docs);
}

multi sub trait_mod:<is>(Attribute:D $attr, :$trailing_docs!) {
    SET_TRAILING_DOCS($attr, $trailing_docs);
}

multi sub trait_mod:<is>(Routine:D $r, |c ) {
    X::Comp::Trait::Unknown.new(
      file       => $?FILE,
      line       => $?LINE,
      type       => 'is',
      subtype    => c.hash.keys[0],
      declaring  => ' ' ~ lc( $r.^name ),
      highexpect => ('rw parcel hidden-from-backtrace hidden-from-USAGE',
                     'pure default DEPRECATED inlinable',
                     'prec equiv tighter looser assoc leading_docs trailing_docs' ),
    ).throw;
}
multi sub trait_mod:<is>(Routine:D $r, :$rw!) {
    $r.set_rw();
}
multi sub trait_mod:<is>(Routine:D $r, :$parcel!) {
    $r.set_rw(); # for now, until we have real parcel handling
}
multi sub trait_mod:<is>(Routine:D $r, :$default!) {
    $r does role { method default() { True } }
}
multi sub trait_mod:<is>(Routine:D $r, :$DEPRECATED!) {
    my $new := nqp::istype($DEPRECATED,Bool)
      ?? "something else"
      !! $DEPRECATED;
    $r.add_phaser( 'ENTER', -> { DEPRECATED($new) } );
}
multi sub trait_mod:<is>(Routine:D $r, Mu :$inlinable!) {
    $r.set_inline_info(nqp::decont($inlinable));
}
multi sub trait_mod:<is>(Routine:D $r, :$onlystar!) {
    $r.set_onlystar();
}
multi sub trait_mod:<is>(Routine:D $r, :prec(%spec)!) {
    my role Precedence {
        has %.prec;
    }
    if nqp::istype($r, Precedence) {
        for %spec {
            $r.prec.{.key} := .value;
        }
    }
    else {
        $r.^mixin(Precedence);
        nqp::bindattr(nqp::decont($r), $r.WHAT, '%!prec', %spec);
    }
    0;
}
multi sub trait_mod:<is>(Routine $r, :&equiv!) {
    nqp::can(&equiv, 'prec')
        ?? trait_mod:<is>($r, :prec(&equiv.prec))
        !! die "Routine given to equiv does not appear to be an operator";
}
multi sub trait_mod:<is>(Routine $r, :&tighter!) {
    die "Routine given to tighter does not appear to be an operator"
        unless nqp::can(&tighter, 'prec');
    if !nqp::can($r, 'prec') || ($r.prec<prec> // "") !~~ /<[@:]>/ {
        trait_mod:<is>($r, :prec(&tighter.prec))
    }
    $r.prec<prec> := $r.prec<prec>.subst(/\=/, '@=');
    $r.prec<assoc>:delete;
}
multi sub trait_mod:<is>(Routine $r, :&looser!) {
    die "Routine given to looser does not appear to be an operator"
        unless nqp::can(&looser, 'prec');
    if !nqp::can($r, 'prec') || ($r.prec<prec> // "") !~~ /<[@:]>/ {
        trait_mod:<is>($r, :prec(&looser.prec))
    }
    $r.prec<prec> := $r.prec<prec>.subst(/\=/, ':=');
    $r.prec<assoc>:delete;
}
multi sub trait_mod:<is>(Routine $r, :$assoc!) {
    trait_mod:<is>($r, :prec({ :$assoc }))
}

BEGIN &trait_mod:<is>.set_onlystar();

multi sub trait_mod:<is>(Parameter:D $param, |c ) {
    X::Comp::Trait::Unknown.new(
      file       => $?FILE,
      line       => $?LINE,
      type       => 'is',
      subtype    => c.hash.keys[0],
      declaring  => ' parameter',
      highexpect => <rw readonly copy required parcel leading_docs trailing_docs>,
    ).throw;
}
multi sub trait_mod:<is>(Parameter:D $param, :$readonly!) {
    # This is the default.
}
multi sub trait_mod:<is>(Parameter:D $param, :$rw!) {
    $param.set_rw();
}
multi sub trait_mod:<is>(Parameter:D $param, :$copy!) {
    $param.set_copy();
}
multi sub trait_mod:<is>(Parameter:D $param, :$required!) {
    $param.set_required();
}
multi sub trait_mod:<is>(Parameter:D $param, :$parcel!) {
    $param.set_parcel();
}
multi sub trait_mod:<is>(Parameter:D $param, :$leading_docs!) {
    SET_LEADING_DOCS($param, $leading_docs);
}
multi sub trait_mod:<is>(Parameter:D $param, :$trailing_docs!) {
    SET_TRAILING_DOCS($param, $trailing_docs);
}

my $!;
my $/;
my $_;

sub EXPORT_SYMBOL(\exp_name, @tags, Mu \sym) {
    my @export_packages = $*EXPORT;
    for nqp::hllize(@*PACKAGES) {
        unless .WHO.EXISTS-KEY('EXPORT') {
            .WHO<EXPORT> := Metamodel::PackageHOW.new_type(:name('EXPORT'));
            .WHO<EXPORT>.^compose;
        }
        @export_packages.push: .WHO<EXPORT>;
    }
    for @export_packages -> $p {
        for @tags -> $tag {
            my $install_in;
            if $p.WHO.EXISTS-KEY($tag) {
                $install_in := $p.WHO.{$tag};
            }
            else {
                $install_in := Metamodel::PackageHOW.new_type(:name($tag));
                $install_in.^compose;
                $p.WHO{$tag} := $install_in;
            }
            if $install_in.WHO.EXISTS-KEY(exp_name) {
                unless ($install_in.WHO){exp_name} =:= sym {
                    X::Export::NameClash.new(symbol => exp_name).throw;
                }
            }
            $install_in.WHO{exp_name} := sym;
        }
    }
    0;
}
multi sub trait_mod:<is>(Routine:D \r, :$export!) {
    my $to_export := r.multi ?? r.dispatcher !! r;
    my $exp_name  := '&' ~ r.name;
    my @tags = 'ALL', (nqp::istype($export,Pair) ?? $export.key() !!
                       nqp::istype($export,Positional) ?? @($export)>>.key !!
                       'DEFAULT');
    EXPORT_SYMBOL($exp_name, @tags, $to_export);
}
multi sub trait_mod:<is>(Mu:U \type, :$export!) {
    my $exp_name := type.^name;
    my @tags = 'ALL', (nqp::istype($export,Pair) ?? $export.key !!
                       nqp::istype($export,Positional) ?? @($export)>>.key !!
                       'DEFAULT');
    EXPORT_SYMBOL($exp_name, @tags, type);
    if nqp::istype(type.HOW, Metamodel::EnumHOW) {
        type.^set_export_callback( {
            for type.^enum_values.keys -> $value_name {
                EXPORT_SYMBOL($value_name, @tags, type.WHO{$value_name});
            }
        });
    }
}
multi sub trait_mod:<is>(Mu \sym, :$export!, :$SYMBOL!) {
    my @tags = 'ALL', (nqp::istype($export,Pair) ?? $export.key !!
                    nqp::istype($export,Positional) ?? @($export)>>.key !!
                    'DEFAULT');
    EXPORT_SYMBOL($SYMBOL, @tags, sym);
}


multi sub trait_mod:<is>(Routine:D $r, :$leading_docs!) {
    SET_LEADING_DOCS($r, $leading_docs);
}
multi sub trait_mod:<is>(Routine:D $r, :$trailing_docs!) {
    SET_TRAILING_DOCS($r, $trailing_docs);
}

multi sub trait_mod:<is>(Mu:U $docee, :$leading_docs!) {
    SET_LEADING_DOCS($docee, $leading_docs);
}
multi sub trait_mod:<is>(Mu:U $docee, :$trailing_docs!) {
    SET_TRAILING_DOCS($docee.HOW, $trailing_docs);
}

proto sub trait_mod:<does>(|) { * }
multi sub trait_mod:<does>(Mu:U $doee, Mu:U $role) {
    if $role.HOW.archetypes.composable() {
        $doee.^add_role($role)
    }
    elsif $role.HOW.archetypes.composalizable() {
        $doee.^add_role($role.HOW.composalize($role))
    }
    else {
        X::Composition::NotComposable.new(
            target-name => $doee.^name,
            composer    => $role,
        ).throw;
    }
}

proto sub trait_mod:<of>(|) { * }
multi sub trait_mod:<of>(Mu:U $target, Mu:U $type) {
    # XXX Ensure we can do this, die if not.
    $target.^set_of($type);
}
multi sub trait_mod:<of>(Routine:D $target, Mu:U $type) {
    my $sig := $target.signature;
    X::Redeclaration.new(what => 'return type for', symbol => $target,
        postfix => " (previous return type was {$sig.returns.^name})").throw
        if $sig.has_returns;
    $sig.set_returns($type)
}

multi sub trait_mod:<is>(Routine:D $r, :$hidden_from_backtrace!) {
    DEPRECATED(
      'is hidden-from-backtrace',
      |<2015.03 2016.03>,
      :what<Routine trait "is hidden_from_backtrace">,
    );
    $r.^mixin( role { method is-hidden-from-backtrace { True } } );
}
multi sub trait_mod:<is>(Routine:D $r, :$hidden-from-backtrace!) {
    $r.^mixin( role { method is-hidden-from-backtrace { True } } );
}

multi sub trait_mod:<is>(Routine:D $r, :$hidden_from_USAGE!) {
    DEPRECATED(
      'is hidden-from-USAGE',
      |<2015.03 2016.03>,
      :what<Routine trait "is hidden_from_USAGE">,
    );
    $r.^mixin( role { method is-hidden-from-USAGE { True } });
}
multi sub trait_mod:<is>(Routine:D $r, :$hidden-from-USAGE!) {
    $r.^mixin( role {
        method is-hidden-from-USAGE { True }
    });
}

multi sub trait_mod:<is>(Routine:D $r, :$pure!) {
    $r.^mixin( role {
        method IS_PURE { True }
    });
}

proto sub trait_mod:<returns>(|) { * }
multi sub trait_mod:<returns>(Routine:D $target, Mu:U $type) {
    my $sig := $target.signature;
    X::Redeclaration.new(what => 'return type for', symbol => $target,
        postfix => " (previous return type was {$sig.returns.^name})").throw
        if $sig.has_returns;
    $sig.set_returns($type)
}

proto sub trait_mod:<as>(|) { * }
multi sub trait_mod:<as>(Parameter:D $param, $type) {
    $param.set_coercion($type);
}

my class Pair { ... }
proto sub trait_mod:<handles>(|) { * }
multi sub trait_mod:<handles>(Attribute:D $target, $thunk) {
    $target does role {
        has $.handles;

        method set_handles($expr) {
            $!handles := $expr;
        }

        method add_delegator_method($attr: $pkg, $meth_name, $call_name) {
            my $meth := method (|c) is rw {
                $attr.get_value(self)."$call_name"(|c)
            };
            $meth.set_name($meth_name);
            $pkg.^add_method($meth_name, $meth);
        }

        method apply_handles($attr: Mu $pkg) {
            sub applier($expr) {
                if $expr.defined() {
                    if nqp::istype($expr,Str) {
                        self.add_delegator_method($pkg, $expr, $expr);
                    }
                    elsif nqp::istype($expr,Pair) {
                        self.add_delegator_method($pkg, $expr.key, $expr.value);
                    }
                    elsif nqp::istype($expr,Positional) {
                        for $expr.list {
                            applier($_);
                        }
                        0;
                    }
                    elsif $expr.isa(Whatever) {
                        $pkg.^add_fallback(
                            -> $obj, $name {
                                so $attr.get_value($obj).can($name);
                            },
                            -> $obj, $name {
                                -> $self, |c {
                                    $attr.get_value($self)."$name"(|c)
                                }
                            });
                    }
                    elsif $expr.isa(HyperWhatever) {
                        $pkg.^add_fallback(
                            -> $obj, $name { True },
                            -> $obj, $name {
                                -> $self, |c {
                                    $attr.get_value($self)."$name"(|c)
                                }
                            });
                    }
                    else {
                        $pkg.^add_fallback(
                            -> $obj, $name {
                                ?($name ~~ $expr)
                            },
                            -> $obj, $name {
                                -> $self, |c {
                                    $attr.get_value($self)."$name"(|c)
                                }
                            });
                    }
                }
                else {
                    $pkg.^add_fallback(
                        -> $obj, $name {
                            ?$expr.can($name)
                        },
                        -> $obj, $name {
                            -> $self, |c {
                                $attr.get_value($self)."$name"(|c)
                            }
                        });
                }
            }
            applier($!handles);
        }
    };
    $target.set_handles($thunk());
}

multi sub trait_mod:<handles>(Method:D $m, &thunk) {
    my $pkg := $m.signature.params[0].type;
    my $call_name := $m.name;
    for thunk() -> $meth_name {
        my $meth := method (|c) is rw {
            self."$call_name"()."$meth_name"(|c);
        }
        $meth.set_name($meth_name);
        $pkg.^add_method($meth_name, $meth);
    }
    0;
}

proto sub trait_mod:<will>(|) { * }
multi sub trait_mod:<will>(Attribute $attr, Block :$build!) {
    $attr.set_build($build)
}

proto sub trait_mod:<trusts>(|) { * }
multi sub trait_mod:<trusts>(Mu:U $truster, Mu:U $trustee) {
    $truster.^add_trustee($trustee);
}

proto sub trait_mod:<hides>(|) { * }
multi sub trait_mod:<hides>(Mu:U $child, Mu:U $parent) {
    if $parent.HOW.archetypes.inheritable() {
        $child.^add_parent($parent, :hides);
    }
    elsif $parent.HOW.archetypes.inheritalizable() {
        $child.^add_parent($parent.^inheritalize, :hides)
    }
    else {
        X::Inheritance::Unsupported.new(
            :child-typename($child.^name),
            :$parent,
        ).throw;
    }
}

# From 'src/core/Positional.pm'

my role Positional[::T = Mu] {
    method of() { T }
}

# From 'src/core/Associative.pm'

my role Associative[::T = Mu] {
    method of() { T }
}

# From 'src/core/Callable.pm'

my role Callable[::T = Mu] {
    method of() { T }
    method returns() { T }
}

# From 'src/core/natives.pm'

my native   int is repr('P6int') is Int { }
my native  int1 is repr('P6int') is Int is nativesize( 1) { }
my native  int2 is repr('P6int') is Int is nativesize( 2) { }
my native  int4 is repr('P6int') is Int is nativesize( 4) { }
my native  int8 is repr('P6int') is Int is nativesize( 8) { }
my native int16 is repr('P6int') is Int is nativesize(16) { }
my native int32 is repr('P6int') is Int is nativesize(32) { }
my native int64 is repr('P6int') is Int is nativesize(64) { }

my native   uint is repr('P6int') is Int is unsigned { }
my native  uint1 is repr('P6int') is Int is nativesize( 1) is unsigned { }
my native    bit is repr('P6int') is Int is nativesize( 1) is unsigned { }
my native  uint2 is repr('P6int') is Int is nativesize( 2) is unsigned { }
my native  uint4 is repr('P6int') is Int is nativesize( 4) is unsigned { }
my native  uint8 is repr('P6int') is Int is nativesize( 8) is unsigned { }
my native   byte is repr('P6int') is Int is nativesize( 8) is unsigned { }
my native uint16 is repr('P6int') is Int is nativesize(16) is unsigned { }
my native uint32 is repr('P6int') is Int is nativesize(32) is unsigned { }
my native uint64 is repr('P6int') is Int is nativesize(64) is unsigned { }

my native   num is repr('P6num') is Num { }
my native num32 is repr('P6num') is Num is nativesize(32) { }
my native num64 is repr('P6num') is Num is nativesize(64) { }

my native   str is repr('P6str') is Str { }

# From 'src/core/stubs.pm'

my class Exception { ... }
my class X::AdHoc  { ... }
my class FatRat    { ... }
my class Enum      { ... }
my class X::OutOfRange { ... }
my class X::Dynamic::NotFound { ... }

my role QuantHash { ... }
my role Setty { ... }
my class Set { ... }
my class SetHash { ... }

my role Baggy { ... }
my class Bag { ... }
my class BagHash { ... }

my role Mixy { ... }
my class Mix { ... }
my class MixHash { ... }

sub DYNAMIC(\name) is rw {
    my Mu \x := nqp::getlexdyn(nqp::unbox_s(name));
    if nqp::isnull(x) {
        my str $pkgname = nqp::replace(nqp::unbox_s(name), 1, 1, '');
        if nqp::existskey((my \globalwho := GLOBAL.WHO), $pkgname) {
            x := nqp::atkey(globalwho, $pkgname);
        }
        elsif nqp::existskey((my \processwho := PROCESS.WHO), $pkgname) {
            x := nqp::atkey(processwho, $pkgname);
        }
        else {
#my $last = now;
#say "initializing {name}";
            x := INITIALIZE_DYNAMIC(name);
#say "    done at {now - $last}";
            fail x if nqp::istype(x, Exception);
        }
    }
    x
}

proto sub INITIALIZE_DYNAMIC(|) { * }
multi sub INITIALIZE_DYNAMIC(\name) {
    X::Dynamic::NotFound.new(:name(name));
}
#multi sub INITIALIZE_DYNAMIC('$*FOO') {   # example stub
#    PROCESS::<$FOO> := "foo";
#}

{
    my class Dummy {
        our proto method AUTOGEN(::T $: |) { * }
    }
    Dummy.HOW.set_autogen_proto(&Dummy::AUTOGEN);
}

# From 'src/core/control.pm'

my class X::Eval::NoSuchLang { ... }
my class PseudoStash { ... }
my class Label { ... }

$PROCESS::FATAL = False;

sub THROW(Mu \arg, int $type) {
    my Mu $ex := nqp::newexception();
    nqp::setpayload($ex, arg);
    nqp::setextype($ex, $type);
    nqp::throw($ex);
    0
}

sub RETURN-PARCEL(Mu \parcel) is rw {
    my Mu $storage := nqp::getattr(parcel, Parcel, '$!storage');
    nqp::iseq_i(nqp::elems($storage), 0)
      ?? Nil
      !! (nqp::iseq_i(nqp::elems($storage), 1)
            ?? nqp::shift($storage)
            !! parcel)
}

my &return-rw := -> | {
    my $parcel :=
        &RETURN-PARCEL(nqp::p6parcel(nqp::p6argvmarray(), Nil));
    nqp::p6routinereturn($parcel);
    $parcel
};
my &return := -> | {
    my $parcel :=
        &RETURN-PARCEL(nqp::p6parcel(nqp::p6argvmarray(), Nil));
    nqp::p6routinereturn(nqp::p6recont_ro($parcel));
    $parcel
};

my &take-rw := -> | {
    my $parcel := &RETURN-PARCEL(nqp::p6parcel(nqp::p6argvmarray(), Nil));
    THROW($parcel, nqp::const::CONTROL_TAKE);
    $parcel
}

my &take := -> | {
    my $parcel := &RETURN-PARCEL(nqp::p6parcel(nqp::p6argvmarray(), Nil));
    THROW(nqp::p6recont_ro($parcel), nqp::const::CONTROL_TAKE);
    $parcel
}

my &last := -> | {
    my Mu $args := nqp::p6argvmarray();
    if nqp::islist($args) && nqp::istype(nqp::atpos($args, 0), Label) {
        nqp::atpos($args, 0).last()
    }
    else {
        my $parcel := nqp::decont(&RETURN-PARCEL(nqp::p6parcel($args, Nil)));
        THROW($parcel, nqp::const::CONTROL_LAST)
    }
};

my &next := -> | {
    my Mu $args := nqp::p6argvmarray();
    if nqp::islist($args) && nqp::istype(nqp::atpos($args, 0), Label) {
        nqp::atpos($args, 0).next()
    }
    else {
        my $parcel := nqp::decont(&RETURN-PARCEL(nqp::p6parcel($args, Nil)));
        THROW($parcel, nqp::const::CONTROL_NEXT)
    }
};

my &redo := -> | {
    my Mu $args := nqp::p6argvmarray();
    if nqp::islist($args) && nqp::istype(nqp::atpos($args, 0), Label) {
        nqp::atpos($args, 0).redo()
    }
    else {
        my $parcel := nqp::decont(&RETURN-PARCEL(nqp::p6parcel($args, Nil)));
        THROW($parcel, nqp::const::CONTROL_REDO)
    }
};

proto sub succeed(|) { * }
multi sub succeed() {
    THROW(Nil, nqp::const::CONTROL_SUCCEED)
}
multi sub succeed(\x) {
    THROW(nqp::decont(x), nqp::const::CONTROL_SUCCEED)
}
multi sub succeed(|) {
    my $parcel := &RETURN-PARCEL(nqp::p6parcel(nqp::p6argvmarray(), Nil));
    THROW(nqp::decont($parcel), nqp::const::CONTROL_SUCCEED)
}

sub proceed() {
    THROW(Nil, nqp::const::CONTROL_PROCEED)
}

my &callwith := -> *@pos, *%named {
    my Mu $dispatcher := nqp::p6finddispatcher('callwith');
    $dispatcher.exhausted ?? Nil !!
        $dispatcher.call_with_args(|@pos, |%named)
};

my &nextwith := -> *@pos, *%named {
    my Mu $dispatcher := nqp::p6finddispatcher('nextwith');
    unless $dispatcher.exhausted {
        nqp::p6routinereturn(nqp::p6recont_ro(
            $dispatcher.call_with_args(|@pos, |%named)))
    }
    Nil
};

my &callsame := -> {
    my Mu $dispatcher := nqp::p6finddispatcher('callsame');
    $dispatcher.exhausted ?? Nil !!
        $dispatcher.call_with_capture(
            nqp::p6argsfordispatcher($dispatcher))
};

my &nextsame := -> {
    my Mu $dispatcher := nqp::p6finddispatcher('nextsame');
    unless $dispatcher.exhausted {
        nqp::p6routinereturn(nqp::p6recont_ro(
            $dispatcher.call_with_capture(
                nqp::p6argsfordispatcher($dispatcher))))
    }
    Nil
};

my &lastcall := -> {
    nqp::p6finddispatcher('lastcall').last();
    True
};

my &samewith := -> *@pos, *%named {
    my $my   = callframe(1).my;
    my $self = $my<self>;
    die "Could not find 'self'" if !$self.DEFINITE;
    my $dispatcher = $my<&?ROUTINE>.dispatcher
      || die "Could not find dispatcher";
    $dispatcher( $self, |@pos, |%named );
}

proto sub die(|) is hidden-from-backtrace {*};
multi sub die(Exception $e) is hidden-from-backtrace { $e.throw }
multi sub die($payload = "Died") is hidden-from-backtrace {
    X::AdHoc.new(:$payload).throw
}
multi sub die(*@msg) is hidden-from-backtrace {
    X::AdHoc.new(payload => @msg.join).throw
}

multi sub warn(*@msg) is hidden-from-backtrace {
    my $ex := nqp::newexception();
    nqp::setmessage($ex, nqp::unbox_s(@msg.join));
    nqp::setextype($ex, nqp::const::CONTROL_WARN);
    nqp::throw($ex);
    0;
}

proto sub EVAL($, *%) {*}
multi sub EVAL(Cool $code, :$lang = 'perl6', PseudoStash :$context) {
    my $eval_ctx := nqp::getattr(nqp::decont($context // CALLER::), PseudoStash, '$!ctx');
    my $?FILES   := 'EVAL_' ~ (state $no)++;
    my $compiler := nqp::getcomp($lang);
    X::Eval::NoSuchLang.new(:$lang).throw
        if nqp::isnull($compiler);
    my $compiled := $compiler.compile($code.Stringy, :outer_ctx($eval_ctx), :global(GLOBAL));
    nqp::forceouterctx(nqp::getattr($compiled, ForeignCode, '$!do'), $eval_ctx);
    $compiled();
}

sub exit($status = 0) {
    state $exit;
    $exit = $status;

    return if $++;  # already exiting

    THE_END();
    nqp::exit(nqp::unbox_i($exit.Int));
    $exit;
}

sub THE_END {
    my @END := nqp::p6list(nqp::getcurhllsym("@END_PHASERS"), Array, Mu);
    while @END.shift -> $end { $end() };
}

my class Proc::Status { ... }

sub run(*@args ($, *@)) {
    my $status = Proc::Status.new( :exit(255) );
    try {
        $status.status(nqp::p6box_i(nqp::spawn(
          CLONE-LIST-DECONTAINERIZED(@args),
          $*CWD.Str,
          CLONE-HASH-DECONTAINERIZED(%*ENV),
        )));
    }
    $status
}

sub shell($cmd) {
    my $status = Proc::Status.new( :exit(255) );
    try {
        $status.status(nqp::p6box_i(nqp::shell(
          $cmd,
          $*CWD.Str,
          CLONE-HASH-DECONTAINERIZED(%*ENV),
        )));
    }
    $status
}

constant Inf = nqp::p6box_n(nqp::inf());
constant NaN = nqp::p6box_n(nqp::nan());

sub QX($cmd) {
    my Mu $pio := nqp::openpipe(
      nqp::unbox_s($cmd), $*CWD.Str, CLONE-HASH-DECONTAINERIZED(%*ENV), ''
    );
    fail "Unable to execute '$cmd'" unless $pio;
    my $result = nqp::p6box_s(nqp::readallfh($pio));
    nqp::closefh($pio);
    $result;
}

sub EXHAUST(|) {
    X::ControlFlow::Return.new.throw();
}

sub NOT_ALL_DEFINED_TYPE(\values,\type) {
    for values {
        return True unless nqp::defined($_) && nqp::istype($_,type);
    }
    False;
}

sub CLONE-HASH-DECONTAINERIZED(\hash) {
    my Mu $clone := nqp::hash();
    my Mu $iter  := nqp::iterator(nqp::getattr(hash,EnumMap,'$!storage'));
    my $e;
    while $iter {
        $e := nqp::shift($iter);
        nqp::bindkey($clone, nqp::iterkey_s($e), nqp::decont(nqp::iterval($e)));
    }
    $clone;
}

sub CLONE-LIST-DECONTAINERIZED(*@list) {
    my Mu $list-without := nqp::list();
    nqp::push($list-without, nqp::decont(~$_)) for @list.eager;
    $list-without;
}

# From 'src/core/Mu.pm'

my class X::Constructor::Positional { ... }
my class X::Method::NotFound        { ... }
my class X::Method::InvalidQualifier { ... }
my class Obsolete { ... }

my class Mu { # declared in BOOTSTRAP
    proto method ACCEPTS(|) { * }
    multi method ACCEPTS(Mu:U: Mu \topic) {
        nqp::p6bool(nqp::istype(topic, self))
    }

    method WHERE() {
        nqp::p6box_i(nqp::where(self))
    }

    proto method WHICH(|) {*}
    multi method WHICH(Mu:U:) {
        nqp::box_s(nqp::unbox_s(self.^name), ObjAt);
    }
    multi method WHICH(Mu:D:) {
        nqp::box_s(
            nqp::concat(
                nqp::concat(nqp::unbox_s(self.^name), '|'),
                nqp::objectid(self)
            ),
            ObjAt
        )
    }

    method take {
        take self;
    }

    proto method WHY(|) { * }
    multi method WHY(Mu:) {
        my Mu $why;

        if nqp::can(self.HOW, 'WHY') {
            $why := self.HOW.WHY;
        }

        if $why.defined && !$.defined #`(ie. we're a type object) {
            $why.set_docee(self);
        }
        $why // Any
    }

    method set_why($why) {
        self.HOW.set_why($why);
    }

    proto method Bool(|) {*}
    multi method Bool() {
        self.defined
    }

    method so()  { self.Bool }
    method not() { self ?? False !! True }

    method defined() {
        nqp::p6bool(nqp::isconcrete(self))
    }

    proto method new(|) { * }
    multi method new(*%) {
        nqp::invokewithcapture(nqp::findmethod(self, 'bless'), nqp::usecapture())
    }
    multi method new($, *@) {
        X::Constructor::Positional.new(:type( self )).throw();
    }

    proto method infinite (|) { * }
    multi method infinite(Mu:) { Nil }

    method CREATE() {
        nqp::create(self)
    }

    method bless(*@autovivs, *%attrinit) {
        nqp::create(self).BUILDALL(@autovivs, %attrinit);
    }

    method BUILDALL(@autovivs, %attrinit) {
        # Get the build plan. Note that we do this "low level" to
        # avoid the NQP type getting mapped to a Rakudo one, which
        # would get expensive.
        my $build_plan := nqp::findmethod(self.HOW, 'BUILDALLPLAN')(self.HOW, self);
        my int $count   = nqp::elems($build_plan);
        my int $i       = 0;
        while nqp::islt_i($i, $count) {
            my $task := nqp::atpos($build_plan, $i);
            my int $code = nqp::atpos($task, 0);
            $i = nqp::add_i($i, 1);
            if nqp::iseq_i($code, 0) {
                # Custom BUILD call.
                nqp::atpos($task, 1)(self, |%attrinit);
            }
            elsif nqp::iseq_i($code, 1) {
                # See if we have a value to initialize this attr
                # with.
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    # XXX Should not really need the decontainerize, but seems
                    # that slurpy hashes sometimes lead to double containers
                    # somehow...
                    nqp::getattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3)) = nqp::decont(%attrinit{$key_name});
                }
            }
            elsif nqp::iseq_i($code, 2) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::getattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3)) = nqp::decont(%attrinit{$key_name});
                }
                else {
                    nqp::bindattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3), nqp::list())
                }
            }
            elsif nqp::iseq_i($code, 3) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::getattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3)) = nqp::decont(%attrinit{$key_name});
                }
                else {
                    nqp::bindattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3), nqp::hash())
                }
            }
            elsif nqp::iseq_i($code, 4) {
                unless nqp::attrinited(self, nqp::atpos($task, 1), nqp::atpos($task, 2)) {
                    my \attr := nqp::getattr(self, nqp::atpos($task, 1), nqp::atpos($task, 2));
                    attr = nqp::atpos($task, 3)(self, attr);
                }
            }
            elsif nqp::iseq_i($code, 5) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::bindattr_i(self, nqp::atpos($task, 1), nqp::atpos($task, 3),
                        nqp::decont(%attrinit{$key_name}));
                }
            }
            elsif nqp::iseq_i($code, 6) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::bindattr_n(self, nqp::atpos($task, 1), nqp::atpos($task, 3),
                        nqp::decont(%attrinit{$key_name}));
                }
            }
            elsif nqp::iseq_i($code, 7) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::bindattr_s(self, nqp::atpos($task, 1), nqp::atpos($task, 3),
                        nqp::decont(%attrinit{$key_name}));
                }
            }
            elsif nqp::iseq_i($code, 8) {
                my int $cur_value = nqp::getattr_i(self, nqp::atpos($task, 1), nqp::atpos($task, 2));
                if nqp::iseq_i($cur_value, 0) {
                    nqp::bindattr_i(self, nqp::atpos($task, 1), nqp::atpos($task, 2),
                        nqp::atpos($task, 3)(self, $cur_value));
                }
            }
            elsif nqp::iseq_i($code, 9) {
                my num $cur_value = nqp::getattr_n(self, nqp::atpos($task, 1), nqp::atpos($task, 2));
                if nqp::iseq_n($cur_value, 0e0) {
                    nqp::bindattr_n(self, nqp::atpos($task, 1), nqp::atpos($task, 2),
                        nqp::atpos($task, 3)(self, $cur_value));
                }
            }
            elsif nqp::iseq_i($code, 10) {
                my str $cur_value = nqp::getattr_s(self, nqp::atpos($task, 1), nqp::atpos($task, 2));
                if nqp::isnull_s($cur_value) {
                    nqp::bindattr_s(self, nqp::atpos($task, 1), nqp::atpos($task, 2),
                        nqp::atpos($task, 3)(self, $cur_value));
                }
            }
            else {
                die "Invalid BUILDALLPLAN";
            }
        }
        self
    }

    method BUILD_LEAST_DERIVED(%attrinit) {
        # Get the build plan for just this class.
        my $build_plan := nqp::findmethod(self.HOW, 'BUILDPLAN')(self.HOW, self);
        my int $count   = nqp::elems($build_plan);
        my int $i       = 0;
        while nqp::islt_i($i, $count) {
            my $task := nqp::atpos($build_plan, $i);
            my int $code = nqp::atpos($task, 0);
            $i = nqp::add_i($i, 1);
            if nqp::iseq_i($code, 0) {
                # Custom BUILD call.
                nqp::atpos($task, 1)(self, |%attrinit);
            }
            elsif nqp::iseq_i($code, 1) {
                # See if we have a value to initialize this attr
                # with.
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::getattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3)) = nqp::decont(%attrinit{$key_name});
                }
            }
            elsif nqp::iseq_i($code, 2) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::getattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3)) = nqp::decont(%attrinit{$key_name});
                }
                else {
                    nqp::bindattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3), nqp::list())
                }
            }
            elsif nqp::iseq_i($code, 3) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::getattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3)) = nqp::decont(%attrinit{$key_name});
                }
                else {
                    nqp::bindattr(self, nqp::atpos($task, 1),
                        nqp::atpos($task, 3), nqp::hash())
                }
            }
            elsif nqp::iseq_i($code, 4) {
                unless nqp::attrinited(self, nqp::atpos($task, 1), nqp::atpos($task, 2)) {
                    my \attr := nqp::getattr(self, nqp::atpos($task, 1), nqp::atpos($task, 2));
                    attr = nqp::atpos($task, 3)(self, attr);
                }
            }
            elsif nqp::iseq_i($code, 5) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::bindattr_i(self, nqp::atpos($task, 1), nqp::atpos($task, 3),
                        nqp::decont(%attrinit{$key_name}));
                }
            }
            elsif nqp::iseq_i($code, 6) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::bindattr_n(self, nqp::atpos($task, 1), nqp::atpos($task, 3),
                        nqp::decont(%attrinit{$key_name}));
                }
            }
            elsif nqp::iseq_i($code, 7) {
                my $key_name := nqp::p6box_s(nqp::atpos($task, 2));
                if %attrinit.EXISTS-KEY($key_name) {
                    nqp::bindattr_s(self, nqp::atpos($task, 1), nqp::atpos($task, 3),
                        nqp::decont(%attrinit{$key_name}));
                }
            }
            else {
                die "Invalid BUILDALLPLAN";
            }
        }
        self
    }

    proto method Numeric(|) { * }
    multi method Numeric(Mu:U \v:) {
        warn "use of uninitialized value of type {self.^name} in numeric context";
        0
    }
    proto method Real(|) { * }
    multi method Real(Mu:U \v:) {
        warn "use of uninitialized value of type {self.^name} in numeric context";
        0
    }

    proto method Str(|) { * }
    multi method Str(Mu:U \v:) {
        my $name = (defined($*VAR_NAME) ?? $*VAR_NAME !! v.VAR.?name) // '';
        $name   ~= ' ' if $name ne '';
        warn "use of uninitialized value {$name}of type {self.^name} in string context";
        ''
    }
    multi method Str(Mu:D:) {
        self.^name ~ '<' ~ nqp::tostr_I(self.WHERE) ~ '>'
    }

    proto method Stringy(|) { * }
    multi method Stringy(Mu:U \v:) {
        my $*VAR_NAME = v.VAR.?name;
        self.Str
    }
    multi method Stringy(Mu:D $:) { self.Str }

    method item(Mu \item:) is rw { item }

    proto method say(|) { * }
    multi method say(Obsolete:D:) { say(self.gist) }
    multi method say() { say(self) }
    method print() { print(self) }
    method note() { note(self) }

    proto method gist(|) { * }
    multi method gist(Mu:U:) { '(' ~ self.^name ~ ')' }
    multi method gist(Mu:D:) { self.perl }

    proto method perl(|) { * }
    multi method perl(Mu:U:) { self.^name }
    multi method perl(Mu:D:) {
        my @attrs;
        for self.^attributes().grep: { .has_accessor } -> $attr {
            my $name := substr($attr.Str,2);
            @attrs.push: $name
                        ~ ' => '
                        ~ $attr.get_value(self).perl
        }
        self.^name ~ '.new' ~ ('(' ~ @attrs.join(', ') ~ ')' if @attrs);
    }

    proto method DUMP(|) { * }
    multi method DUMP(Mu:U:) { self.perl }
    multi method DUMP(Mu:D: :$indent-step = 4, :%ctx?) {
        return DUMP(self, :$indent-step) unless %ctx;

        my Mu $attrs := nqp::list();
        for self.^attributes -> $attr {
            my str $name       = $attr.name;
            my str $acc_name   = nqp::substr($name, 2, nqp::chars($name) - 2);
            my str $build_name = $attr.has_accessor ?? $acc_name !! $name;

            my Mu $value;
            if    $attr.has_accessor {
                $value := self."$acc_name"();
            }
            elsif nqp::can($attr, 'get_value') {
                $value := $attr.get_value(self);
            }
            elsif nqp::can($attr, 'package') {
                my Mu $decont  := nqp::decont(self);
                my Mu $package := $attr.package;

                $value := do given nqp::p6box_i(nqp::objprimspec($attr.type)) {
                    when 0 {              nqp::getattr(  $decont, $package, $name)  }
                    when 1 { nqp::p6box_i(nqp::getattr_i($decont, $package, $name)) }
                    when 2 { nqp::p6box_n(nqp::getattr_n($decont, $package, $name)) }
                    when 3 { nqp::p6box_s(nqp::getattr_s($decont, $package, $name)) }
                };
            }
            else {
                next;
            }

            nqp::push($attrs, $build_name);
            nqp::push($attrs, $value);
        }

        self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx);
    }
    method DUMP-PIECES(@pieces: $before, $after = ')', :$indent = @pieces > 1, :$indent-step) {
        $indent ?? $before ~ "\n" ~ @pieces.join(",\n").indent($indent-step) ~ "\n" ~ $after
                !! $before ~        @pieces.join(', ')                              ~ $after;
    }
    method DUMP-OBJECT-ATTRS(|args (*@args, :$indent-step, :%ctx, :$flags?)) {
        my Mu  $attrs := nqp::clone(nqp::captureposarg(nqp::usecapture(), 1));
        my str $where  = nqp::base_I(nqp::where(self), 16);
        my str $before = ($flags if defined $flags) ~ self.^name ~ '<' ~ %ctx{$where} ~ '>(';

        my @pieces;
        while $attrs {
            my str $name  = nqp::shift($attrs);
            my Mu $value := nqp::shift($attrs);
            @pieces.push: ':' ~ $name ~ '(' ~ DUMP($value, :$indent-step, :%ctx) ~ ')';
        }
        @pieces.DUMP-PIECES($before, :$indent-step);
    }

    proto method isa(|) { * }
    multi method isa(Mu \SELF: Mu $type) {
        nqp::p6bool(SELF.^isa($type.WHAT))
    }
    multi method isa(Mu \SELF: Str:D $name) {
        my @mro = SELF.^mro;
        my int $mro_count = +@mro;
        my int $i = 0;
        while $i < $mro_count {
            my $obj = @mro[$i];
            if $obj.^name eq $name {
                return Bool::True;
            }
            $i = $i + 1;
        }
        Bool::False
    }

    method does(Mu \SELF: Mu $type) {
        nqp::p6bool(nqp::istype(SELF, $type.WHAT))
    }

    method can(Mu \SELF: $name) {
        SELF.^can($name)
    }

    method clone(*%twiddles) {
        my $cloned := nqp::clone(nqp::decont(self));
        for self.^attributes() -> $attr {
            my $name := $attr.name;
            my $package := $attr.package;
            unless nqp::objprimspec($attr.type) {
                my $attr_val := nqp::getattr($cloned, $package, $name);
                nqp::bindattr($cloned, $package, $name, nqp::clone($attr_val.VAR))
                    if nqp::iscont($attr_val);
            }
            my $acc_name := substr($name,2);
            if $attr.has-accessor && %twiddles.EXISTS-KEY($acc_name) {
                nqp::getattr($cloned, $package, $name) = %twiddles{$acc_name};
            }
        }
        $cloned
    }

    method Capture() {
        my %attrs;
        for self.^attributes -> $attr {
            if $attr.has-accessor {
                my $name = substr($attr.name,2);
                unless %attrs.EXISTS-KEY($name) {
                    %attrs{$name} = self."$name"();
                }
            }
        }
        %attrs.Capture
    }

    # XXX TODO: Handle positional case.
    method dispatch:<var>(Mu \SELF: $var, |c) is rw is hidden-from-backtrace {
        $var(SELF, |c)
    }

    method dispatch:<::>(Mu \SELF: $name, Mu $type, |c) is rw {
        unless nqp::istype(SELF, $type) {
            X::Method::InvalidQualifier.new(
                    method          => $name,
                    invocant        => SELF,
                    qualifier-type  => $type,

            ).throw;
        }
        self.^find_method_qualified($type, $name)(SELF, |c)
    }

    method dispatch:<!>(Mu \SELF: $name, Mu $type, |c) is rw is hidden-from-backtrace {
        my $meth := $type.^find_private_method($name);
        $meth ??
            $meth(SELF, |c) !!
            X::Method::NotFound.new(
              invocant => SELF,
              method   => '!' ~ $name,
              typename => $type.^name,
              :private,
            ).throw;
    }

    method dispatch:<.^>(Mu \SELF: $name, |c) is rw is hidden-from-backtrace {
        self.HOW."$name"(SELF, |c)
    }

    method dispatch:<.=>(\mutate: $name, |c) is rw {
        $/ := nqp::getlexcaller('$/');
        mutate = mutate."$name"(|c)
    }

    method dispatch:<.?>(Mu \SELF: $name, |c) is rw is hidden-from-backtrace {
        nqp::can(SELF, $name) ??
            SELF."$name"(|c) !!
            Nil
    }

    method dispatch:<.+>(Mu \SELF: $name, |c) {
        my @result := SELF.dispatch:<.*>($name, |c);
        if @result.elems == 0 {
            X::Method::NotFound.new(
              invocant => SELF,
              method   => $name,
              typename => SELF.^name,
            ).throw;
        }
        @result
    }

    method dispatch:<.*>(Mu \SELF: $name, |c) {
        my @mro = SELF.^mro;
        my int $mro_count = +@mro;
        my @results;
        my int $i = 0;
        while $i < $mro_count {
            my $obj = @mro[$i];
            my $meth = ($obj.^method_table){$name};
            if !$meth && $i == 0 {
                $meth = ($obj.^submethod_table){$name};
            }
            if $meth {
                @results.push($meth(SELF, |c));
            }
            $i = $i + 1;
        }
        &infix:<,>(|@results)
    }

    method dispatch:<hyper>(Mu \SELF: $name, |c) {
        c
            ?? hyper( -> \obj { obj."$name"(|c) }, SELF )
            !! hyper( -> \obj { obj."$name"() }, SELF )
    }

    method WALK(:$name!, :$canonical, :$ascendant, :$descendant, :$preorder, :$breadth,
                :$super, :$omit, :$include) {
        # First, build list of classes in the order we'll need them.
        my @classes;
        if $super {
            @classes = self.^parents(:local);
        }
        elsif $breadth {
            my @search_list = self.WHAT;
            while @search_list {
                push @classes, @search_list;
                my @new_search_list;
                for @search_list -> $current {
                    for $current.^parents(:local) -> $next {
                        unless @new_search_list.grep({ $^c.WHAT =:= $next.WHAT }) {
                            push @new_search_list, $next;
                        }
                    }
                }
                @search_list = @new_search_list;
            }
        } elsif $ascendant | $preorder {
            sub build_ascendent(Mu $class) {
                unless @classes.grep({ $^c.WHAT =:= $class.WHAT }) {
                    push @classes, $class;
                    for $class.^parents(:local) {
                        build_ascendent($^parent);
                    }
                }
            }
            build_ascendent(self.WHAT);
        } elsif $descendant {
            sub build_descendent(Mu $class) {
                unless @classes.grep({ $^c.WHAT =:= $class.WHAT }) {
                    for $class.^parents(:local) {
                        build_descendent($^parent);
                    }
                    push @classes, $class;
                }
            }
            build_descendent(self.WHAT);
        } else {
            # Canonical, the default (just whatever the meta-class says) with us
            # on the start.
            @classes = self.^mro();
        }

        # Now we have classes, build method list.
        my @methods;
        for @classes -> $class {
            if (!defined($include) || $include.ACCEPTS($class)) &&
              (!defined($omit) || !$omit.ACCEPTS($class)) {
                try {
                    for $class.^methods(:local) -> $method {
                        my $check_name = $method.?name;
                        if $check_name.defined && $check_name eq $name {
                            @methods.push($method);
                        }
                    }
                    0;
                }
            }
        }

        return @methods;
    }
}


proto sub defined(Mu) is pure { * }
multi sub defined(Mu \x) { x.defined }

proto sub infix:<~~>(|) { * }
multi sub infix:<~~>(Mu \topic, Mu \matcher) {
    matcher.ACCEPTS(topic).Bool;
}

proto sub infix:<=:=>(Mu $?, Mu $?) { * }
multi sub infix:<=:=>($?)      { Bool::True }
multi sub infix:<=:=>(Mu \a, Mu \b) {
    nqp::p6bool(nqp::eqaddr(a, b));
}

proto sub infix:<eqv>(Any $?, Any $?) { * }
multi sub infix:<eqv>($?)            { Bool::True }
multi sub infix:<eqv>(Any $a, Any $b) {
    $a.WHICH eq $b.WHICH
}

multi sub infix:<eqv>(@a, @b) {
    unless @a.WHAT === @b.WHAT && (my int $n = @a.elems) == @b.elems {
        return Bool::False
    }
    my int $i = 0;
    while $i < $n {
        return Bool::False unless @a.AT-POS($i) eqv @b.AT-POS($i);
        $i = $i + 1;
    }
    Bool::True
}

sub DUMP(|args (*@args, :$indent-step = 4, :%ctx?)) {
    my Mu $capture := nqp::usecapture();
    my Mu $topic   := nqp::captureposarg($capture, 0);

    return "\x25b6" ~ DUMP(nqp::decont($topic), :$indent-step, :%ctx)
        if nqp::iscont($topic);
    return '(null)' if nqp::isnull($topic);

    my str $type  = $topic.^name;
    my str $where = nqp::base_I(nqp::where($topic), 16);

    if %ctx{$where} -> $obj_num {
        nqp::istype($topic, Bool) ?? $topic.DUMP(:$indent-step, :%ctx)  !!
        nqp::isconcrete($topic)   ?? '=' ~ $type ~ '<' ~ $obj_num ~ '>' !!
        nqp::can($topic, 'DUMP')  ?? $topic.DUMP(:$indent-step, :%ctx)  !!
                                     $type;
    }
    else {
        my int $obj_num = %ctx.elems + 1;
        %ctx{$where} = $obj_num;

        if    nqp::islist($topic) {
            my str $id = $type ~ '<' ~ $obj_num ~ '>';

            my @pieces;
            $topic := nqp::clone($topic);
            while $topic {
                my Mu $x := nqp::shift($topic);
                @pieces.push: DUMP($x, :$indent-step, :%ctx);
            }

            @pieces.DUMP-PIECES($id ~ '(', :$indent-step);
        }
        elsif nqp::ishash($topic) {
            my str $id = $type ~ '<' ~ $obj_num ~ '>';

            my @pieces;
            {
                for $topic {
                    @pieces.push: $_.key ~ ' => ' ~ DUMP($_.value, :$indent-step, :%ctx);
                }
                CATCH { default { @pieces.push: '...' } }
            }

            @pieces.DUMP-PIECES($id ~ '(', :$indent-step);
        }
        elsif nqp::can($topic, 'DUMP') {
            $topic.DUMP(:$indent-step, :%ctx);
        }
        else {
            given nqp::p6box_i(nqp::captureposprimspec($capture, 0)) {
                when 0 { $type ~ '<' ~ $obj_num ~ '>(...)' }
                when 1 { nqp::captureposarg_i($capture, 0).DUMP(:$indent-step, :%ctx) }
                when 2 { nqp::captureposarg_n($capture, 0).DUMP(:$indent-step, :%ctx) }
                when 3 { nqp::captureposarg_s($capture, 0).DUMP(:$indent-step, :%ctx) }
            }
        }
    }
}

multi sub so(Mu $x)  { ?$x }
multi sub not(Mu $x) { !$x }

Metamodel::ClassHOW.exclude_parent(Mu);

# From 'src/core/Stringy.pm'

my role Stringy { }

multi sub infix:<eqv>(Stringy:D $a, Stringy:D $b) {
    $a.WHAT === $b.WHAT && ($a cmp $b) == 0
}

proto sub prefix:<~>($) is pure { * }
multi sub prefix:<~>(\a)          { a.Stringy }
multi sub prefix:<~>(int $a)      { nqp::p6box_s($a) }
multi sub prefix:<~>(num $a)      { nqp::p6box_s($a) }

proto sub infix:<~>(|) is pure { * }
multi sub infix:<~>($x = '')       { $x.Stringy }
multi sub infix:<~>(\a, \b)      { a.Stringy ~ b.Stringy }

proto sub infix:<x>(Mu $?, Mu $?)        { * }
multi sub infix:<x>()              { fail "No zero-arg meaning for infix:<x>" }
multi sub infix:<x>($x)            { $x.Stringy }
multi sub infix:<x>($s, $n)        { $s.Stringy x ($n.Int // 0) }

proto sub infix:<leg>(Mu $?, Mu $?) is pure { * }
multi sub infix:<leg>(\a, \b)      { a.Stringy cmp b.Stringy }

proto sub infix:<eq>(Mu $?, Mu $?)  is pure { * }
multi sub infix:<eq>($x?)          { Bool::True }
multi sub infix:<eq>(\a, \b)       { a.Stringy eq b.Stringy }

proto sub infix:<ne>(Mu $?, Mu $?) is pure { * }
multi sub infix:<ne>($x?)            { Bool::True }
multi sub infix:<ne>(Mu \a, Mu \b)   { a !eq b }

proto sub infix:<lt>(Mu $?, Mu $?) is pure { * }
multi sub infix:<lt>($x?)          { Bool::True }
multi sub infix:<lt>(\a, \b)       { a.Stringy lt b.Stringy }

proto sub infix:<le>(Mu $?, Mu $?) is pure { * }
multi sub infix:<le>($x?)          { Bool::True }
multi sub infix:<le>(\a, \b)       { a.Stringy le b.Stringy }

proto sub infix:<gt>(Mu $?, Mu $?) is pure { * }
multi sub infix:<gt>($x?)          { Bool::True }
multi sub infix:<gt>(\a, \b)       { a.Stringy gt b.Stringy }

proto sub infix:<ge>(Mu $?, Mu $?) is pure { * }
multi sub infix:<ge>($x?)          { Bool::True }
multi sub infix:<ge>(\a, \b)       { a.Stringy ge b.Stringy }

proto sub infix:<~|>(Mu $?, Mu $?) is pure { * }
multi sub infix:<~|>($x = '')      { $x.Stringy }
multi sub infix:<~|>(\a, \b)       { a.Stringy ~| b.Stringy }

proto sub infix:<~^>(Mu $?, Mu $?)  is pure { * }
multi sub infix:<~^>($x = '')      { $x.Stringy }
multi sub infix:<~^>(\a, \b)       { a.Stringy ~^ b.Stringy }

proto sub infix:<~&>(Mu $?, Mu $?) is pure { * }
multi sub infix:<~&>()             { fail "No zero-arg meaning for infix:<~&>" }
multi sub infix:<~&>($x)           { $x.Stringy }
multi sub infix:<~&>(\a, \b)       { a.Stringy ~& b.Stringy }

proto sub prefix:<~^>(Mu $) is pure { * }
multi sub prefix:<~^>(\a)         { ~^ a.Stringy }

# From 'src/core/Any.pm'

my class MapIter                { ... }
my class Pair                   { ... }
my class Range                  { ... }
my class X::Bind                { ... }
my class X::Bind::Slice         { ... }
my class X::Bind::ZenSlice      { ... }
my class X::Item                { ... }
my class X::Match::Bool         { ... }
my class X::Pairup::OddNumber   { ... }
my class X::Subscript::Negative { ... }

my role  Numeric { ... }

my class Any { # declared in BOOTSTRAP
    # my class Any is Mu {

    multi method ACCEPTS(Any:D: Mu \a) { self === a }

    method invoke(|c) {
        DEPRECATED('CALL-ME',|<2015.03 2016.03>);
        self.CALL-ME(|c);
    }

    method exists_key(|c) {
        DEPRECATED('EXISTS-KEY',|<2015.03 2016.03>);
        self.EXISTS-KEY(|c);
    }

    proto method EXISTS-KEY(|){ * }
    multi method EXISTS-KEY(Any:U: $) { False }
    multi method EXISTS-KEY(Any:D: $) { False }

    method delete_key(|c) {
        DEPRECATED('DELETE-KEY',|<2015.03 2016.03>);
        self.DELETE-KEY(|c);
    }

    proto method DELETE-KEY(|) { * }
    multi method DELETE-KEY(Any:U: $) { Nil }
    multi method DELETE-KEY(Any:D: $) {
        fail "Can not remove values from a {self.^name}";
    }

    method delete_pos(|c) {
        DEPRECATED('DELETE-POS',|<2015.03 2016.03>);
        self.DELETE-POS(|c);
    }

    proto method DELETE-POS(|) { * }
    multi method DELETE-POS(Any:U: $pos) { Nil }
    multi method DELETE-POS(Any:D: $pos) {
        fail "Can not remove elements from a {self.^name}";
    }

    proto method list(|) { * }
    multi method list(Any:U:) { nqp::p6list(nqp::list(),     List, Mu) }
    multi method list(Any:D:) { nqp::p6list(nqp::list(self), List, Mu) }

    proto method flat(|) { * }
    multi method flat(Any:U:) { nqp::p6list(nqp::list(),     List, Bool::True) }
    multi method flat(Any:D:) { nqp::p6list(nqp::list(self), List, Bool::True) }

    proto method eager(|) { * }
    multi method eager(Any:U:) {
        nqp::p6list(nqp::list(),     List, Mu).eager;
    }
    multi method eager(Any:D:) {
        nqp::p6list(nqp::list(self), List, Mu).eager;
    }

    proto method hash(|) { * }
    multi method hash(Any:U:) { my % = () }
    multi method hash(Any:D:) { my % = self }
    method Hash() { self.hash }

    # derived from .list
    method Parcel() { self.list.Parcel }
    method List() { self.list }

    proto method elems(|) { * }
    multi method elems(Any:U:) { 0 }
    multi method elems(Any:D:) { self.list.elems }

    proto method end(|) { * }
    multi method end(Any:U:) { -1 }
    multi method end(Any:D:) { self.list.end }

    proto method keys(|) { * }
    multi method keys(Any:U:) { ().list }
    multi method keys(Any:D:) { self.list.keys }

    proto method kv(|) { * }
    multi method kv(Any:U:) { ().list }
    multi method kv(Any:D:) { self.list.kv }

    proto method values(|) { * }
    multi method values(Any:U:) { ().list }
    multi method values(Any:D:) { self.list }

    proto method pairs(|) { * }
    multi method pairs(Any:U:) { ().list }
    multi method pairs(Any:D:) { self.list.pairs }

    proto method antipairs(|) { * }
    multi method antipairs(Any:U:) { ().list }
    multi method antipairs(Any:D:) { self.list.antipairs }

    proto method invert(|) { * }

    proto method pairup(|) { * }
    multi method pairup(Any:U:) { ().list }
    multi method pairup(Any:D:) {

        my $list := self.list;
        my int $i;
        my int $elems = self.elems;

        gather while $i < $elems {
            my Mu $it := $list.AT-POS($i++);
            if nqp::istype($it,Enum) {
                take $it.key => $it.value;
            }
            elsif nqp::istype($it,EnumMap) and !nqp::iscont($it) {
                take $it.pairs;
            }
            elsif $i < $elems {
                take $it => $list.AT-POS($i++);
            }
            else {
                X::Pairup::OddNumber.new.throw;
            }
        }
    }

    method squish(|c) { self.list.squish(|c) }
    method rotor(|c) { self.list.rotor(|c) }
    method reverse() { self.list.reverse }
    method sort($by = &infix:<cmp>) { self.list.sort($by) }
    method reduce(&with) { self.list.reduce(&with) }
    method combinations(|c) { self.list.combinations(|c) }
    method permutations(|c) { self.list.permutations(|c) }

    method unique(|c) { self.list.unique(|c) }
    method uniq(|c) {
        DEPRECATED('unique', |<2014.11 2015.11>);
        self.unique(|c);
    }

    proto method pick(|) { * }
    multi method pick()   { self.list.pick     }
    multi method pick($n) { self.list.pick($n) }

    proto method roll(|) { * }
    multi method roll()   { self.list.roll     }
    multi method roll($n) { self.list.roll($n) }

    proto method classify(|) { * }
    multi method classify($test)   {
        Hash.^parameterize(Any,Any).new.classify-list( $test, self.list );
    }
    multi method classify($test, :$into!)   {
        ( $into // $into.new ).classify-list( $test, self.list );
    }

    proto method categorize(|) { * }
    multi method categorize($test) {
        Hash.^parameterize(Any,Any).new.categorize-list( $test, self.list );
    }
    multi method categorize($test, :$into!) {
        ( $into // $into.new ).categorize-list( $test, self.list );
    }

    # derived from MapIter/list
    method lol()  {
        MapIter.new(self.list, { .item }, Mu).list
    }
    proto method map (|) { * }
    multi method map(Whatever) is rw { self }
    multi method map($block, :$label) is rw {
        MapIter.new(self, $block, Bool::True, :$label).list
    }
    proto method for (|) { * }
    multi method for(Whatever) is rw { self }
    multi method for($block, :$label) is rw {
        MapIter.new(self, $block, Bool::True, :$label).list
    }
    method flatmap($block) is rw { flatmap($block, self) }
    method duckmap($block) is rw { duckmap($block, self) }
    method deepmap($block) is rw { deepmap($block, self) }

    proto method tree(|) { * }
    multi method tree(Any:U:) { self }
    multi method tree(Any:D:) {
        nqp::istype(self,Positional)
            ?? LoL.new(|MapIter.new(self.list, { .tree }, Mu).list).item
            !! self
    }
    multi method tree(Any:D: Whatever ) { self.tree }
    multi method tree(Any:D: Int(Cool) $count) {
        nqp::istype(self,Positional) && $count > 0
            ?? LoL.new(|MapIter.new(self.list, { .tree($count - 1) }, Mu).list).item
            !! self
    }
    multi method tree(Any:D: *@ [&first, *@rest]) {
        nqp::istype(self,Positional)
            ?? @rest ?? first MapIter.new(self.list, { .tree(|@rest) }, Mu).list
                     !! first self.list
            !! self
    }

    method Array() { Array.new(self.flat) }

    # auto-vivifying
    proto method push(|) { * }
    multi method push(Any:U \SELF: *@values) {
        SELF = nqp::istype(SELF,Positional) ?? SELF.new !! Array.new;
        SELF.push(@values);
    }

    proto method unshift(|) { * }
    multi method unshift(Any:U \SELF: *@values) {
        SELF = Array.new;
        SELF.unshift(@values);
    }

    proto method grep(|) { * }
    multi method grep(Bool:D $t) is rw {
        fail X::Match::Bool.new( type => '.grep' );
    }
    multi method grep(Regex:D $test) is rw {
        self.map({ next unless .match($test); $_ });
    }
    multi method grep(Callable:D $test) is rw {
        self.map({ next unless $test($_); $_ });
    }
    multi method grep(Mu $test) is rw {
        self.map({ next unless $_ ~~ $test; $_ });
    }

    proto method grep-index(|) { * }
    multi method grep-index(Bool:D $t) is rw {
        fail X::Match::Bool.new( type => '.grep-index' );
    }
    multi method grep-index(Regex:D $test) {
        my int $index = -1;
        self.map: {
            $index = $index+1;
            next unless .match($test);
            nqp::box_i($index,Int);
        };
    }
    multi method grep-index(Callable:D $test) {
        my int $index = -1;
        self.map: {
            $index = $index + 1;
            next unless $test($_);
            nqp::box_i($index,Int);
        };
    }
    multi method grep-index(Mu $test) {
        my int $index = -1;
        self.map: {
            $index = $index + 1;
            next unless $_ ~~ $test;
            nqp::box_i($index,Int);
        };
    }

    proto method first(|) { * }
    multi method first(Bool:D $t) is rw {
        fail X::Match::Bool.new( type => '.first' );
    }
    multi method first(Regex:D $test) is rw {
        self.map({ return-rw $_ if .match($test) });
        Nil;
    }
    multi method first(Callable:D $test) is rw {
        self.map({ return-rw $_ if $test($_) });
        Nil;
    }
    multi method first(Mu $test) is rw {
        self.map({ return-rw $_ if $_ ~~ $test });
        Nil;
    }

    proto method first-index(|) { * }
    multi method first-index(Bool:D $t) is rw {
        fail X::Match::Bool.new( type => '.first-index' );
    }
    multi method first-index(Regex:D $test) {
        my int $index = -1;
        self.map: {
            $index = $index + 1;
            return nqp::box_i($index,Int) if .match($test);
        };
        Nil;
    }
    multi method first-index(Callable:D $test) {
        my int $index = -1;
        self.map: {
            $index = $index + 1;
            return nqp::box_i($index,Int) if $test($_);
        };
        Nil;
    }
    multi method first-index(Mu $test) {
        my int $index = -1;
        self.map: {
            $index = $index + 1;
            return nqp::box_i($index,Int) if $_ ~~ $test;
        };
        Nil;
    }

    proto method last-index(|) { * }
    multi method last-index(Bool:D $t) is rw {
        fail X::Match::Bool.new( type => '.last-index' );
    }
    multi method last-index(Regex:D $test) {
        my $elems = self.elems;
        return Inf if $elems == Inf;

        my int $index = $elems;
        while $index {
            $index = $index - 1;
            return nqp::box_i($index,Int) if self.AT-POS($index).match($test);
        }
        Nil;
    }
    multi method last-index(Callable:D $test) {
        my $elems = self.elems;
        return Inf if $elems == Inf;

        my int $index = $elems;
        while $index {
            $index = $index - 1;
            return nqp::box_i($index,Int) if $test(self.AT-POS($index));
        }
        Nil;
    }
    multi method last-index(Mu $test) {
        my $elems = self.elems;
        return Inf if $elems == Inf;

        my int $index = $elems;
        while $index {
            $index = $index - 1;
            return nqp::box_i($index,Int) if self.AT-POS($index) ~~ $test;
        }
        Nil;
    }

    method join($separator = '') {
        my $list = (self,).flat.eager;
        my Mu $rsa := nqp::list_s();
        $list.gimme(4);        # force reification of at least 4 elements
        unless $list.infinite {  # presize array
            nqp::setelems($rsa, nqp::unbox_i($list.elems));
            nqp::setelems($rsa, 0);
        }
        my $tmp;
        while $list.gimme(0) {
            $tmp := $list.shift;
            nqp::push_s($rsa,
              nqp::unbox_s(nqp::istype($tmp, Str) && nqp::isconcrete($tmp) ?? $tmp !! $tmp.Str));
        }
        nqp::push_s($rsa, '...') if $list.infinite;
        nqp::p6box_s(nqp::join(nqp::unbox_s($separator.Str), $rsa))
    }

    proto method min (|) { * }
    multi method min(Any:D:) {
        my $min;
        for self {
            $min = $_ if .defined and !$min.defined || $_ cmp $min < 0;
        }
        $min // Inf;
    }
    multi method min(Any:D: $by) {
        my $cmp = $by.arity == 2 ?? $by !! { $by($^a) cmp $by($^b) }
        my $min;
        for self {
            $min = $_ if .defined and !$min.defined || $cmp($_, $min) < 0;
        }
        $min // Inf;
    }

    proto method max (|) { * }
    multi method max(Any:D:) {
        my $max;
        for self {
            $max = $_ if .defined and !$max.defined || $_ cmp $max > 0;
        }
        $max // -Inf;
    }
    multi method max(Any:D: $by) {
        my $cmp = $by.arity == 2 ?? $by !! { $by($^a) cmp $by($^b) }
        my $max;
        for self {
            $max = $_ if .defined and !$max.defined || $cmp($_, $max) > 0;
        }
        $max // -Inf;
    }

    proto method minmax (|) { * }
    multi method minmax(Any:D: $by = &infix:<cmp>) {
        my $cmp = $by.arity == 2 ?? $by !! { $by($^a) cmp $by($^b) };

        my $min;
        my $max;
        my $excludes-min = Bool::False;
        my $excludes-max = Bool::False;

        for @.list {
            .defined or next;

            if .isa(Range) {
                if !$min.defined || $cmp($_.min, $min) < 0 {
                    $min = .min;
                    $excludes-min = $_.excludes-min;
                }
                if !$max.defined || $cmp($_.max, $max) > 0 {
                    $max = .max;
                    $excludes-max = $_.excludes-max;
                }
            } elsif Positional.ACCEPTS($_) {
                my $mm = .minmax($by);
                if !$min.defined || $cmp($mm.min, $min) < 0 {
                    $min = $mm.min;
                    $excludes-min = $mm.excludes-min;
                }
                if !$max.defined || $cmp($mm.max, $max) > 0 {
                    $max = $mm.max;
                    $excludes-max = $mm.excludes-max;
                }
            } else {
                if !$min.defined || $cmp($_, $min) < 0 {
                    $min = $_;
                    $excludes-min = Bool::False;
                }
                if !$max.defined || $cmp($_, $max) > 0 {
                    $max = $_;
                    $excludes-max = Bool::False;
                }
            }
        }
        Range.new($min // Inf,
                  $max // -Inf,
                  :excludes-min($excludes-min),
                  :excludes-max($excludes-max));
    }

    method exists_pos(|c) {
        DEPRECATED('EXISTS-POS',|<2015.03 2016.03>);
        self.EXISTS-POS(|c);
    }

    proto method EXISTS-POS(|) { * }
    multi method EXISTS-POS(Any:U: Any:D $) { False }
    multi method EXISTS-POS(Any:U: Any:U $pos) is rw {
        die "Cannot use '{$pos.^name}' as an index";
    }

    multi method EXISTS-POS(Any:D: int \pos) {
        nqp::p6bool(nqp::iseq_i(pos,0));
    }
    multi method EXISTS-POS(Any:D: Int:D \pos) {
        pos == 0;
    }
    multi method EXISTS-POS(Any:D: Num:D \pos) {
        X::Item.new(aggregate => self, index => pos).throw
          if nqp::isnanorinf(pos);
        self.AT-POS(nqp::unbox_i(pos.Int));
        pos == 0;
    }
    multi method EXISTS-POS(Any:D: Any:D \pos) {
        pos.Int == 0;
    }
    multi method EXISTS-POS(Any:D: Any:U \pos) {
        die "Cannot use '{pos.^name}' as an index";
    }

    method at_pos(|c) is rw {
        DEPRECATED('AT-POS',|<2015.03 2016.03>);
        self.AT-POS(|c);
    }

    proto method AT-POS(|) {*}
    multi method AT-POS(Any:U \SELF: int \pos) is rw {
        nqp::bindattr(my $v, Scalar, '$!whence',
            -> { SELF.defined || (SELF = Array.new);
                 SELF.BIND-POS(pos, $v) });
        $v
    }
    multi method AT-POS(Any:U \SELF: Int:D \pos) is rw {
        nqp::bindattr(my $v, Scalar, '$!whence',
            -> { SELF.defined || (SELF = Array.new);
                 SELF.BIND-POS(nqp::unbox_i(pos), $v) });
        $v
    }
    multi method AT-POS(Any:U: Num:D \pos) is rw {
        fail X::Item.new(aggregate => self, index => pos)
          if nqp::isnanorinf(pos);
        self.AT-POS(nqp::unbox_i(pos.Int));
    }
    multi method AT-POS(Any:U: Any:D \pos) is rw {
        self.AT-POS(nqp::unbox_i(pos.Int));
    }

    multi method AT-POS(Any:D: int \pos) is rw {
        fail X::OutOfRange.new(:what<Index>, :got(pos), :range<0..0>)
          unless nqp::not_i(pos);
        self;
    }
    multi method AT-POS(Any:D: Int:D \pos) is rw {
        fail X::OutOfRange.new(:what<Index>, :got(pos), :range<0..0>)
          if pos != 0;
        self;
    }
    multi method AT-POS(Any:D: Num:D \pos) is rw {
        fail X::Item.new(aggregate => self, index => pos)
          if nqp::isnanorinf(pos);
        self.AT-POS(nqp::unbox_i(pos.Int));
    }
    multi method AT-POS(Any:D: Any:D \pos) is rw {
        self.AT-POS(nqp::unbox_i(pos.Int));
    }

    multi method AT-POS(Any:   Any:U \pos) is rw {
        die "Cannot use '{pos.^name}' as an index";
    }

    method bind_pos(|c) is rw {
        DEPRECATED('BIND-POS',|<2015.03 2016.03>);
        self.BIND-POS(|c);
    }

    method assign_pos(|c) {
        DEPRECATED('ASSIGN-POS',|<2015.03 2016.03>);
        self.ASSIGN-POS(|c);
    }

    proto method ASSIGN-POS(|) { * }
    multi method ASSIGN-POS(Any:U \SELF: \pos, Mu \assignee) {
       SELF.AT-POS(pos) = assignee;                     # defer < 0 check
    }

    multi method ASSIGN-POS(Any:D: int \pos, Mu \assignee) {
        self.AT-POS(pos) = assignee;                    # defer < 0 check
    }
    multi method ASSIGN-POS(Any:D: Int:D \pos, Mu \assignee) {
        self.AT-POS(pos) = assignee;                    # defer < 0 check
    }
    multi method ASSIGN-POS(Any:D: Num:D \pos, Mu \assignee) {
        fail X::Item.new(aggregate => self, index => pos)
          if nqp::isnanorinf(pos);
        self.AT-POS(nqp::unbox_i(pos.Int)) = assignee;  # defer < 0 check
    }
    multi method ASSIGN-POS(Any:D: Any:D \pos, Mu \assignee) {
        self.AT-POS(nqp::unbox_i(pos.Int)) = assignee;  # defer < 0 check
    }
    multi method ASSIGN-POS(Any:D: Any:U \pos, Mu \assignee) {
        die "Cannot use '{pos.^name}' as an index";
    }

    method all() { all(self.list) }
    method any() { any(self.list) }
    method one() { one(self.list) }
    method none() { none(self.list) }

    method at_key(|c) is rw {
        DEPRECATED('AT-KEY',|<2015.03 2016.03>);
        self.AT-KEY(|c);
    }

    # internals
    proto method AT-KEY(|) { * }
    multi method AT-KEY(Any:D: $key) is rw {
        fail "postcircumfix:<\{ \}> not defined for type {self.WHAT.perl}";
    }
    multi method AT-KEY(Any:U \SELF: $key) is rw {
        nqp::bindattr(my $v, Scalar, '$!whence',
            -> { SELF.defined || (SELF = Hash.new);
                 SELF.BIND-KEY($key, $v) });
        $v
    }

    method bind_key(|c) is rw {
        DEPRECATED('BIND-KEY',|<2015.03 2016.03>);
        self.BIND-KEY(|c);
    }

    proto method BIND-KEY(|) { * }
    multi method BIND-KEY(Any:D: \k, \v) is rw {
        fail X::Bind.new(target => self.^name);
    }
    multi method BIND-KEY(Any:U \SELF: $key, $BIND ) is rw {
        SELF = Hash.new;
        SELF.BIND-KEY($key, $BIND);
        $BIND
    }

    method assign_key(|c) {
        DEPRECATED('ASSIGN-KEY',|<2015.03 2016.03>);
        self.ASSIGN-KEY(|c);
    }

    proto method ASSIGN-KEY(|) { * }
    multi method ASSIGN-KEY(\SELF: \key, Mu \assignee) {
        SELF.AT-KEY(key) = assignee;
    }

    method FLATTENABLE_LIST() {
        my $list := self.list;
        nqp::findmethod($list, 'FLATTENABLE_LIST')($list);
    }
    method FLATTENABLE_HASH() { nqp::hash() }

    method Set()     {     Set.new-from-pairs(self.list) }
    method SetHash() { SetHash.new-from-pairs(self.list) }
    method Bag()     {     Bag.new-from-pairs(self.list) }
    method BagHash() { BagHash.new-from-pairs(self.list) }
    method Mix()     {     Mix.new-from-pairs(self.list) }
    method MixHash() { MixHash.new-from-pairs(self.list) }

    method Supply() { self.list.Supply }
}
Metamodel::ClassHOW.exclude_parent(Any);

proto sub infix:<===>(Mu $?, Mu $?) is pure { * }
multi sub infix:<===>($?)    { Bool::True }
multi sub infix:<===>($a, $b) {
    nqp::p6bool(nqp::iseq_s(nqp::unbox_s($a.WHICH), nqp::unbox_s($b.WHICH)))
}

proto sub infix:<before>(Mu $, Mu $?)  is pure { * }
multi sub infix:<before>($?)      { Bool::True }
multi sub infix:<before>(\a, \b)   { (a cmp b) < 0 }

proto sub infix:<after>(Mu $, Mu $?) is pure { * }
multi sub infix:<after>($x?)       { Bool::True }
multi sub infix:<after>(\a, \b)    { (a cmp b) > 0 }

proto prefix:<++>(|)             { * }
multi prefix:<++>(Mu:D \a is rw) { a = a.succ }
multi prefix:<++>(Mu:U \a is rw) { a = 1 }
proto prefix:<-->(|)             { * }
multi prefix:<-->(Mu:D \a is rw) { a = a.pred }
multi prefix:<-->(Mu:U \a is rw) { a = -1 }

proto postfix:<++>(|)             { * }
multi postfix:<++>(Mu:D \a is rw) { my $b = a; a = a.succ; $b }
multi postfix:<++>(Mu:U \a is rw) { a = 1; 0 }
proto postfix:<-->(|)             { * }
multi postfix:<-->(Mu:D \a is rw) { my $b = a; a = a.pred; $b }
multi postfix:<-->(Mu:U \a is rw) { a = -1; 0 }

proto sub infix:<min>(|) is pure { * }
multi sub infix:<min>(Mu:D \a, Mu:U) { a }
multi sub infix:<min>(Mu:U, Mu:D \b) { b }
multi sub infix:<min>(Mu:D \a, Mu:D \b) { (a cmp b) < 0 ?? a !! b }
multi sub infix:<min>(*@args) { @args.min }
#proto sub min(|)     { * }
#multi sub min(*@args) { @args.min() }
#multi sub min(*@args, :&by!) { @args.min(&by) }
sub min(*@args, :&by = &infix:<cmp>) { @args.min(&by) }

proto sub infix:<max>(|) is pure { * }
multi sub infix:<max>(Mu:D \a, Mu:U) { a }
multi sub infix:<max>(Mu:U, Mu:D \b) { b }
multi sub infix:<max>(Mu:D \a, Mu:D \b) { (a cmp b) > 0 ?? a !! b }
multi sub infix:<max>(*@args) { @args.max }
#proto sub max(|) { * }
#multi sub max(*@args) { @args.max() }
#multi sub max(*@args, :&by!) { @args.max(&by) }
sub max(*@args, :&by = &infix:<cmp>) { @args.max(&by) }

proto sub infix:<minmax>(|) is pure { * }
multi sub infix:<minmax>(**@args) { @args.minmax }
#proto sub minmax(|) { * }
#multi sub minmax(*@args) { @args.minmax() }
#multi sub minmax(*@args, :&by!) { @args.minmax(&by) }
sub minmax(**@args, :&by = &infix:<cmp>) { @args.minmax(&by) }

proto sub map(|) {*}
#multi sub map(&code, @values) { @values.map(&code) }
multi sub map(&code, *@values) { @values.map(&code) }
multi sub map(Whatever, \a)    { a }
multi sub map(&code, Whatever) { (1..Inf).map(&code) }

proto sub grep(|) {*}
multi sub grep(Mu $test, @values) { @values.grep($test) }
multi sub grep(Mu $test, *@values) { @values.grep($test) }
multi sub grep(Bool:D $t, *@v) { fail X::Match::Bool.new( type => 'grep' ) }

proto sub grep-index(|) {*}
multi sub grep-index(Mu $test, @values) { @values.grep-index($test) }
multi sub grep-index(Mu $test, *@values) { @values.grep-index($test) }
multi sub grep-index(Bool:D $t, *@v) {
    fail X::Match::Bool.new(type => 'grep-index');
}

proto sub first(|) {*}
multi sub first(Mu $test, @values) { @values.first($test) }
multi sub first(Mu $test, *@values) { @values.first($test) }
multi sub first(Bool:D $t, *@v) { fail X::Match::Bool.new( type => 'first' ) }

proto sub first-index(|) {*}
multi sub first-index(Mu $test, @values) { @values.first-index($test) }
multi sub first-index(Mu $test, *@values) { @values.first-index($test) }
multi sub first-index(Bool:D $t,*@v) {
    fail X::Match::Bool.new(type => 'first-index');
}

proto sub last-index(|) {*}
multi sub last-index(Mu $test, @values) { @values.last-index($test) }
multi sub last-index(Mu $test, *@values) { @values.last-index($test) }
multi sub last-index(Bool:D $t, *@v) {
    fail X::Match::Bool.new(type => 'last-index');
}

proto sub join(|) { * }
multi sub join($sep = '', *@values) { @values.join($sep) }

proto sub pick(|) { * }
multi sub pick($n, @values) { @values.pick($n) }
multi sub pick($n, *@values) { @values.pick($n) }

proto sub roll(|) { * }
multi sub roll($n, @values) { @values.roll($n) }
multi sub roll($n, *@values) { @values.roll($n) }

proto sub keys(|) { * }
multi sub keys($x) { $x.keys }

proto sub values(|) { * }
multi sub values($x) { $x.values }

proto sub pairs(|) { * }
multi sub pairs($x) { $x.pairs }

proto sub kv(|) { * }
multi sub kv($x) { $x.kv }

proto sub elems(|) { * }
multi sub elems($a) { $a.elems }

proto sub end(|) { * }
multi sub end($a) { $a.end }

proto sub classify(|) { * }
multi sub classify( $test, *@items ) { Hash.^parameterize(Any,Any).new.classify-list( $test, @items ) }
#multi sub classify( $test, *@items, :$into! ) {   # problem in MMD
#    ( $into // $into.new).classify-list( $test, @items );
#}

proto sub categorize(|) { * }
multi sub categorize( $test, *@items ) { Hash.^parameterize(Any,Any).new.categorize-list( $test, @items ) }
#multi sub categorize( $test, *@items, :$into! ) {   # problem in MMD
#    ( $into // $into.new).categorize-list( $test, @items );
#}

proto sub uniq(|) { * }
multi sub uniq(*@values, |c) {
    DEPRECATED('unique', |<2014.12 2015.11>);
    @values.unique(|c)
}

proto sub unique(|) { * }
multi sub unique(*@values, |c) { @values.unique(|c) }

proto sub squish(|) { * }
multi sub squish(*@values, |c) { @values.squish(|c) }

proto sub sort(|) {*}
multi sub sort(*@values)      {
    nqp::istype(@values.AT-POS(0), Callable)
        ?? SEQ(my $cmp := @values.shift; @values.sort($cmp) )
        !! @values.sort;
}

proto sub item(|) is pure   { * }
multi sub item(\x)    { my $ = x }
multi sub item(*@a)   { my $ = nqp::p6parcel(nqp::p6argvmarray(), nqp::null()) }
multi sub item(Mu $a) { $a }

my $default= [];       # so that we can check missing parameters
sub RWPAIR(\k, \v) {   # internal fast pair creation
    my \p := nqp::create(Pair);
    nqp::bindattr(p, Enum, '$!key', k);
    nqp::bindattr(p, Enum, '$!value', v);
    p
}

sub OBJECT_HUH (\SELF) {
    my $huh := SELF.WHAT.perl;
    try { $huh ~= " {SELF.VAR.name}" };
    $huh;
}

sub SLICE_HUH ( \SELF, @nogo, Mu $d, %adv ) is hidden-from-backtrace {
    @nogo.unshift('delete')  # recover any :delete if necessary
      if @nogo && @nogo[0] ne 'delete' && %adv.EXISTS-KEY('delete');
    for <delete exists kv p k v> -> $valid { # check all valid params
        if nqp::existskey($d,nqp::unbox_s($valid)) {
            nqp::deletekey($d,nqp::unbox_s($valid));
            @nogo.push($valid);
        }
    }

    if nqp::elems($d) -> $elems {
        my @keys;
        my Mu $iter := nqp::iterator($d);
        @keys.push: nqp::p6box_s(nqp::iterkey_s(nqp::shift($iter))) while $iter;

        $elems > 1
          ?? fail "$elems unexpected named parameters (@keys.join(', ')) passed to {OBJECT_HUH(SELF)}"
          !! fail "Unexpected named parameter '@keys[0]' passed to {OBJECT_HUH(SELF)}";
    }

    else {
        fail "Unsupported combination of named parameters (@nogo.join(', ')) passed to {OBJECT_HUH(SELF)}";
    }
} #SLICE_HUH

sub DELETEKEY(Mu \d, str $key) {
    if nqp::existskey(d,$key) {
        my Mu $value := nqp::atkey(d,$key);
        nqp::deletekey(d,$key);
        $value;
    }
    else {
        Mu;
    }
} #DELETEKEY

proto sub dd (|) { * }
multi sub dd (\a) {
    note "{a.VAR.name} = {a.perl}";
}
multi sub dd (\a,\b) {
    note "{a.VAR.name} = {a.perl}, {b.VAR.name} = {b.perl}";
}
multi sub dd (\a,\b,\c) {
    note "{a.VAR.name} = {a.perl}, {b.VAR.name} = {b.perl}, {c.VAR.name} = {c.perl}";
}
multi sub dd (\a,\b,\c,\d) {
    note "{a.VAR.name} = {a.perl}, {b.VAR.name} = {b.perl}, {c.VAR.name} = {c.perl}, {d.VAR.name} = {d.perl}";
}
multi sub dd (\a,\b,\c,\d,\e) {
    note "{a.VAR.name} = {a.perl}, {b.VAR.name} = {b.perl}, {c.VAR.name} = {c.perl}, {d.VAR.name} = {d.perl}, {e.VAR.name} = {e.perl}";
}

# From 'src/core/SLICE.pm'

#===============================================================================
#
#
#
#===============================================================================

sub SLICE_ONE_LIST(\SELF,$one,*%adv) is hidden-from-backtrace {
    my $d := CLONE-HASH-DECONTAINERIZED(%adv);

    my @nogo;
    my \result = do {

        if DELETEKEY($d,'delete') {            # :delete:*
            if DELETEKEY($d,'SINK') {            # :delete:SINK
                SELF.DELETE-POS($one,:SINK);
            }
            elsif nqp::elems($d) == 0 {       # :delete
                SELF.DELETE-POS($one);
            }
            elsif nqp::existskey($d,'exists') { # :delete:exists(0|1):*
                my $exists   := DELETEKEY($d,'exists');
                my $wasthere := SELF.EXISTS-POS($one);
                SELF.DELETE-POS($one);
                if nqp::elems($d) == 0 {          # :delete:exists(0|1)
                    !( $wasthere ?^ $exists )
                }
                elsif nqp::existskey($d,'kv') {   # :delete:exists(0|1):kv(0|1)
                    my $kv := DELETEKEY($d,'kv');
                    if nqp::elems($d) == 0 {
                        !$kv || $wasthere
                          ?? ( $one, !( $wasthere ?^ $exists ) )
                          !! ();
                    }
                    else {
                        @nogo = <delete exists kv>;
                    }
                }
                elsif nqp::existskey($d,'p') {    # :delete:exists(0|1):p(0|1)
                    my $p := DELETEKEY($d,'p');
                    if nqp::elems($d) == 0 {
                        !$p || $wasthere
                          ?? RWPAIR($one, !($wasthere ?^ $exists) )
                          !! ();
                    }
                    else {
                        @nogo = <delete exists p>;
                    }
                }
                else {
                    @nogo = <delete exists>;
                }
            }
            elsif nqp::existskey($d,'kv') {    # :delete:kv(0|1)
                my $kv := DELETEKEY($d,'kv');
                if nqp::elems($d) == 0 {
                    !$kv || SELF.EXISTS-POS($one)
                      ?? ( $one, SELF.DELETE-POS($one) )
                      !! ();
                }
                else {
                    @nogo = <delete kv>;
                }
            }
            elsif nqp::existskey($d,'p') {     # :delete:p(0|1)
                my $p := DELETEKEY($d,'p');
                if nqp::elems($d) == 0 {
                    !$p || SELF.EXISTS-POS($one)
                      ?? RWPAIR($one, SELF.DELETE-POS($one))
                      !! ();
                }
                else {
                    @nogo = <delete p>;
                }
            }
            elsif nqp::existskey($d,'k') {     # :delete:k(0|1)
                my $k := DELETEKEY($d,'k');
                if nqp::elems($d) == 0 {
                    !$k || SELF.EXISTS-POS($one)
                      ?? do { SELF.DELETE-POS($one); $one }
                      !! ();
                }
                else {
                    @nogo = <delete k>;
                }
            }
            elsif nqp::existskey($d,'v') {     # :delete:v(0|1)
                my $v := DELETEKEY($d,'v');
                if nqp::elems($d) == 0 {
                    !$v || SELF.EXISTS-POS($one)
                      ?? SELF.DELETE-POS($one)
                      !! ();
                }
                else {
                    @nogo = <delete v>;
                }
            }
            else {
                @nogo = <delete>;
            }
        }
        elsif nqp::existskey($d,'exists') {  # :!delete?:exists(0|1):*
            my $exists  := DELETEKEY($d,'exists');
            my $wasthere = SELF.EXISTS-POS($one);
            if nqp::elems($d) == 0 {           # :!delete?:exists(0|1)
                !( $wasthere ?^ $exists )
            }
            elsif nqp::existskey($d,'kv') {    # :!delete?:exists(0|1):kv(0|1)
                my $kv := DELETEKEY($d,'kv');
                if nqp::elems($d) == 0 {
                    !$kv || $wasthere
                      ?? ( $one, !( $wasthere ?^ $exists ) )
                      !! ();
                }
                else {
                    @nogo = <exists kv>;
                }
            }
            elsif nqp::existskey($d,'p') {     # :!delete?:exists(0|1):p(0|1)
                my $p := DELETEKEY($d,'p');
                if nqp::elems($d) == 0 {
                    !$p || $wasthere
                      ?? RWPAIR($one, !( $wasthere ?^ $exists ))
                      !! ();
                }
                else {
                    @nogo = <exists p>;
                }
            }
            else {
                @nogo = <exists>;
            }
        }
        elsif nqp::existskey($d,'kv') {      # :!delete?:kv(0|1):*
            my $kv := DELETEKEY($d,'kv');
            if nqp::elems($d) == 0 {           # :!delete?:kv(0|1)
                !$kv || SELF.EXISTS-POS($one)
                  ?? ($one, SELF.AT-POS($one))
                  !! ();
            }
            else {
                @nogo = <kv>;
            }
        }
        elsif nqp::existskey($d,'p') {       # :!delete?:p(0|1):*
            my $p := DELETEKEY($d,'p');
            if nqp::elems($d) == 0 {           # :!delete?:p(0|1)
                !$p || SELF.EXISTS-POS($one)
                  ?? RWPAIR($one, SELF.AT-POS($one))
                  !! ();
            }
            else {
                @nogo = <p>;
            }
        }
        elsif nqp::existskey($d,'k') {       # :!delete?:k(0|1):*
            my $k := DELETEKEY($d,'k');
            if nqp::elems($d) == 0 {           # :!delete?:k(0|1)
                !$k || SELF.EXISTS-POS($one)
                  ?? $one
                  !! ();
            }
            else {
                @nogo = <k>;
            }
        }
        elsif nqp::existskey($d,'v') {       # :!delete?:v(0|1):*
            my $v := DELETEKEY($d,'v');           # :!delete?:v(0|1)
            if nqp::elems($d) == 0 {
                !$v || SELF.EXISTS-POS($one)
                  ?? SELF.AT-POS($one)
                  !! ();
            }
            else {
                @nogo = <v>;
            }
        }
        elsif nqp::elems($d) == 0 {           # :!delete
            SELF.AT-POS($one);
        }
    }

    @nogo || nqp::elems($d)
      ?? SLICE_HUH( SELF, @nogo, $d, %adv )
      !! result;
} #SLICE_ONE_LIST

sub SLICE_MORE_LIST(\SELF,$more,*%adv) is hidden-from-backtrace {
    my $d := CLONE-HASH-DECONTAINERIZED(%adv);
    my @nogo;

    my \result = do {

        if DELETEKEY($d,'delete') {            # :delete:*
            if DELETEKEY($d,'SINK') {            # :delete:SINK
                SELF.DELETE-POS($_,:SINK) for $more;
                Nil;
            }
            elsif nqp::elems($d) == 0 {       # :delete
                $more.list.map( { SELF.DELETE-POS($_) } ).eager.Parcel;
            }
            elsif nqp::existskey($d,'exists') { # :delete:exists(0|1):*
                my $exists := DELETEKEY($d,'exists');
                my $wasthere; # no need to initialize every iteration of map
                if nqp::elems($d) == 0 {          # :delete:exists(0|1)
                    $more.list.map( {
                        SELF.DELETE-POS($_) if $wasthere = SELF.EXISTS-POS($_);
                        !( $wasthere ?^ $exists );
                    } ).eager.Parcel;
                }
                elsif nqp::existskey($d,'kv') { # :delete:exists(0|1):kv(0|1):*
                    my $kv := DELETEKEY($d,'kv');
                    if nqp::elems($d) == 0 {      # :delete:exists(0|1):kv(0|1)
                        $more.list.map( {
                            SELF.DELETE-POS($_) if $wasthere = SELF.EXISTS-POS($_);
                            next unless !$kv || $wasthere;
                            ($_, !( $wasthere ?^ $exists ));
                        } ).flat.eager.Parcel;
                    }
                    else {
                        @nogo = <delete exists kv>;
                    }
                }
                elsif nqp::existskey($d,'p') {  # :delete:exists(0|1):p(0|1):*
                    my $p := DELETEKEY($d,'p');
                    if nqp::elems($d) == 0 {      # :delete:exists(0|1):p(0|1)
                        $more.list.map( {
                            SELF.DELETE-POS($_) if $wasthere = SELF.EXISTS-POS($_);
                            next unless !$p || $wasthere;
                            RWPAIR($_,!($wasthere ?^ $exists));
                        } ).eager.Parcel;
                    }
                    else {
                        @nogo = <delete exists p>;
                    }
                }
                else {
                    @nogo = <delete exists>;
                }
            }
            elsif nqp::existskey($d,'kv') {     # :delete:kv(0|1):*
                my $kv := DELETEKEY($d,'kv');
                if nqp::elems($d) == 0 {          # :delete:kv(0|1)
                    $kv
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-POS($_);
                             ( $_, SELF.DELETE-POS($_) );
                         } ).flat.eager.Parcel
                      !! $more.list.map( {
                             ( $_, SELF.DELETE-POS($_) )
                         } ).flat.eager.Parcel;
                }
                else {
                    @nogo = <delete kv>;
                }
            }
            elsif nqp::existskey($d,'p') {      # :delete:p(0|1):*
                my $p := DELETEKEY($d,'p');
                if nqp::elems($d) == 0 {          # :delete:p(0|1)
                    $p
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-POS($_);
                             RWPAIR($_, SELF.DELETE-POS($_));
                         } ).eager.Parcel
                      !! $more.list.map( {
                             RWPAIR($_, SELF.DELETE-POS($_))
                         } ).eager.Parcel;
                }
                else {
                    @nogo = <delete p>;
                }
            }
            elsif nqp::existskey($d,'k') {     # :delete:k(0|1):*
                my $k := DELETEKEY($d,'k');
                if nqp::elems($d) == 0 {          # :delete:k(0|1)
                    $k
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-POS($_);
                             SEQ( SELF.DELETE-POS($_); $_ );
                         } ).eager.Parcel
                      !! $more.list.map( {
                             SELF.DELETE-POS($_); $_
                         } ).eager.Parcel;
                }
                else {
                    @nogo = <delete k>;
                }
            }
            elsif nqp::existskey($d,'v') {      # :delete:v(0|1):*
                my $v := DELETEKEY($d,'v');
                if nqp::elems($d) == 0 {          # :delete:v(0|1)
                    $v
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-POS($_);
                             SELF.DELETE-POS($_);
                     } ).eager.Parcel
                      !! $more.list.map( {
                             SELF.DELETE-POS($_)
                     } ).eager.Parcel;
                }
                else {
                    @nogo = <delete v>;
                }
            }
            else {
                @nogo = <delete>;
            }
        }
        elsif nqp::existskey($d,'exists') { # :!delete?:exists(0|1):*
            my $exists := DELETEKEY($d,'exists');
            if nqp::elems($d) == 0 {          # :!delete?:exists(0|1)
                $more.list.map({ !( SELF.EXISTS-POS($_) ?^ $exists ) }).eager.Parcel;
            }
            elsif nqp::existskey($d,'kv') {   # :!delete?:exists(0|1):kv(0|1):*
                my $kv := DELETEKEY($d,'kv');
                if nqp::elems($d) == 0 {        # :!delete?:exists(0|1):kv(0|1)
                    $kv
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-POS($_);
                             ( $_, $exists );
                         } ).flat.eager.Parcel
                      !! $more.list.map( {
                             ( $_, !( SELF.EXISTS-POS($_) ?^ $exists ) )
                         } ).flat.eager.Parcel;
                }
                else {
                    @nogo = <exists kv>;
                }
            }
            elsif nqp::existskey($d,'p') {  # :!delete?:exists(0|1):p(0|1):*
                my $p := DELETEKEY($d,'p');
                if nqp::elems($d) == 0 {      # :!delete?:exists(0|1):p(0|1)
                    $p
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-POS($_);
                             RWPAIR( $_, $exists );
                         } ).eager.Parcel
                      !! $more.list.map( {
                             RWPAIR( $_, !( SELF.EXISTS-POS($_) ?^ $exists ) )
                         } ).eager.Parcel;
                }
                else {
                    @nogo = <exists p>;
                }
            }
            else {
                @nogo = <exists>;
            }
        }
        elsif nqp::existskey($d,'kv') {     # :!delete?:kv(0|1):*
            my $kv := DELETEKEY($d,'kv');
            if nqp::elems($d) == 0 {          # :!delete?:kv(0|1)
                $kv
                  ?? $more.list.map( {
                         next unless SELF.EXISTS-POS($_);
                         $_, SELF.AT-POS($_);
                     } ).flat.eager.Parcel
                  !! $more.list.map( {
                         $_, SELF.AT-POS($_)
                     } ).flat.eager.Parcel;
            }
            else {
                @nogo = <kv>;
            }
        }
        elsif nqp::existskey($d,'p') {      # :!delete?:p(0|1):*
            my $p := DELETEKEY($d,'p');
            if nqp::elems($d) == 0 {          # :!delete?:p(0|1)
                $p
                  ?? $more.list.map( {
                         next unless SELF.EXISTS-POS($_);
                         RWPAIR($_, SELF.AT-POS($_));
                     } ).eager.Parcel
                  !! $more.list.map( {
                         RWPAIR( $_, SELF.AT-POS($_) )
                     } ).eager.Parcel;
            }
            else {
                @nogo = <p>
            }
        }
        elsif nqp::existskey($d,'k') {      # :!delete?:k(0|1):*
            my $k := DELETEKEY($d,'k');
            if nqp::elems($d) == 0 {          # :!delete?:k(0|1)
                $k
                  ?? $more.list.map( {
                         next unless SELF.EXISTS-POS($_);
                         $_;
                     } ).eager.Parcel
                  !! $more.list.flat.eager.Parcel;
            }
            else {
                @nogo = <k>;
            }
        }
        elsif nqp::existskey($d,'v') {      # :!delete?:v(0|1):*
            my $v := DELETEKEY($d,'v');
            if nqp::elems($d) == 0 {          # :!delete?:v(0|1)
                $v
                  ??  $more.list.map( {
                          next unless SELF.EXISTS-POS($_);
                          SELF.AT-POS($_);
                      } ).eager.Parcel
                  !!  $more.list.map( {
                          SELF.AT-POS($_)
                      } ).eager.Parcel;
            }
            else {
                @nogo = <v>;
            }
        }
        elsif nqp::elems($d) == 0 {         # :!delete
            $more.list.map( { SELF.AT-POS($_) } ).eager.Parcel;
        }
    }

    @nogo || nqp::elems($d)
      ?? SLICE_HUH( SELF, @nogo, $d, %adv )
      !! result;
} #SLICE_MORE_LIST


sub SLICE_ONE_HASH(\SELF,$one,*%adv) is hidden-from-backtrace {
    my $d := CLONE-HASH-DECONTAINERIZED(%adv);

    my @nogo;
    my \result = do {

        if DELETEKEY($d,'delete') {            # :delete:*
            if DELETEKEY($d,'SINK') {            # :delete:SINK
                SELF.DELETE-KEY($one,:SINK);
            }
            elsif nqp::elems($d) == 0 {       # :delete
                SELF.DELETE-KEY($one);
            }
            elsif nqp::existskey($d,'exists') { # :delete:exists(0|1):*
                my $exists   := DELETEKEY($d,'exists');
                my $wasthere := SELF.EXISTS-KEY($one);
                SELF.DELETE-KEY($one);
                if nqp::elems($d) == 0 {          # :delete:exists(0|1)
                    !( $wasthere ?^ $exists )
                }
                elsif nqp::existskey($d,'kv') {   # :delete:exists(0|1):kv(0|1)
                    my $kv := DELETEKEY($d,'kv');
                    if nqp::elems($d) == 0 {
                        !$kv || $wasthere
                          ?? ( $one, !( $wasthere ?^ $exists ) )
                          !! ();
                    }
                    else {
                        @nogo = <delete exists kv>;
                    }
                }
                elsif nqp::existskey($d,'p') {    # :delete:exists(0|1):p(0|1)
                    my $p := DELETEKEY($d,'p');
                    if nqp::elems($d) == 0 {
                        !$p || $wasthere
                          ?? RWPAIR($one, !($wasthere ?^ $exists) )
                          !! ();
                    }
                    else {
                        @nogo = <delete exists p>;
                    }
                }
                else {
                    @nogo = <delete exists>;
                }
            }
            elsif nqp::existskey($d,'kv') {    # :delete:kv(0|1)
                my $kv := DELETEKEY($d,'kv');
                if nqp::elems($d) == 0 {
                    !$kv || SELF.EXISTS-KEY($one)
                      ?? ( $one, SELF.DELETE-KEY($one) )
                      !! ();
                }
                else {
                    @nogo = <delete kv>;
                }
            }
            elsif nqp::existskey($d,'p') {     # :delete:p(0|1)
                my $p := DELETEKEY($d,'p');
                if nqp::elems($d) == 0 {
                    !$p || SELF.EXISTS-KEY($one)
                      ?? RWPAIR($one, SELF.DELETE-KEY($one))
                      !! ();
                }
                else {
                    @nogo = <delete p>;
                }
            }
            elsif nqp::existskey($d,'k') {     # :delete:k(0|1)
                my $k := DELETEKEY($d,'k');
                if nqp::elems($d) == 0 {
                    !$k || SELF.EXISTS-KEY($one)
                      ?? do { SELF.DELETE-KEY($one); $one }
                      !! ();
                }
                else {
                    @nogo = <delete k>;
                }
            }
            elsif nqp::existskey($d,'v') {     # :delete:v(0|1)
                my $v := DELETEKEY($d,'v');
                if nqp::elems($d) == 0 {
                    !$v || SELF.EXISTS-KEY($one)
                      ?? SELF.DELETE-KEY($one)
                      !! ();
                }
                else {
                    @nogo = <delete v>;
                }
            }
            else {
                @nogo = <delete>;
            }
        }
        elsif nqp::existskey($d,'exists') {  # :!delete?:exists(0|1):*
            my $exists  := DELETEKEY($d,'exists');
            my $wasthere = SELF.EXISTS-KEY($one);
            if nqp::elems($d) == 0 {           # :!delete?:exists(0|1)
                !( $wasthere ?^ $exists )
            }
            elsif nqp::existskey($d,'kv') {    # :!delete?:exists(0|1):kv(0|1)
                my $kv := DELETEKEY($d,'kv');
                if nqp::elems($d) == 0 {
                    !$kv || $wasthere
                      ?? ( $one, !( $wasthere ?^ $exists ) )
                      !! ();
                }
                else {
                    @nogo = <exists kv>;
                }
            }
            elsif nqp::existskey($d,'p') {     # :!delete?:exists(0|1):p(0|1)
                my $p := DELETEKEY($d,'p');
                if nqp::elems($d) == 0 {
                    !$p || $wasthere
                      ?? RWPAIR($one, !( $wasthere ?^ $exists ))
                      !! ();
                }
                else {
                    @nogo = <exists p>;
                }
            }
            else {
                @nogo = <exists>;
            }
        }
        elsif nqp::existskey($d,'kv') {      # :!delete?:kv(0|1):*
            my $kv := DELETEKEY($d,'kv');
            if nqp::elems($d) == 0 {           # :!delete?:kv(0|1)
                !$kv || SELF.EXISTS-KEY($one)
                  ?? ($one, SELF.AT-KEY($one))
                  !! ();
            }
            else {
                @nogo = <kv>;
            }
        }
        elsif nqp::existskey($d,'p') {       # :!delete?:p(0|1):*
            my $p := DELETEKEY($d,'p');
            if nqp::elems($d) == 0 {           # :!delete?:p(0|1)
                !$p || SELF.EXISTS-KEY($one)
                  ?? RWPAIR($one, SELF.AT-KEY($one))
                  !! ();
            }
            else {
                @nogo = <p>;
            }
        }
        elsif nqp::existskey($d,'k') {       # :!delete?:k(0|1):*
            my $k := DELETEKEY($d,'k');
            if nqp::elems($d) == 0 {           # :!delete?:k(0|1)
                !$k || SELF.EXISTS-KEY($one)
                  ?? $one
                  !! ();
            }
            else {
                @nogo = <k>;
            }
        }
        elsif nqp::existskey($d,'v') {       # :!delete?:v(0|1):*
            my $v := DELETEKEY($d,'v');           # :!delete?:v(0|1)
            if nqp::elems($d) == 0 {
                !$v || SELF.EXISTS-KEY($one)
                  ?? SELF.AT-KEY($one)
                  !! ();
            }
            else {
                @nogo = <v>;
            }
        }
        elsif nqp::elems($d) == 0 {           # :!delete
            SELF.AT-KEY($one);
        }
    }

    @nogo || nqp::elems($d)
      ?? SLICE_HUH( SELF, @nogo, $d, %adv )
      !! result;
} #SLICE_ONE_HASH

sub SLICE_MORE_HASH(\SELF,$more,*%adv) is hidden-from-backtrace {
    my $d := CLONE-HASH-DECONTAINERIZED(%adv);
    my @nogo;

    my \result = do {

        if DELETEKEY($d,'delete') {            # :delete:*
            if DELETEKEY($d,'SINK') {            # :delete:SINK
                SELF.DELETE-KEY($_,:SINK) for $more;
                Nil;
            }
            elsif nqp::elems($d) == 0 {       # :delete
                $more.list.map( { SELF.DELETE-KEY($_) } ).eager.Parcel;
            }
            elsif nqp::existskey($d,'exists') { # :delete:exists(0|1):*
                my $exists := DELETEKEY($d,'exists');
                my $wasthere; # no need to initialize every iteration of map
                if nqp::elems($d) == 0 {          # :delete:exists(0|1)
                    $more.list.map( {
                        SELF.DELETE-KEY($_) if $wasthere = SELF.EXISTS-KEY($_);
                        !( $wasthere ?^ $exists );
                    } ).eager.Parcel;
                }
                elsif nqp::existskey($d,'kv') { # :delete:exists(0|1):kv(0|1):*
                    my $kv := DELETEKEY($d,'kv');
                    if nqp::elems($d) == 0 {      # :delete:exists(0|1):kv(0|1)
                        $more.list.map( {
                            SELF.DELETE-KEY($_) if $wasthere = SELF.EXISTS-KEY($_);
                            next unless !$kv || $wasthere;
                            ($_, !( $wasthere ?^ $exists ));
                        } ).flat.eager.Parcel;
                    }
                    else {
                        @nogo = <delete exists kv>;
                    }
                }
                elsif nqp::existskey($d,'p') {  # :delete:exists(0|1):p(0|1):*
                    my $p := DELETEKEY($d,'p');
                    if nqp::elems($d) == 0 {      # :delete:exists(0|1):p(0|1)
                        $more.list.map( {
                            SELF.DELETE-KEY($_) if $wasthere = SELF.EXISTS-KEY($_);
                            next unless !$p || $wasthere;
                            RWPAIR($_,!($wasthere ?^ $exists));
                        } ).eager.Parcel;
                    }
                    else {
                        @nogo = <delete exists p>;
                    }
                }
                else {
                    @nogo = <delete exists>;
                }
            }
            elsif nqp::existskey($d,'kv') {     # :delete:kv(0|1):*
                my $kv := DELETEKEY($d,'kv');
                if nqp::elems($d) == 0 {          # :delete:kv(0|1)
                    $kv
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-KEY($_);
                             ( $_, SELF.DELETE-KEY($_) );
                         } ).flat.eager.Parcel
                      !! $more.list.map( {
                             ( $_, SELF.DELETE-KEY($_) )
                         } ).flat.eager.Parcel;
                }
                else {
                    @nogo = <delete kv>;
                }
            }
            elsif nqp::existskey($d,'p') {      # :delete:p(0|1):*
                my $p := DELETEKEY($d,'p');
                if nqp::elems($d) == 0 {          # :delete:p(0|1)
                    $p
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-KEY($_);
                             RWPAIR($_, SELF.DELETE-KEY($_));
                         } ).eager.Parcel
                      !! $more.list.map( {
                             RWPAIR($_, SELF.DELETE-KEY($_))
                         } ).eager.Parcel;
                }
                else {
                    @nogo = <delete p>;
                }
            }
            elsif nqp::existskey($d,'k') {     # :delete:k(0|1):*
                my $k := DELETEKEY($d,'k');
                if nqp::elems($d) == 0 {          # :delete:k(0|1)
                    $k
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-KEY($_);
                             SEQ( SELF.DELETE-KEY($_); $_ );
                         } ).eager.Parcel
                      !! $more.list.map( {
                             SELF.DELETE-KEY($_); $_
                         } ).eager.Parcel;
                }
                else {
                    @nogo = <delete k>;
                }
            }
            elsif nqp::existskey($d,'v') {      # :delete:v(0|1):*
                my $v := DELETEKEY($d,'v');
                if nqp::elems($d) == 0 {          # :delete:v(0|1)
                    $v
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-KEY($_);
                             SELF.DELETE-KEY($_);
                     } ).eager.Parcel
                      !! $more.list.map( {
                             SELF.DELETE-KEY($_)
                     } ).eager.Parcel;
                }
                else {
                    @nogo = <delete v>;
                }
            }
            else {
                @nogo = <delete>;
            }
        }
        elsif nqp::existskey($d,'exists') { # :!delete?:exists(0|1):*
            my $exists := DELETEKEY($d,'exists');
            if nqp::elems($d) == 0 {          # :!delete?:exists(0|1)
                $more.list.map({ !( SELF.EXISTS-KEY($_) ?^ $exists ) }).eager.Parcel;
            }
            elsif nqp::existskey($d,'kv') {   # :!delete?:exists(0|1):kv(0|1):*
                my $kv := DELETEKEY($d,'kv');
                if nqp::elems($d) == 0 {        # :!delete?:exists(0|1):kv(0|1)
                    $kv
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-KEY($_);
                             ( $_, $exists );
                         } ).flat.eager.Parcel
                      !! $more.list.map( {
                             ( $_, !( SELF.EXISTS-KEY($_) ?^ $exists ) )
                         } ).flat.eager.Parcel;
                }
                else {
                    @nogo = <exists kv>;
                }
            }
            elsif nqp::existskey($d,'p') {  # :!delete?:exists(0|1):p(0|1):*
                my $p := DELETEKEY($d,'p');
                if nqp::elems($d) == 0 {      # :!delete?:exists(0|1):p(0|1)
                    $p
                      ?? $more.list.map( {
                             next unless SELF.EXISTS-KEY($_);
                             RWPAIR( $_, $exists );
                         } ).eager.Parcel
                      !! $more.list.map( {
                             RWPAIR( $_, !( SELF.EXISTS-KEY($_) ?^ $exists ) )
                         } ).eager.Parcel;
                }
                else {
                    @nogo = <exists p>;
                }
            }
            else {
                @nogo = <exists>;
            }
        }
        elsif nqp::existskey($d,'kv') {     # :!delete?:kv(0|1):*
            my $kv := DELETEKEY($d,'kv');
            if nqp::elems($d) == 0 {          # :!delete?:kv(0|1)
                $kv
                  ?? $more.list.map( {
                         next unless SELF.EXISTS-KEY($_);
                         $_, SELF.AT-KEY($_);
                     } ).flat.eager.Parcel
                  !! $more.list.map( {
                         $_, SELF.AT-KEY($_)
                     } ).flat.eager.Parcel;
            }
            else {
                @nogo = <kv>;
            }
        }
        elsif nqp::existskey($d,'p') {      # :!delete?:p(0|1):*
            my $p := DELETEKEY($d,'p');
            if nqp::elems($d) == 0 {          # :!delete?:p(0|1)
                $p
                  ?? $more.list.map( {
                         next unless SELF.EXISTS-KEY($_);
                         RWPAIR($_, SELF.AT-KEY($_));
                     } ).eager.Parcel
                  !! $more.list.map( {
                         RWPAIR( $_, SELF.AT-KEY($_) )
                     } ).eager.Parcel;
            }
            else {
                @nogo = <p>
            }
        }
        elsif nqp::existskey($d,'k') {      # :!delete?:k(0|1):*
            my $k := DELETEKEY($d,'k');
            if nqp::elems($d) == 0 {          # :!delete?:k(0|1)
                $k
                  ?? $more.list.map( {
                         next unless SELF.EXISTS-KEY($_);
                         $_;
                     } ).eager.Parcel
                  !! $more.list.flat.eager.Parcel;
            }
            else {
                @nogo = <k>;
            }
        }
        elsif nqp::existskey($d,'v') {      # :!delete?:v(0|1):*
            my $v := DELETEKEY($d,'v');
            if nqp::elems($d) == 0 {          # :!delete?:v(0|1)
                $v
                  ??  $more.list.map( {
                          next unless SELF.EXISTS-KEY($_);
                          SELF.AT-KEY($_);
                      } ).eager.Parcel
                  !!  $more.list.map( {
                          SELF.AT-KEY($_)
                      } ).eager.Parcel;
            }
            else {
                @nogo = <v>;
            }
        }
        elsif nqp::elems($d) == 0 {         # :!delete
            $more.list.map( { SELF.AT-KEY($_) } ).eager.Parcel;
        }
    }

    @nogo || nqp::elems($d)
      ?? SLICE_HUH( SELF, @nogo, $d, %adv )
      !! result;
} #SLICE_MORE_HASH


# From 'src/core/Whatever.pm'

my class Whatever {
    multi method ACCEPTS(Whatever:D: $topic) { True }
    multi method perl(Whatever:D:) { '*' }
}

my class HyperWhatever {
    multi method ACCEPTS(HyperWhatever:D: $topic) { True }
    multi method perl(HyperWhatever:D:) { '**' }
}

sub HYPERWHATEVER (&c) { sub (*@_) { map &c, @_ } }

# From 'src/core/array_slice.pm'


sub POSITIONS(\SELF, \pos) { # handle possible infinite slices
    my $positions := pos.flat;

    if nqp::istype(pos,Range)                         # a Range
      || $positions.infinite                          # an infinite list
      || ($positions.gimme(*) && $positions.infinite) # an infinite list now
    {
        my $list = SELF.list;
        $positions.map( {
            last if $_ >= $list.gimme( $_ + 1 );
            $_;
        } ).eager.Parcel;
    }
    else {
        $positions.map( {
            nqp::istype($_,Callable) ?? $_(|(SELF.elems xx $_.count)) !! $_
        } ).eager.Parcel;
    }
}

my class X::NYI { ... }

proto sub postcircumfix:<[ ]>(|) { * }

multi sub postcircumfix:<[ ]>( \SELF, Any:U $type, |c ) is rw {
    die "Indexing requires an instance, tried to do: {SELF.VAR.name}[ {$type.gist} ]";
}

# @a[int 1]
multi sub postcircumfix:<[ ]>( \SELF, int $pos ) is rw {
    SELF.AT-POS($pos);
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, Mu \assignee ) is rw {
    SELF.ASSIGN-POS($pos, assignee);
}
multi sub postcircumfix:<[ ]>(\SELF, int $pos, Mu :$BIND! is parcel) is rw {
    SELF.BIND-POS($pos, $BIND);
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$SINK!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$SINK, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$delete!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$delete, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$exists!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$exists, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$kv!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$kv, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$p!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$p, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$k!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$k, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$v!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$v, |%other );
}

# @a[Int 1]
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos ) is rw {
    SELF.AT-POS($pos);
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, Mu \assignee ) is rw {
    SELF.ASSIGN-POS($pos, assignee);
}
multi sub postcircumfix:<[ ]>(\SELF, Int:D $pos, Mu :$BIND! is parcel) is rw {
    SELF.BIND-POS($pos, $BIND);
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$SINK!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$SINK, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$delete!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$delete, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$exists!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$exists, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$kv!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$kv, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$p!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$p, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$k!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$k, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$v!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, $pos, :$v, |%other );
}

# @a[$x]
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos ) is rw {
    SELF.AT-POS(pos.Int);
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, Mu \assignee ) is rw {
    SELF.ASSIGN-POS(pos.Int, assignee);
}
multi sub postcircumfix:<[ ]>(\SELF, Any:D \pos, Mu :$BIND! is parcel) is rw {
    SELF.BIND-POS(pos.Int, $BIND);
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$SINK!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, pos.Int, :$SINK, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$delete!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, pos.Int, :$delete, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$exists!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, pos.Int, :$exists, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$kv!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, pos.Int, :$kv, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$p!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, pos.Int, :$p, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$k!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, pos.Int, :$k, |%other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$v!, *%other ) is rw {
    SLICE_ONE_LIST( SELF, pos.Int, :$v, |%other );
}

# @a[@i]
multi sub postcircumfix:<[ ]>( \SELF, Positional:D \pos ) is rw {
    nqp::iscont(pos)
      ?? SELF.AT-POS(pos.Int)
      !! POSITIONS(SELF,pos).map({ SELF[$_] }).eager.Parcel;
}
multi sub postcircumfix:<[ ]>( \SELF, Positional:D \pos, Mu \assignee ) is rw {
    nqp::iscont(pos)
      ?? SELF.ASSIGN-POS(pos.Int,assignee)
      !! POSITIONS(SELF,pos).map({ SELF[$_] }).eager.Parcel = assignee;
}
multi sub postcircumfix:<[ ]>(\SELF, Positional:D \pos, :$BIND!) is rw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<[ ]>(\SELF, Positional:D \pos, :$SINK!, *%other) is rw {
   SLICE_MORE_LIST( SELF, POSITIONS(SELF,pos), :$SINK, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF,Positional:D \pos,:$delete!,*%other) is rw {
   SLICE_MORE_LIST( SELF, POSITIONS(SELF,pos), :$delete, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF,Positional:D \pos,:$exists!,*%other) is rw {
   SLICE_MORE_LIST( SELF, POSITIONS(SELF,pos), :$exists, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Positional:D \pos, :$kv!, *%other) is rw {
   SLICE_MORE_LIST( SELF, POSITIONS(SELF,pos), :$kv, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Positional:D \pos, :$p!, *%other) is rw {
   SLICE_MORE_LIST( SELF, POSITIONS(SELF,pos), :$p, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Positional:D \pos, :$k!, *%other) is rw {
   SLICE_MORE_LIST( SELF, POSITIONS(SELF,pos), :$k, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Positional:D \pos, :$v!, *%other) is rw {
   SLICE_MORE_LIST( SELF, POSITIONS(SELF,pos), :$v, |%other );
}

# @a[->{}]
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block ) is rw {
    SELF[$block(|(SELF.elems xx $block.count))];
}
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block, Mu \assignee ) is rw {
    SELF[$block(|(SELF.elems xx $block.count))] = assignee;
}
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block, :$BIND!) is rw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block, :$SINK!, *%other) is rw {
    SLICE_MORE_LIST( SELF, POSITIONS(SELF,$block), :$SINK, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF,Callable:D $block,:$delete!,*%other) is rw {
    my $pos := $block(|(SELF.elems xx $block.count));
    nqp::istype($pos,Int)
      ?? SLICE_ONE_LIST(  SELF,  $pos, :$delete, |%other )
      !! SLICE_MORE_LIST( SELF, @$pos, :$delete, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF,Callable:D $block,:$exists!,*%other) is rw {
    my $pos := $block(|(SELF.elems xx $block.count));
    nqp::istype($pos,Int)
      ?? SLICE_ONE_LIST(  SELF,  $pos, :$exists, |%other )
      !! SLICE_MORE_LIST( SELF, @$pos, :$exists, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block, :$kv!, *%other) is rw {
    my $pos := $block(|(SELF.elems xx $block.count));
    nqp::istype($pos,Int)
      ?? SLICE_ONE_LIST(  SELF,  $pos, :$kv, |%other )
      !! SLICE_MORE_LIST( SELF, @$pos, :$kv, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block, :$p!, *%other) is rw {
    my $pos := $block(|(SELF.elems xx $block.count));
    nqp::istype($pos,Int)
      ?? SLICE_ONE_LIST(  SELF,  $pos, :$p, |%other )
      !! SLICE_MORE_LIST( SELF, @$pos, :$p, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block, :$k!, *%other) is rw {
    my $pos := $block(|(SELF.elems xx $block.count));
    nqp::istype($pos,Int)
      ?? SLICE_ONE_LIST(  SELF,  $pos, :$k, |%other )
      !! SLICE_MORE_LIST( SELF, @$pos, :$k, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block, :$v!, *%other) is rw {
    my $pos := $block(|(SELF.elems xx $block.count));
    nqp::istype($pos,Int)
      ?? SLICE_ONE_LIST(  SELF,  $pos, :$v, |%other )
      !! SLICE_MORE_LIST( SELF, @$pos, :$v, |%other );
}

# @a[*]
multi sub postcircumfix:<[ ]>( \SELF, Whatever:D ) is rw {
    SELF[^SELF.elems];
}
multi sub postcircumfix:<[ ]>( \SELF, Whatever:D, Mu \assignee ) is rw {
    SELF[^SELF.elems] = assignee;
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$BIND!) is rw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$SINK!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$SINK, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$delete!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$delete, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$exists!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$exists, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$kv!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$kv, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$p!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$p, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$k!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$k, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$v!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$v, |%other );
}

# @a[**]
multi sub postcircumfix:<[ ]>(\SELF, HyperWhatever:D $, *%adv) is rw {
    X::NYI.new(feature => 'HyperWhatever in array index').throw;
}
multi sub postcircumfix:<[ ]>(\SELF, HyperWhatever:D $, Mu \assignee) is rw {
    X::NYI.new(feature => 'HyperWhatever in array index').throw;
}

# @a[]
multi sub postcircumfix:<[ ]>( \SELF ) is rw {
    nqp::decont(SELF);
}
multi sub postcircumfix:<[ ]>(\SELF, :$BIND!) is rw {
    X::Bind::ZenSlice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<[ ]>(\SELF, :$SINK!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$SINK, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$delete!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$delete, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$exists!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$exists, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$kv!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$kv, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$p!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$p, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$k!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$k, |%other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$v!, *%other) is rw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, :$v, |%other );
}

# @a[;]
multi sub postcircumfix:<[ ]> (\SELF is rw, LoL:D \keys, *%adv) is rw {
    if keys > 1 {
        X::NYI.new(feature => "Accessing dimensions after HyperWhatever").throw
            if keys[0].isa(HyperWhatever);

        if [||] %adv<kv p k> {
            (SELF[keys[0]]:kv).map(-> \key, \value {
                # make sure to call .item so that recursive calls don't map the LoL's elems
                map %adv<kv> ?? -> \key2, \value2 { LoL.new(key, |key2).item, value2 } !!
                    %adv<p>  ?? {; LoL.new(key, |.key) => .value } !!
                    { LoL.new(key, |$_).item },
                    postcircumfix:<[ ]>(value, LoL.new(|keys[1..*]), |%adv);
            }).eager.Parcel;
        } else {
            (keys[0].isa(Whatever)
                ?? SELF[^SELF.elems].Parcel
                !! SELF[keys[0].list].Parcel
            ).map(-> \elem {
                postcircumfix:<[ ]>(elem, LoL.new(|keys[1..*]), |%adv);
            }).eager.Parcel;
        }
    } else {
        postcircumfix:<[ ]>(SELF, keys[0].elems > 1 ?? keys[0].list !! keys[0] , |%adv);
    }
}
multi sub postcircumfix:<[ ]> (\SELF is rw, LoL:D \keys, Mu \assignee) is rw {
    (SELF[keys],) = assignee;
}

# From 'src/core/hash_slice.pm'


proto sub postcircumfix:<{ }>(|) { * }

# %h<key>
multi sub postcircumfix:<{ }>( \SELF, \key ) is rw {
    SELF.AT-KEY(key);
}
multi sub postcircumfix:<{ }>(\SELF, \key, Mu \ASSIGN) is rw {
    SELF.ASSIGN-KEY(key, ASSIGN);
}
multi sub postcircumfix:<{ }>(\SELF, \key, Mu :$BIND! is parcel) is rw {
    SELF.BIND-KEY(key, $BIND);
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$SINK!, *%other ) is rw {
    SLICE_ONE_HASH( SELF, key, :$SINK, |%other );
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$delete!, *%other ) is rw {
    SLICE_ONE_HASH( SELF, key, :$delete, |%other );
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$exists!, *%other ) is rw {
    SLICE_ONE_HASH( SELF, key, :$exists, |%other );
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$kv!, *%other ) is rw {
    SLICE_ONE_HASH( SELF, key, :$kv, |%other );
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$p!, *%other ) is rw {
    SLICE_ONE_HASH( SELF, key, :$p, |%other );
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$k!, *%other ) is rw {
    SLICE_ONE_HASH( SELF, key, :$k, |%other );
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$v!, *%other ) is rw {
    SLICE_ONE_HASH( SELF, key, :$v, |%other );
}

# %h<a b c>
multi sub postcircumfix:<{ }>( \SELF, Positional \key ) is rw {
    nqp::iscont(key)
      ?? SELF.AT-KEY(key)
      !! key.map({ SELF{$_} }).eager.Parcel;
}
multi sub postcircumfix:<{ }>(\SELF, Positional \key, Mu \ASSIGN) is rw {
    (nqp::iscont(key)
      ?? SELF.AT-KEY(key)
      !! key.map({ SELF{$_} }).eager.Parcel) = ASSIGN
}
multi sub postcircumfix:<{ }>(\SELF, Positional \key, :$BIND!) is rw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<{ }>(\SELF,Positional \key, :$SINK!,*%other) is rw {
    SLICE_MORE_HASH( SELF, \key, :$SINK, |%other );
}
multi sub postcircumfix:<{ }>(\SELF,Positional \key, :$delete!,*%other) is rw {
    SLICE_MORE_HASH( SELF, \key, :$delete, |%other );
}
multi sub postcircumfix:<{ }>(\SELF,Positional \key, :$exists!,*%other) is rw {
    SLICE_MORE_HASH( SELF, \key, :$exists, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Positional \key, :$kv!, *%other) is rw {
    SLICE_MORE_HASH( SELF, \key, :$kv, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Positional \key, :$p!, *%other) is rw {
    SLICE_MORE_HASH( SELF, \key, :$p, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Positional \key, :$k!, *%other) is rw {
    SLICE_MORE_HASH( SELF, \key, :$k, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Positional \key, :$v!, *%other) is rw {
    SLICE_MORE_HASH( SELF, \key, :$v, |%other );
}

# %h{*}
multi sub postcircumfix:<{ }>( \SELF, Whatever ) is rw {
    SELF{SELF.keys};
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, Mu \ASSIGN) is rw {
    SELF{SELF.keys} = ASSIGN;
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$BIND!) is rw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$SINK!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$SINK, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$delete!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$delete, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$exists!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$exists, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$kv!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$kv, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$p!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$p, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$k!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$k, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$p!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$p, |%other );
}

# %h{}
multi sub postcircumfix:<{ }>( \SELF ) is rw {
    nqp::decont(SELF);
}
multi sub postcircumfix:<{ }>(\SELF, :$BIND!) is rw {
    X::Bind::ZenSlice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<{ }>(\SELF, :$SINK!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$SINK, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, :$delete!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$delete, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, :$exists!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$exists, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, :$kv!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$kv, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, :$p!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$p, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, :$k!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$k, |%other );
}
multi sub postcircumfix:<{ }>(\SELF, :$p!, *%other) is rw {
    SLICE_MORE_HASH( SELF, SELF.keys, :$p, |%other );
}

# %h{;}
multi sub postcircumfix:<{ }> (\SELF is rw, LoL \keys, *%adv) is rw {
    if keys > 1 {
        X::NYI.new(feature => "Accessing dimensions after HyperWhatever").throw
            if keys[0].isa(HyperWhatever);

        if [||] %adv<kv p k> {
            postcircumfix:<{ }>(SELF, keys[0], :kv).map(-> \key, \value {
                map %adv<kv> ?? -> \key2, \value2 { LoL.new(key, |key2), value2 } !!
                    %adv<p>  ?? {; LoL.new(key, |.key) => .value } !!
                    # .item so that recursive calls don't map the LoL's elems
                    %adv<k>  ?? { LoL.new(key, |$_).item } !!
                    *, postcircumfix:<{ }>(value, LoL.new(|keys[1..*]), |%adv);
            }).eager.Parcel;
        } else {
            (keys[0].isa(Whatever)
                ?? SELF{SELF.keys}.Parcel
                !! SELF{keys[0].list}.Parcel
            ).map(-> \elem {
                postcircumfix:<{ }>(elem, LoL.new(|keys[1..*]), |%adv);
            }).eager.Parcel;
        }
    } else {
        postcircumfix:<{ }>(SELF, keys[0].elems > 1 ?? keys[0].list !! keys[0] , |%adv);
    }
}
multi sub postcircumfix:<{ }> (\SELF is rw, LoL \keys, Mu \ASSIGN) is rw {
    (SELF{keys},) = ASSIGN;
}

# From 'src/core/Scalar.pm'

my class Scalar { # declared in BOOTSTRAP
    # class Scalar is Any {
    #     has Mu $!descriptor;
    #     has Mu $!value;
    #     has Mu $!whence;

    multi method WHICH(Scalar:D:) {
        'Scalar|' ~ nqp::objectid($!descriptor);
    }
    method name() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Str !! $d.name()
    }
    method of() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Mu !! $d.of;
    }
    method default() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Mu !! $d.default;
    }
    method dynamic() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Mu !! so $d.dynamic;
    }
}

my class IntLexRef  { }
my class NumLexRef  { }
my class StrLexRef  { }
my class IntAttrRef { }
my class NumAttrRef { }
my class StrAttrRef { }
my class IntPosRef  { }
my class NumPosRef  { }
my class StrPosRef  { }

# From 'src/core/Code.pm'

my class Code does Callable { # declared in BOOTSTRAP
    # class Code is Any {
    #     has Mu $!do;                # Low level code object
    #     has Mu $!signature;         # Signature object
    #     has Mu $!compstuff;         # Place for the compiler to hang stuff

    multi method ACCEPTS(Code:D $self: Mu $topic) {
        $self.count ?? $self($topic) !! $self()
    }

    method arity(Code:D:) { $!signature.arity }

    method count(Code:D:) { $!signature.count }

    method signature(Code:D:) { $!signature }

    multi method Str(Code:D:) { warn("Code object coerced to string (please use .gist or .perl to do that)"); self.name }

    method outer(Code:D:) {
        nqp::ifnull(nqp::getcodeobj(nqp::p6staticouter($!do)), Mu)
    }

    # returns an identifier for this code object
    # that is the same even for cloned closures
    method static_id(Code:D:) {
        nqp::p6box_i(nqp::where(nqp::getstaticcode($!do)));
    }
}

# From 'src/core/WhateverCode.pm'

my class WhateverCode is Code {
}

# From 'src/core/Block.pm'

my class Block { # declared in BOOTSTRAP
    # class Block is Code {
    #     has Mu $!phasers;

    method add_phaser(Str $name, &block) {
        nqp::isnull($!phasers) &&
            nqp::bindattr(self, Block, '$!phasers', nqp::hash());
        nqp::existskey($!phasers, nqp::unbox_s($name)) ||
            nqp::bindkey($!phasers, nqp::unbox_s($name), nqp::list());
        if $name eq 'LEAVE' || $name eq 'KEEP' || $name eq 'UNDO' {
            nqp::unshift(nqp::atkey($!phasers, nqp::unbox_s($name)), &block);
            self.add_phaser('!LEAVE-ORDER', &block);
        }
        elsif $name eq 'NEXT' || $name eq '!LEAVE-ORDER' || $name eq 'POST' {
            nqp::unshift(nqp::atkey($!phasers, nqp::unbox_s($name)), &block);
        }
        else {
            nqp::push(nqp::atkey($!phasers, nqp::unbox_s($name)), &block);
        }
    }

    method fire_phasers(str $name) {
        if !nqp::isnull($!phasers) && nqp::existskey($!phasers, $name) {
            my Mu $iter := nqp::iterator(nqp::atkey($!phasers, $name));
            nqp::shift($iter).() while $iter;
        }
    }

    method phasers(Str $name) {
        unless nqp::isnull($!phasers) {
            if nqp::existskey($!phasers, nqp::unbox_s($name)) {
                return nqp::p6parcel(nqp::atkey($!phasers, nqp::unbox_s($name)), Mu);
            }
        }
        ()
    }

    multi method perl(Block:D:) {
        my $perl = '-> ';
        $perl ~= substr(self.signature().perl,1); # lose colon prefix
        $perl ~= ' { #`(' ~ self.WHICH ~ ') ... }';
        $perl
    }
}

# From 'src/core/Attribute.pm'

my class Attribute { # declared in BOOTSTRAP
    # class Attribute is Any {
    #     has str $!name;
    #     has int $!rw;
    #     has int $!has_accessor;
    #     has Mu $!type;
    #     has Mu $!container_descriptor;
    #     has Mu $!auto_viv_container;
    #     has Mu $!build_closure;
    #     has Mu $!package;
    #     has int $!positional_delegate;
    #     has int $!associative_delegate;
    #     has Mu $!why;

    method compose(Mu $package) {
        # Generate accessor method, if we're meant to have one.
        if self.has_accessor {
            my str $name   = nqp::unbox_s(self.name);
            my $meth_name := nqp::substr($name, 2);
            unless $package.^declares_method($meth_name) {
                my $dcpkg := nqp::decont($package);
                my $meth;
                my int $attr_type = nqp::objprimspec($!type);
                if self.rw {
                    $meth  := nqp::p6bool(nqp::iseq_i($attr_type, 0))
                        ??
                        method (Mu \fles:) is rw {
                            nqp::getattr(nqp::decont(fles), $dcpkg, $name)
                        }
                        !!
                        nqp::p6bool(nqp::iseq_i($attr_type, 1))
                        ??
                        method (Mu \fles:) is rw {
                            nqp::getattrref_i(nqp::decont(fles), $dcpkg, $name)
                        }
                        !!
                        nqp::p6bool(nqp::iseq_i($attr_type, 2))
                        ??
                        method (Mu \fles:) is rw {
                            nqp::getattrref_n(nqp::decont(fles), $dcpkg, $name)
                        }
                        !!
                        method (Mu \fles:) is rw {
                            nqp::getattrref_s(nqp::decont(fles), $dcpkg, $name)
                        }
                } else {
                    # ro accessor
                    $meth  := nqp::p6bool(nqp::iseq_i($attr_type, 0))
                        ??
                        method (Mu \fles:) {
                            nqp::getattr(nqp::decont(fles), $dcpkg, $name)
                        }
                        !!
                        nqp::p6bool(nqp::iseq_i($attr_type, 1))
                        ??
                        method (Mu \fles:) {
                            nqp::p6box_i(
                                nqp::getattr_i(nqp::decont(fles), $dcpkg, $name)
                            );
                        }
                        !!
                        nqp::p6bool(nqp::iseq_i($attr_type, 2))
                        ??
                        method (Mu \fles:) {
                            nqp::p6box_n(
                                nqp::getattr_n(nqp::decont(fles), $dcpkg, $name)
                            );
                        }
                        !!
                        method (Mu \fles:) {
                            nqp::p6box_s(
                                nqp::getattr_s(nqp::decont(fles), $dcpkg, $name)
                            );
                        }
                }
                $meth.set_name($meth_name);
                $package.^add_method($meth_name, $meth);
            }
        }

        # Apply any handles trait we may have.
        self.apply_handles($package);
    }

    method apply_handles(Mu $pkg) {
        # None by default.
    }

    method get_value(Mu $obj) {
        my $decont := nqp::decont($obj);
        given nqp::p6box_i(nqp::objprimspec($!type)) {
            when 0 { nqp::getattr($decont, $!package, $!name) }
            when 1 { nqp::p6box_i(nqp::getattr_i($decont, $!package, $!name)) }
            when 2 { nqp::p6box_n(nqp::getattr_n($decont, $!package, $!name)) }
            when 3 { nqp::p6box_s(nqp::getattr_s($decont, $!package, $!name)) }
        }
    }

    method set_value(Mu $obj, Mu \value) {
        my $decont := nqp::decont($obj);
        given nqp::p6box_i(nqp::objprimspec($!type)) {
            when 0 { nqp::bindattr($decont, $!package, $!name, value) }
            when 1 { nqp::p6box_i(nqp::bindattr_i($decont, $!package, $!name, value)) }
            when 2 { nqp::p6box_n(nqp::bindattr_n($decont, $!package, $!name, value)) }
            when 3 { nqp::p6box_s(nqp::bindattr_s($decont, $!package, $!name, value)) }
        }
    }

    method container() is rw { nqp::isnull($!auto_viv_container) ?? Mu !! $!auto_viv_container }
    method has-accessor() { ?$!has_accessor }
    method readonly() { !self.rw }
    method package() { $!package }
    multi method Str(Attribute:D:) { self.name }
    multi method gist(Attribute:D:) { self.type.^name ~ " " ~ self.name }

    method WHY() {
        if nqp::isnull($!why) {
            Any
        } else {
            $!why.set_docee(self);
            $!why
        }
    }

    method set_why($why) {
        $!why := $why;
    }
}

# From 'src/core/Variable.pm'

my class X::Comp::NYI { ... };
my class X::Comp::Trait::Unknown { ... };
my class X::Comp::Trait::NotOnNative { ... };
my class X::Comp::Trait::Scope { ... };


my class Variable {
    has str $.name;
    has str $.scope;
    has $.var is rw;
    has $.block;
    has $.slash;

    # make throwing easier
    submethod throw ( |c ) is hidden-from-backtrace {
        $*W.throw( self.slash, |c );
    }
}

# "is" traits
multi sub trait_mod:<is>(Variable:D $v, |c ) {
    $v.throw( 'X::Comp::Trait::Unknown',
      type      => 'is',
      subtype   => c.hash.keys[0],
      declaring => ' variable',
      expected  => <TypeObject default dynamic>,
    );
}
multi sub trait_mod:<is>(Variable:D $v, Mu:U $is ) {
    $v.throw( 'X::Comp::NYI',
      feature => "Variable trait 'is TypeObject'",
    );
}
multi sub trait_mod:<is>(Variable:D $v, :$default!) {
    my $var  := $v.var;
    my $what := $var.VAR.WHAT;
    try { nqp::getattr(
            $var,
            $what.^mixin_base,
            '$!descriptor',
          ).set_default(nqp::decont($default));
        CATCH {
            nqp::istype($default,Whatever)
              ?? $v.throw( 'X::Comp::NYI',
                :feature<is default(*) on natives> )
              !! $v.throw( 'X::Comp::Trait::NotOnNative',
                :type<is>, :subtype<default> ); # can't find out native type yet
        }
    }

    # make sure we start with the default if a scalar
    $var = $default if nqp::istype($what, Scalar);
}
multi sub trait_mod:<is>(Variable:D $v, :$dynamic!) {
    my $var  := $v.var;
    my $what := $var.VAR.WHAT;
    try { nqp::getattr(
            $var,
            $what.^mixin_base,
            '$!descriptor',
          ).set_dynamic($dynamic);
        CATCH {
            $v.throw( 'X::Comp::Trait::NotOnNative',
              :type<is>, :subtype<dynamic> ); # can't find out native type yet
        }
    }
}
multi sub trait_mod:<is>(Variable:D $v, :$export!) {
    if $v.scope ne 'our' {
        $v.throw( 'X::Comp::Trait::Scope',
          type      => 'is',
          subtype   => 'export',
          declaring => 'variable',
          scope     => $v.scope,
          supported => ['our'],
        );
    }
    my $var  := $v.var;
    my @tags = 'ALL', (nqp::istype($export,Pair) ?? $export.key() !!
                       nqp::istype($export,Positional) ?? @($export)>>.key !!
                       'DEFAULT');
    EXPORT_SYMBOL($var.VAR.name, @tags, $var);
}

# "of" traits
multi sub trait_mod:<of>(Variable:D $v, |c ) {
    $v.throw( 'X::Comp::Trait::Unknown',
      type      => 'of',
      subtype   => c.hash.keys[0],
      declaring => ' variable',
      expected  => <TypeObject>,
    );
}
multi sub trait_mod:<of>(Variable:D $v, Mu:U $of ) {
    my $var  := $v.var;
    my $what := $var.VAR.WHAT;
    my $how  := $what.HOW;
    try { nqp::getattr(
            $var,
            $how.mixin_base($what),
            '$!descriptor'
          ).set_of(nqp::decont($of));
        CATCH {
            $v.throw( 'X::Comp::Trait::NotOnNative',
              :type<of>, :subtype($of.^name) ); # can't find out native type yet
        }
    }
    # probably can go if we have a COMPOSE phaser
    $how.set_name($what,"{$how.name($what)}[{$of.^name}]");
}

multi sub trait_mod:<will>(Variable:D $v, $block, |c ) {
    $v.throw( 'X::Comp::Trait::Unknown',
      type      => 'will',
      subtype   => c.hash.keys[0],
      declaring => ' variable',
      expected  => ('begin check final init end',
                    'enter leave keep undo',
                    'first next last pre post',
                    'compose'),
    );
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$begin! ) {
    $block(); # no need to delay execution
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$check! ) {
    $*W.add_phaser($v.slash, 'CHECK', $block)
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$final! ) {
    $v.throw( 'X::Comp::NYI',
      feature => "Variable trait 'will final {...}'",
    );
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$init! ) {
#    $*W.add_phaser($v.slash, 'INIT', $block)  # doesn't work :-(
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$end! ) {
#    $*W.add_phaser($v.slash, 'END', $block)  # doesn't work :-(
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$enter! ) {
    $v.block.add_phaser('ENTER', $block)
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$leave! ) {
    $v.block.add_phaser('LEAVE', $block)
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$keep! ) {
    $v.block.add_phaser('KEEP', $block)
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$undo! ) {
    $v.block.add_phaser('UNDO', $block)
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$first! ) {
    $v.block.add_phaser('FIRST', $block)
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$next! ) {
    $v.block.add_phaser('NEXT', $block)
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$last! ) {
    $v.block.add_phaser('LAST', $block)
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$pre! ) {
    $v.block.add_phaser('PRE', $block)
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$post! ) {
#    $v.block.add_phaser('POST', $block)  # doesn't work :-(
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$compose! ) {
#    $*W.add_phaser($v.slash, 'COMPOSE', $block)  # doesn't work :-(
}

# From 'src/core/Routine.pm'

my class X::Routine::Unwrap { ... }

my role HardRoutine {
    method soft() { False }
}
my role SoftRoutine {
    method soft() { True }
}

my class Routine { # declared in BOOTSTRAP
    # class Routine is Block {
    #     has Mu $!dispatchees;
    #     has Mu $!dispatcher_cache;
    #     has Mu $!dispatcher;
    #     has int $!rw;
    #     has Mu $!inline_info;
    #     has int $!yada;
    #     has Mu $!package;
    #     has int $!onlystar;
    #     has Mu $!dispatch_order;
    #     has Mu $!dispatch_cache;
    #     has Mu $!why;

    method of() { self.signature.returns }
    method returns() { self.signature.returns }
    method onlystar() { nqp::p6bool($!onlystar) }

    method assuming($r: |curried) {
        return sub CURRIED (|direct) {
            $r(|curried, |direct)
        }
    }

    method candidates() {
        self.is_dispatcher ??
            nqp::hllize($!dispatchees) !!
            (self,)
    }

    method cando(Capture $c) {
        my $disp;
        if self.is_dispatcher {
            $disp := self;
        }
        else {
            $disp := nqp::create(self);
            nqp::bindattr($disp, Routine, '$!dispatchees', nqp::list(self));
        }
        # Call this lexical sub to get rid of 'self' in the signature.
        sub checker(|) {
            nqp::hllize($disp.find_best_dispatchee(nqp::usecapture(), 1))
        }
        checker(|$c);
    }

    method multi() {
        self.dispatcher.defined
    }

    multi method perl(Routine:D:) {
        my $perl = ( self.^name ~~ m/^\w+/ ).lc;
        if self.name() -> $n {
            $perl ~= " $n";
        }
        $perl ~= ' ' ~ substr(self.signature().perl,1); # lose colon prefix
        $perl ~= ' { #`(' ~ self.WHICH ~ ') ... }';
        $perl
    }

    method soft() {
        Mu
    }

    method wrap(&wrapper) {
        my class WrapHandle {
            has $!dispatcher;
            has $!wrapper;
            method restore() {
                nqp::p6bool($!dispatcher.remove($!wrapper));
            }
        }
        my role Wrapped {
            has $!dispatcher;
            method UNSHIFT_WRAPPER(&wrapper) {
                # Add candidate.
                $!dispatcher := WrapDispatcher.new()
                    unless nqp::isconcrete($!dispatcher);
                $!dispatcher.add(&wrapper);

                # Return a handle.
                my $handle := nqp::create(WrapHandle);
                nqp::bindattr($handle, WrapHandle, '$!dispatcher', $!dispatcher);
                nqp::bindattr($handle, WrapHandle, '$!wrapper', &wrapper);
                $handle
            }
            method CALL-ME(|c) is rw {
                $!dispatcher.enter(|c);
            }
            method soft() { True }
        }

        # We can't wrap a hardened routine (that is, one that's been
        # marked inlinable).
        if nqp::istype(self, HardRoutine) {
            die "Cannot wrap a HardRoutine, since it may have been inlined; " ~
                "use the 'soft' pragma to avoid marking routines as hard.";
        }

        # If we're not wrapped already, do the initial dispatcher
        # creation.
        unless nqp::istype(self, Wrapped) {
            my $orig = self.clone();
            self does Wrapped;
            self.UNSHIFT_WRAPPER($orig);
        }

        # Add this wrapper.
        self.UNSHIFT_WRAPPER(&wrapper);
    }

    method unwrap($handle) {
        $handle.can('restore') && $handle.restore() ||
            X::Routine::Unwrap.new.throw
    }

    method yada() {
        nqp::p6bool(nqp::getattr_i(self, Routine, '$!yada'))
    }

    method package() { $!package }

    method WHY() {
        if nqp::isnull($!why) {
            Any
        } else {
            $!why.set_docee(self);
            $!why
        }
    }

    method set_why($why) {
        $!why := $why;
    }
}

multi sub trait_mod:<is>(Routine $r, :$cached!) {
    my %cache;
    nqp::bindattr_i($r, Routine, '$!onlystar', 0 )
      if $r.onlystar; # disable optimization
    $r.wrap(-> |c {
        my $key := c.gist;
        %cache.EXISTS-KEY($key)
          ?? %cache{$key}
          !! (%cache{$key} := callsame);
    });
}

# From 'src/core/Sub.pm'

my class Sub { # declared in BOOTSTRAP
    # class Sub is Routine { ... }

}

# From 'src/core/Macro.pm'

my class Macro is Routine {
}

# From 'src/core/Method.pm'

my class Method { # declared in BOOTSTRAP
    # class Method is Routine { ... }

    multi method gist(Method:D:) { self.name }
}

# From 'src/core/Submethod.pm'

my class Submethod { # declared in BOOTSTRAP
    # class Submethod is Routine { ... }

    multi method gist(Submethod:D:) { self.name }
}

# From 'src/core/Junction.pm'

my class Junction { # declared in BOOTSTRAP
    # class Junction is Mu {
    #     has Mu $!storage;             # elements of Junction
    #     has str $!type;                # type of Junction

    proto method new(|) { * }
    multi method new(@values, Str :$type!) {
        my $junc := nqp::create(Junction);
        nqp::bindattr($junc, Junction, '$!storage', @values.eager);
        nqp::bindattr($junc, Junction, '$!type', $type);
        $junc
    }
    multi method new(*@values, Str :$type!) {
        my $junc := nqp::create(Junction);
        nqp::bindattr($junc, Junction, '$!storage', @values.eager);
        nqp::bindattr($junc, Junction, '$!type', $type);
        $junc
    }

    multi method Bool(Junction:D:) {
        SEQ($!storage.map({return True if $_}).gimme(*); return False)
            if nqp::iseq_s($!type, 'any');
        SEQ($!storage.map({return False unless $_}).gimme(*); return True)
            if nqp::iseq_s($!type, 'all');
        SEQ($!storage.map({return False if $_}).gimme(*); return True)
            if nqp::iseq_s($!type, 'none');
        # 'one' junction
        my $count = 0;
        $!storage.map({ $count++ if $_; return False if $count > 1 }).gimme(*);
        $count == 1;
    }

    multi method Str(Junction:D:) {
        self.perl
    }

    multi method ACCEPTS(Junction:D: Mu \topic) {
        SEQ($!storage.map({return True if $_.ACCEPTS(topic)}).gimme(*); return False)
            if nqp::iseq_s($!type, 'any');
        SEQ($!storage.map({return False unless $_.ACCEPTS(topic)}).gimme(*); return True)
            if nqp::iseq_s($!type, 'all');
        SEQ($!storage.map({return False if $_.ACCEPTS(topic)}).gimme(*); return True)
            if nqp::iseq_s($!type, 'none');
        # 'one' junction
        my $count = 0;
        $!storage.map({ $count++ if $_.ACCEPTS(topic); return False if $count > 1 }).gimme(*);
        $count == 1;
    }

    multi method gist(Junction:D:) {
        $!type ~ '(' ~ $!storage.map({$_.gist}).join(', ') ~ ')'
    }

    multi method perl(Junction:D:) {
        $!type ~ '(' ~ $!storage.map({$_.perl}).join(', ') ~ ')'
    }

    method CALL-ME(|c) {
        self.AUTOTHREAD(
            -> $obj, |c { $obj(|c) },
            self, |c);
    }

    method sink(Junction:D:) {
        .?sink for $!storage.list;
        Nil;
    }

    method AUTOTHREAD(&call, |args) {
        my Mu $pos_rpa := nqp::getattr(nqp::decont(args), Capture, '$!list');
        sub thread_junction(int $i) {
            my Junction $arg := nqp::atpos($pos_rpa, $i);
            my Str $type := nqp::getattr(nqp::decont($arg), Junction, '$!type');
            my @states := nqp::getattr(nqp::decont($arg), Junction, '$!storage');

            my Mu $res := nqp::list();
            for @states -> \st {
                # Next line is Officially Naughty, since captures are meant to be
                # immutable. But hey, it's our capture to be naughty with...
                nqp::bindpos($pos_rpa, $i, st);
                nqp::push($res, call(|args));
                Nil;
            }
            my $res_junc := nqp::clone(nqp::decont($arg));
            nqp::bindattr($res_junc, Junction, '$!storage', nqp::p6parcel($res, Nil));
            return $res_junc;
        }

        # Look for a junctional arg in the positionals.

        # we have to autothread the first all or none junction before
        # doing any one or any junctions.
        my int $first_one_any = -1;
        loop (my int $i = 0; $i < nqp::elems($pos_rpa); $i = $i + 1) {
            # Junctional positional argument?
            my Mu $arg := nqp::atpos($pos_rpa, $i);
            if nqp::istype($arg, Junction) {
                my Str $type := nqp::getattr(nqp::decont($arg), Junction, '$!type');
                if nqp::iseq_s($type, 'any') || nqp::iseq_s($type, 'one') {
                    if $first_one_any == -1 {
                        # save it for later, first make sure we don't have all or none junctions later.
                        $first_one_any = $i;
                    }
                } else {
                    return thread_junction($i);
                }
            }
        }

        if $first_one_any >= 0 {
            return thread_junction($first_one_any);
        }

        # Otherwise, look for one in the nameds.
        for args.hash.kv -> $k, $v {
            if nqp::istype($v, Junction) {
                my Mu $nam_hash := nqp::getattr(nqp::decont(args), Capture, '$!hash');
                my @states := nqp::getattr(nqp::decont($v), Junction, '$!storage');
                my $type   := nqp::getattr(nqp::decont($v), Junction, '$!type');
                my Mu $res := nqp::list();
                for @states -> \st {
                    nqp::bindkey($nam_hash, $k, st);
                    nqp::push($res, call(|args));
                    Nil;
                }
                my $res_junc := nqp::clone(nqp::decont($v));
                nqp::bindattr($res_junc, Junction, '$!storage', nqp::p6parcel($res, Nil));
                return $res_junc;
            }
        }

        # If we get here, wasn't actually anything to autothread.
        call(|args);
    }
}

sub any(*@values) { Junction.new(@values, :type<any>); }
sub all(*@values) { Junction.new(@values, :type<all>); }
sub one(*@values) { Junction.new(@values, :type<one>); }
sub none(*@values) { Junction.new(@values, :type<none>); }

sub infix:<|>(**@values) { Junction.new(@values, :type<any>); }
sub infix:<&>(**@values) { Junction.new(@values, :type<all>); }
sub infix:<^>(**@values) { Junction.new(@values, :type<one>); }

sub AUTOTHREAD(|c) {
    Junction.AUTOTHREAD(|c)
}

sub AUTOTHREAD_METHOD($name, |c) {
    Junction.AUTOTHREAD(
        -> $obj, |c { $obj."$name"(|c) },
        |c);
}

nqp::p6setautothreader(&AUTOTHREAD);
Mu.HOW.setup_junction_fallback(Junction, &AUTOTHREAD_METHOD);

# From 'src/core/Cool.pm'

my role  IO         { ... }
my class IO::Path   { ... }

my class SprintfHandler {
    method mine($x) { nqp::reprname($x) eq "P6opaque"; }

    method int($x) { $x.Int }
}

my $sprintfHandlerInitialized = False;

my class Cool { # declared in BOOTSTRAP
    # class Cool is Any {

    ## numeric methods

    method abs()  { self.Numeric.abs }
    method conj()  { self.Numeric.conj }
    method sqrt()  { self.Numeric.sqrt }
    method sign()  { self.Real.sign }
    method rand() { self.Num.rand }
    method sin()  { self.Numeric.sin }
    method asin() { self.Numeric.asin }
    method cos()  { self.Numeric.cos }
    method acos() { self.Numeric.acos }
    method tan()  { self.Numeric.tan }
    method atan() { self.Numeric.atan }
    method atan2($y = 1e0) { self.Numeric.atan2($y.Numeric) }
    method sec()  { self.Numeric.sec }
    method asec() { self.Numeric.asec }
    method cosec()  { self.Numeric.cosec }
    method acosec() { self.Numeric.acosec }
    method cotan()  { self.Numeric.cotan }
    method acotan() { self.Numeric.acotan }
    method sinh()  { self.Numeric.sinh }
    method asinh() { self.Numeric.asinh }
    method cosh()  { self.Numeric.cosh }
    method acosh() { self.Numeric.acosh }
    method tanh()  { self.Numeric.tanh }
    method atanh() { self.Numeric.atanh }
    method sech()  { self.Numeric.sech }
    method asech() { self.Numeric.asech }
    method cosech()  { self.Numeric.cosech }
    method acosech() { self.Numeric.acosech }
    method cotanh()  { self.Numeric.cotanh }
    method acotanh() { self.Numeric.acotanh }
    method cis()     { self.Numeric.cis }

    proto method log(|) {*}
    multi method log(Cool:D: )      { self.Numeric.log          }
    multi method log(Cool:D: $base) { self.Numeric.log($base.Numeric) }

    proto method exp(|) {*}
    multi method exp(Cool:D: )      { self.Numeric.exp          }
    multi method exp(Cool:D: $base) { self.Numeric.exp($base.Numeric) }

    proto method round(|) { * }
    multi method round()      { self.Numeric.round()      }
    multi method round($base) { self.Numeric.round($base) }

    method roots(Cool $n)   { self.Numeric.roots($n)    }
    method log10()          { self.Numeric.log10        }
    method unpolar($n)      { self.Numeric.unpolar($n.Numeric) }

    method floor()          { self.Numeric.floor        }
    method ceiling()        { self.Numeric.ceiling      }
    method truncate()       { self.Numeric.truncate     }

    ## string methods

    method chars() {
        nqp::p6box_i(nqp::chars(nqp::unbox_s(self.Str)));
    }
    method codes() {
        nqp::p6box_i(nqp::chars(nqp::unbox_s(self.Str)));
    }

    method fmt($format = '%s') {
        unless $sprintfHandlerInitialized {
            nqp::sprintfaddargumenthandler(SprintfHandler.new);
            $sprintfHandlerInitialized = True;
        }
        nqp::p6box_s(
            nqp::sprintf(nqp::unbox_s($format.Stringy), nqp::list(self))
        )
    }

    method substr($from, $length?)           { substr(   self,$from,$length) }
    method substr-rw(\SELF: $from, $length?) { substr-rw(SELF,$from,$length) }

    method uc() {
        nqp::p6box_s(nqp::uc(nqp::unbox_s(self.Str)))
    }

    method lc() {
        nqp::p6box_s(nqp::lc(nqp::unbox_s(self.Str)))
    }

    method tc() {
        my $u := nqp::unbox_s(self.Str);
        nqp::p6box_s(nqp::uc(nqp::substr($u,0,1)) ~ nqp::substr($u,1));
    }

    method tclc() {
        nqp::p6box_s(nqp::tclc(nqp::unbox_s(self.Str)))
    }

    method wordcase()   { self.Str.wordcase }

    method chomp() {
        self.Str.chomp;
    }

    method chop() {
        self.Str.chop
    }

    method ord(--> Int) {
        my $s := self.Str;
        $s.chars
          ?? nqp::p6box_i(nqp::ord(nqp::unbox_s($s)))
          !! Int;
    }
    method chr() {
        self.Int.chr;
    }
    method chrs(Cool:D:) {
        self>>.chr.join;
    }

    method flip() {
        nqp::p6box_s(nqp::flip(nqp::unbox_s(self.Str)))
    }
    method trans(*@a) { self.Str.trans(@a) }

    proto method has-substr(|) {*}
    multi method has-substr(Cool $needle, Cool $pos = 0) {
        ?nqp::eqat(
            nqp::unbox_s(self.Str),
            nqp::unbox_s($needle.Str),
            nqp::unbox_i($pos.Int)
        );
    }

    proto method starts-with(|) {*}
    multi method starts-with(Str:D: Str(Cool) $needle) {
        nqp::p6bool(
          nqp::eqat(nqp::unbox_s(self),nqp::unbox_s($needle),0)
        );
    }
    multi method starts-with(Cool:D: Str(Cool) $needle) {
        nqp::p6bool(
          nqp::eqat(nqp::unbox_s(self.Str),nqp::unbox_s($needle),0)
        );
    }

    proto method ends-with(Str(Cool) $suffix) { * }
    multi method ends-with(Str:D: Str(Cool) $suffix) {
        my str $str    = nqp::unbox_s(self);
        my str $needle = nqp::unbox_s($suffix);
        nqp::p6bool(
          nqp::eqat($str,$needle,nqp::chars($str) - nqp::chars($needle))
        );
    }
    multi method ends-with(Cool:D: Str(Cool) $suffix) {
        my str $str    = nqp::unbox_s(self.Str);
        my str $needle = nqp::unbox_s($suffix);
        nqp::p6bool(
          nqp::eqat($str,$needle,nqp::chars($str) - nqp::chars($needle))
        );
    }

    proto method substr-eq(|) {*}
    multi method substr-eq(Str:D: Str(Cool) $needle, Int(Cool) $pos) {
        $pos >= 0 && nqp::p6bool(
          nqp::eqat(nqp::unbox_s(self),nqp::unbox_s($needle),nqp::unbox_i($pos))
        );
    }
    multi method substr-eq(Cool:D: Str(Cool) $needle, Int(Cool) $pos) {
        $pos >= 0 && nqp::p6bool(nqp::eqat(
          nqp::unbox_s(self.Str),
          nqp::unbox_s($needle),
          nqp::unbox_i($pos)
        ));
    }

    proto method index(|) {*}
    multi method index(Cool $needle, Cool $pos = 0) {
        my int $result = nqp::index(
                nqp::unbox_s(self.Str),
                nqp::unbox_s($needle.Str),
                nqp::unbox_i($pos.Int)
        );
        # TODO: fail() instead of returning Int
        $result < 0 ?? Int !! nqp::p6box_i($result);
    }

    proto method rindex(|) {*}
    multi method rindex(Cool $needle, Cool $pos?) {
        my $result = $pos.defined
            ?? nqp::p6box_i(
                nqp::rindex(
                    nqp::unbox_s(self.Str),
                    nqp::unbox_s($needle.Str),
                    nqp::unbox_i($pos.Int)
                ))
            !! nqp::p6box_i(
                nqp::rindex(
                    nqp::unbox_s(self.Str),
                    nqp::unbox_s($needle.Str),
                ));
        fail "substring not found" if $result < 0;
        $result;
    }

    method ords(Cool:D:) { self.Str.ords }
    proto method split(|) {*}
    multi method split(Regex $pat, $limit = Inf, :$all) {
        self.Stringy.split($pat, $limit, :$all);
    }
    multi method split(Cool $pat, $limit = Inf, :$all) {
        self.Stringy.split($pat.Stringy, $limit, :$all);
    }
    proto method match(|) {*}
    multi method match(Cool:D: $target, *%adverbs) {
        self.Stringy.match($target, |%adverbs)
    }

    proto method comb(|) {*}
    multi method comb() { self.Str.comb() }
    multi method comb(Regex $matcher, $limit = Inf) { self.Str.comb($matcher, $limit) }

    proto method lines(|) {*}
    multi method lines(Cool:D: |c) { self.Str.lines(|c) }

    proto method words(|) {*}
    multi method words(Cool:D: |c) { self.Str.words(|c) }

    proto method subst(|) {
        $/ := nqp::getlexdyn('$/');
        {*}
    }
    multi method subst($matcher, $replacement, *%adverbs) {
        $/ := nqp::getlexdyn('$/');
        self.Stringy.subst($matcher, $replacement, |%adverbs);
    }

    proto method subst-mutate(|c) {
        $/ := nqp::getlexdyn('$/');
        {*}
    }
    multi method subst-mutate($self is rw: |c) {
        $/ := nqp::getlexdyn('$/');
        my $str = Str($self);
        $str.subst-mutate(|c);
        $self = $str;
    }

    proto method IO(|) { * }
    multi method IO(|c) { IO::Path.new(self) }

    method sprintf(*@args) { sprintf(self, @args) };
    method printf (*@args) {  printf(self, @args) };
    method samecase(Cool:D: Cool $pattern) { self.Stringy.samecase($pattern) }

    method path() { self.Stringy.IO }
    method trim         () { self.Stringy.trim          };
    method trim-leading () { self.Stringy.trim-leading  };
    method trim-trailing() { self.Stringy.trim-trailing };

    method EVAL(*%opts) {
        EVAL(self, context => CALLER::, |%opts);
    }

    multi method Real() { self.Numeric.Real }

    proto method Int(|) { * }
    multi method Int()  { self.Numeric.Int }

    proto method UInt(|) { * }
    multi method UInt()  {
        my $got := self.Int;
        fail X::OutOfRange.new(
          :what<Coercion to UInt>,
          :$got,
          :range("0..Inf")
        ) if $got < 0;
        $got;
    }

    method Num()  { self.Numeric.Num }
    method Rat()  { self.Numeric.Rat }
}
Metamodel::ClassHOW.exclude_parent(Cool);

sub chop(Cool $s) returns Str      { $s.chop }
sub chomp(Cool $s) returns Str     { $s.chomp }
sub flip(Cool $s) returns Str      { $s.flip }
sub index(Cool $s,$needle,$pos=0)  { $s.index($needle,$pos) }
sub lc(Cool $s)                    { $s.lc }
sub ord(Cool $s)                   { $s.ord }
sub uc(Cool $s)                    { $s.uc }
sub tc(Cool $s)                    { $s.tc }
sub tclc(Cool $s)                  { $s.tclc }

proto sub rindex($, $, $?) is pure { * };
multi sub rindex(Cool $s, Cool $needle, Cool $pos) { $s.rindex($needle, $pos) };
multi sub rindex(Cool $s, Cool $needle)            { $s.rindex($needle) };

proto sub ords($) is pure     { * }
multi sub ords(Cool $s)       { ords($s.Stringy) }

proto sub comb($, $, $?)            { * }
multi sub comb(Regex $matcher, Cool $input, $limit = *) { $input.comb($matcher, $limit) }

proto sub wordcase($) is pure { * }
multi sub wordcase(Str:D $x) {$x.wordcase }
multi sub wordcase(Cool $x)  {$x.Str.wordcase }

sub sprintf(Cool $format, *@args) {
    unless $sprintfHandlerInitialized {
        nqp::sprintfaddargumenthandler(SprintfHandler.new);
        $sprintfHandlerInitialized = True;
    }

    @args.gimme(*);
    nqp::p6box_s(
        nqp::sprintf(nqp::unbox_s($format.Stringy),
            nqp::clone(nqp::getattr(@args, List, '$!items'))
        )
    );
}

sub printf(Cool $format, *@args) { print sprintf $format, @args };
sub samecase(Cool $string, Cool $pattern) { $string.samecase($pattern) }
sub split($pat, Cool $target, $limit = Inf, :$all) {
    $target.split($pat, $limit, :$all);
}

proto sub chars($) is pure {*}
multi sub chars(Cool $x)  { $x.Str.chars }
multi sub chars(Str:D $x) { nqp::p6box_i(nqp::chars($x)) }
multi sub chars(str $x) returns int { nqp::chars($x) }

# From 'src/core/Enumeration.pm'

my role Enumeration {
    has $.key;
    has $.value;

    multi method Numeric(::?CLASS:D:) { $!value.Numeric }

    method enums() {
        self.^enum_values
    }

    multi method gist(::?CLASS:D:) {
        $!key
    }

    multi method kv(::?CLASS:D:) { ($!key, $!value) }

    method pair(::?CLASS:D:) { $!key => $!value }

    method perl() {
        self.defined ??
            (self.^name ~ '::' ~ $!key) !!
            self.^name;
    }

    method pick(*@pos, *%named) {
        self.defined
          ?? self xx +?( @pos[0] // 1 )
          !! self.^enum_value_list.pick(|@pos, |%named);
    }
    method roll(*@pos, *%named) {
        self.defined
          ?? self xx ( @pos[0] // 1 )
          !! self.^enum_value_list.roll(|@pos, |%named);
    }

    method Int(::?CLASS:D:) {
        self.value.Int
    }

    method CALL-ME(|) {
        my $x := nqp::atpos(nqp::p6argvmarray(), 1).AT-POS(0);
        nqp::istype($x, ::?CLASS)
            ?? $x
            !! self.^enum_from_value($x)
    }
}

my role NumericEnumeration {
    multi method Str(::?CLASS:D:) {
        self.key
    }
}
my role StringyEnumeration {
    multi method Str(::?CLASS:D:) {
        self.value
    }
}

sub ANON_ENUM(*@args) {
    my Mu $prev = -1;
    my %res;
    for @args {
        if .^isa(Enum) {
            %res{.key} = $prev = .value;
        }
        else {
            %res{$_} = $prev.=succ;
        }
    }
    my $r := nqp::create(EnumMap);
    nqp::bindattr($r, EnumMap, '$!storage',
        nqp::getattr(%res, EnumMap, '$!storage'));
    $r;
}

Metamodel::EnumHOW.set_composalizer(-> $type, $name, %enum_values {
    my Mu $r := Metamodel::ParametricRoleHOW.new_type(:name($name));
    $r.^add_attribute(Attribute.new(
        :name('$!' ~ $name), :type(nqp::decont($type)),
        :has_accessor(1), :package($r)));
    for %enum_values.kv -> $key, $value {
        my $meth = method () { self."$name"() === $value }
        $meth.set_name($key);
        $r.^add_method($key, $meth);
    }
    $r.^set_body_block( -> |c {nqp::list($r,nqp::hash('$?CLASS',c<$?CLASS>))});
    $r.^compose;
    $r
});

# From 'src/core/Bool.pm'

my class Bool { # declared in BOOTSTRAP
    # class Bool is Cool {
    #     has int $!value;

    multi method Bool(Bool:D:)    { self }
    multi method Numeric(Bool:D:) { self ?? 1 !! 0 }
    multi method Str(Bool:D:)     { self ?? 'True' !! 'False' }
    multi method gist(Bool:D:)    { self ?? 'True' !! 'False' }
    multi method DUMP(Bool:D:)    { self.Str }

    method Int()     { self ?? 1 !! 0 }

    method pred() { Bool::False }
    method succ() { Bool::True }

    method key() { self.Str }
    method value() { self.Numeric }

    proto method pick(|) { * }
    multi method pick(Bool:U:)    { nqp::p6bool(nqp::isge_n(nqp::rand_n(2e0), 1e0)) }
    multi method pick(Bool:U: $n) { (Bool::True,Bool::False).pick($n) }

    proto method roll(|) { * }
    multi method roll(Bool:U:)    { nqp::p6bool(nqp::isge_n(nqp::rand_n(2e0), 1e0)) }
    multi method roll(Bool:U: $n) { (Bool::True,Bool::False).roll($n) }

    multi method ACCEPTS(Bool:D: Mu \topic ) { self }

    multi method perl(Bool:D:) { self ?? 'Bool::True' !! 'Bool::False' }

    method enums() {
        my % = False => 0, True => 1
    }
}

multi sub prefix:<++>(Bool:U \a is rw)  { a = True; }
multi sub prefix:<-->(Bool:U \a is rw)  { a = False; }
multi sub postfix:<++>(Bool:U \a is rw) { a = True; False; }
multi sub postfix:<-->(Bool:U \a is rw) { a = False; }

proto sub prefix:<?>(Mu $) is pure { * }
multi sub prefix:<?>(Bool:D \a) { a }
multi sub prefix:<?>(Mu \a) { a.Bool }

proto sub prefix:<so>(Mu $) is pure { * }
multi sub prefix:<so>(Bool:D \a) { a }
multi sub prefix:<so>(Mu \a) { a.Bool }

proto sub prefix:<!>(Mu $) is pure { * }
multi sub prefix:<!>(Bool \a) { nqp::p6bool(nqp::not_i(nqp::istrue(a))) }
multi sub prefix:<!>(Mu \a) { nqp::p6bool(nqp::not_i(nqp::istrue(a))) }

proto sub prefix:<not>(Mu $) is pure { * }
multi sub prefix:<not>(Bool \a) { nqp::p6bool(nqp::not_i(nqp::istrue(a))) }
multi sub prefix:<not>(Mu \a) { nqp::p6bool(nqp::not_i(nqp::istrue(a))) }

proto sub prefix:<?^>(Mu $) is pure { * }
multi sub prefix:<?^>(Mu \a) { not a }

proto sub infix:<?&>(|) is pure          { * }
multi sub infix:<?&>(Mu $x = Bool::True) { $x.Bool }
multi sub infix:<?&>(Mu \a, Mu \b)       { a.Bool && b.Bool }

proto sub infix:<?|>(|) is pure           { * }
multi sub infix:<?|>(Mu $x = Bool::False) { $x.Bool }
multi sub infix:<?|>(Mu \a, Mu \b)        { a.Bool || b.Bool }

proto sub infix:<?^>(|) is pure           { * }
multi sub infix:<?^>(Mu $x = Bool::False) { $x.Bool }
multi sub infix:<?^>(Mu \a, Mu \b)        { nqp::p6bool(nqp::ifnull(nqp::xor(a.Bool,b.Bool), 0)) }

proto sub infix:<&&>(|)                   { * }
multi sub infix:<&&>(Mu $x = Bool::True)  { $x }
multi sub infix:<&&>(Mu \a, Mu \b)        { a && b }

proto sub infix:<||>(|)                   { * }
multi sub infix:<||>(Mu $x = Bool::False) { $x }
multi sub infix:<||>(Mu \a, Mu \b)        { a || b }

proto sub infix:<^^>(|)                   { * }
multi sub infix:<^^>(Mu $x = Bool::False) { $x }
multi sub infix:<^^>(Mu \a, Mu \b)        { a ^^ b }
multi sub infix:<^^>(*@a) {
    my $a = shift @a;
    while @a {
        my $b := shift @a;
        next unless $b;
        return Nil if $a;
        $a := $b;
    }
    $a;
}

proto sub infix:<//>(|)                   { * }
multi sub infix:<//>(Mu $x = Any)         { $x }
multi sub infix:<//>(Mu \a, Mu \b)        { a // b }

proto sub infix:<and>(|)                  { * }
multi sub infix:<and>(Mu $x = Bool::True) { $x }
multi sub infix:<and>(Mu \a, Mu \b)       { a && b }

proto sub infix:<or>(|)                   { * }
multi sub infix:<or>(Mu $x = Bool::False) { $x }
multi sub infix:<or>(Mu \a, Mu \b)        { a || b }

proto sub infix:<xor>(|)                   { * }
multi sub infix:<xor>(Mu $x = Bool::False) { $x }
multi sub infix:<xor>(Mu \a, Mu \b)        { a ^^ b }
multi sub infix:<xor>(*@a)                 { &infix:<^^>(@a); }

proto sub infix:<orelse>(|)               { * }
multi sub infix:<orelse>(Mu $x = Any)     { $x }
multi sub infix:<orelse>(Mu \a, Mu \b)    { a // b }

# From 'src/core/Numeric.pm'

my class X::Numeric::DivideByZero { ... }

my role Numeric {
    multi method Numeric(Numeric:D:) { self }

    multi method ACCEPTS(Numeric:D: $a) {
        self.isNaN ?? $a.defined && $a.isNaN !! $a == self;
    }

    proto method log(|) {*}
    multi method log(Numeric:D: Cool $base) { self.log / $base.Numeric.log }
    multi method log(Numeric:D: Numeric $base) { self.log / $base.log         }

    method log10() { self.log / 10e0.log }

    proto method exp(|) {*}
    multi method exp(Numeric:D: $base) {
        $base ** self;
    }
    method roots(Cool $n) { self.Complex.roots($n.Int) }

    multi method Bool(Numeric:D:) { self != 0 }

    multi method gist(Numeric:D:) { self.Str }
    multi method DUMP(Numeric:D:) { self.perl }

    method succ() { self + 1 }
    method pred() { self - 1 }
}

multi sub infix:<eqv>(Numeric:D $a, Numeric:D $b) {
    $a.WHAT === $b.WHAT && ($a cmp $b) == 0
}

## arithmetic operators

proto sub prefix:<+>($?) is pure { * }
multi sub prefix:<+>(\a) { a.Numeric }

proto sub prefix:<->($?) is pure { * }
multi sub prefix:<->(\a) { -a.Numeric }

proto sub abs($) is pure { * }
multi sub abs(\a) { abs a.Numeric }

proto sub sign($) is pure {*}
multi sub sign(Numeric \x) { x.sign }
multi sub sign(Cool \x)    { x.Numeric.sign }

proto sub log($, $?) is pure {*}
multi sub log(Numeric $x) { $x.log }
multi sub log(Numeric $x, Numeric $base) { $x.log($base) }
multi sub log(Cool $x)    { $x.Numeric.log }
multi sub log(Cool $x, Cool $base) { $x.Numeric.log($base.Numeric) }

proto sub log10($, $?) is pure {*}
multi sub log10(Numeric $x) { $x.log(10e0) }
multi sub log10(Cool    $x) { $x.Numeric.log(10e0) }

proto sub exp($, $?) is pure {*}
multi sub exp(Numeric $x) { $x.exp }
multi sub exp(Numeric $x, Numeric $base) { $x.exp($base) }

proto sub sin($) is pure {*}
multi sub sin(Numeric \x) { x.sin }
multi sub sin(Cool \x)    { x.Numeric.sin }

proto sub asin($) is pure {*}
multi sub asin(Numeric \x) { x.asin }
multi sub asin(Cool \x)    { x.Numeric.asin }

proto sub cos($) is pure {*}
multi sub cos(Numeric \x) { x.cos }
multi sub cos(Cool \x)    { x.Numeric.cos }

proto sub acos($) is pure {*}
multi sub acos(Numeric \x) { x.acos }
multi sub acos(Cool \x)    { x.Numeric.acos }

proto sub tan($) is pure {*}
multi sub tan(Numeric \x) { x.tan }
multi sub tan(Cool \x)    { x.Numeric.tan }

proto sub atan($) is pure {*}
multi sub atan(Numeric \x) { x.atan }
multi sub atan(Cool \x)    { x.Numeric.atan }

proto sub sec($) is pure {*}
multi sub sec(Numeric \x)  { x.sec }
multi sub sec(Cool \x)     { x.Numeric.sec }

proto sub asec($) is pure {*}
multi sub asec(Numeric \x)  { x.asec }
multi sub asec(Cool \x)     { x.Numeric.asec }

proto sub cosec($) is pure {*}
multi sub cosec(Numeric \x)  { x.cosec }
multi sub cosec(Cool \x)     { x.Numeric.cosec }

proto sub acosec(|) is pure {*}
multi sub acosec(Numeric \x)  { x.acosec }
multi sub acosec(Cool \x)     { x.Numeric.acosec }

proto sub cotan($) is pure {*}
multi sub cotan(Numeric \x)  { x.cotan }
multi sub cotan(Cool \x)     { x.Numeric.cotan }

proto sub acotan($) is pure {*}
multi sub acotan(Numeric \x)  { x.acotan }
multi sub acotan(Cool \x)     { x.Numeric.acotan }

proto sub sinh($) is pure {*}
multi sub sinh(Numeric \x) { x.sinh }
multi sub sinh(Cool \x)    { x.Numeric.sinh }

proto sub asinh($) is pure {*}
multi sub asinh(Numeric \x) { x.asinh }
multi sub asinh(Cool \x)    { x.Numeric.asinh }

proto sub cosh($) is pure {*}
multi sub cosh(Numeric \x) { x.cosh }
multi sub cosh(Cool \x)    { x.Numeric.cosh }

proto sub acosh($) is pure {*}
multi sub acosh(Numeric \x) { x.acosh }
multi sub acosh(Cool \x)    { x.Numeric.acosh }

proto sub tanh($) is pure {*}
multi sub tanh(Numeric \x) { x.tanh }
multi sub tanh(Cool \x)    { x.Numeric.tanh }

proto sub atanh($) is pure {*}
multi sub atanh(Numeric \x) { x.atanh }
multi sub atanh(Cool \x)    { x.Numeric.atanh }

proto sub sech($) is pure {*}
multi sub sech(Numeric \x) { x.sech }
multi sub sech(Cool \x)    { x.Numeric.sech }

proto sub asech($) is pure {*}
multi sub asech(Numeric \x) { x.asech }
multi sub asech(Cool \x)    { x.Numeric.asech }

proto sub cosech($) is pure {*}
multi sub cosech(Numeric \x) { x.cosech }
multi sub cosech(Cool \x)    { x.Numeric.cosech }

proto sub acosech($) is pure {*}
multi sub acosech(Numeric \x) { x.acosech }
multi sub acosech(Cool \x)    { x.Numeric.acosech }

proto sub cotanh($) is pure {*}
multi sub cotanh(Numeric \x) { x.cotanh }
multi sub cotanh(Cool \x)    { x.Numeric.cotanh }

proto sub acotanh($) is pure {*}
multi sub acotanh(Numeric \x) { x.acotanh }
multi sub acotanh(Cool \x)    { x.Numeric.acotanh }

proto sub sqrt($) is pure {*}
multi sub sqrt(Numeric \x) { x.sqrt }
multi sub sqrt(Cool \x)    { x.Numeric.sqrt }

proto sub roots($, $) is pure { * }
multi sub roots($x, Cool $n) { $x.Numeric.Complex.roots($n.Int) }
multi sub roots($x, Numeric $n) { $x.Numeric.Complex.roots($n.Int) }

proto sub floor($) is pure   { * }
multi sub floor($a)          { $a.Numeric.floor }
multi sub floor(Numeric $a)  { $a.floor }

proto sub ceiling($) is pure   { * }
multi sub ceiling($a)          { $a.Numeric.ceiling }
multi sub ceiling(Numeric $a)  { $a.ceiling }

proto sub round($, $?) is pure      { * }
multi sub round($a)                 { $a.Numeric.round }
multi sub round(Numeric $a)         { $a.round }
multi sub round(Numeric $a, $scale) { $a.round($scale) }

proto sub infix:<+>(Mu $?, Mu $?) is pure   { * }
multi sub infix:<+>($x = 0)      { $x.Numeric }
multi sub infix:<+>(\a, \b)    { a.Numeric + b.Numeric }

proto sub infix:<->(Mu $?, Mu $?) is pure   { * }
multi sub infix:<->($x = 0)      { $x.Numeric }
multi sub infix:<->(\a, \b)    { a.Numeric - b.Numeric }

proto sub infix:<*>(Mu $?, Mu $?) is pure   { * }
multi sub infix:<*>($x = 1)      { $x.Numeric }
multi sub infix:<*>(\a, \b)    { a.Numeric * b.Numeric }

proto sub infix:</>(Mu $?, Mu $?) { * }
multi sub infix:</>()            { fail "No zero-arg meaning for infix:</>" }
multi sub infix:</>($x)          { $x.Numeric }
multi sub infix:</>(\a, \b)    { a.Numeric / b.Numeric }

proto sub infix:<div>(Mu $?, Mu $?) is pure  { * }

proto sub infix:<%>(Mu $?, Mu $?) is pure   { * }
multi sub infix:<%>()            { fail "No zero-arg meaning for infix:<%>" }
multi sub infix:<%>($x)          { $x }
multi sub infix:<%>(\a, \b)    { a.Real % b.Real }

proto sub infix:<%%>(Mu $?, Mu $?) is pure  { * }
multi sub infix:<%%>()           { fail "No zero-arg meaning for infix:<%%>" }
multi sub infix:<%%>($)         { Bool::True }
multi sub infix:<%%>(\a, \b)   {
    fail X::Numeric::DivideByZero.new(using => 'infix:<%%>') unless b;
    a.Real % b.Real == 0;
}

proto sub infix:<lcm>(Mu $?, Mu $?) is pure  { * }
multi sub infix:<lcm>(Int $x = 1) { $x }
multi sub infix:<lcm>(\a, \b)   { a.Int lcm b.Int }

proto sub infix:<gcd>(Mu $?, Mu $?) is pure { * }
multi sub infix:<gcd>()          { fail 'No zero-arg meaning for infix:<gcd>' }
multi sub infix:<gcd>(Int $x)    { $x }
multi sub infix:<gcd>(\a, \b)  { a.Int gcd b.Int }

proto sub infix:<**>(Mu $?, Mu $?) is pure  { * }
multi sub infix:<**>($x = 1)     { $x.Numeric }
multi sub infix:<**>(\a, \b)   { a.Numeric ** b.Numeric }

## relational operators

proto sub infix:<=>(Mu $, Mu $?) is pure       { * }
multi sub infix:<=>(\a, \b)  { a.Real <=> b.Real }

proto sub infix:<==>(Mu $?, Mu $?) is pure  { * }
multi sub infix:<==>($?)        { Bool::True }
multi sub infix:<==>(\a, \b)   { a.Numeric == b.Numeric }

proto sub infix:<!=>(Mu $?, Mu $?) is pure  { * }
multi sub infix:<!=>($?)        { Bool::True }
multi sub infix:<!=>(Mu \a, Mu \b)   { not a == b }

proto sub infix:<(Mu $?, Mu $?) is pure   { * }
multi sub infix:<($?)         { Bool::True }
multi sub infix:<(\a, \b)    { a.Real < b.Real }

proto sub infix:<=(Mu $?, Mu $?) is pure  { * }
multi sub infix:<=($?)        { Bool::True }
multi sub infix:<=(\a, \b)   { a.Real <= b.Real }

proto sub infix:>(Mu $?, Mu $?) is pure   { * }
multi sub infix:>($?)         { Bool::True }
multi sub infix:>(\a, \b)    { a.Real > b.Real }

proto sub infix:>=(Mu $?, Mu $?) is pure  { * }
multi sub infix:>=($?)        { Bool::True }
multi sub infix:>=(\a, \b)   { a.Real >= b.Real }

## bitwise operators

proto sub infix:<+&>(Mu $?, Mu $?) is pure { * }
multi sub infix:<+&>()           { +^0 }
multi sub infix:<+&>($x)         { $x }
multi sub infix:<+&>($x, $y)     { $x.Numeric.Int +& $y.Numeric.Int }

proto sub infix:<+|>(Mu $?, Mu $?) is pure { * }
multi sub infix:<+|>()           { 0 }
multi sub infix:<+|>($x)         { $x }
multi sub infix:<+|>($x, $y)     { $x.Numeric.Int +| $y.Numeric.Int }

proto sub infix:<+^>(Mu $?, Mu $?) is pure { * }
multi sub infix:<+^>()           { 0 }
multi sub infix:<+^>($x)         { $x }
multi sub infix:<+^>($x, $y)     { $x.Numeric.Int +^ $y.Numeric.Int }

proto sub infix:+<(Mu $?, Mu $?) is pure { * }
multi sub infix:+<()           { fail "No zero-arg meaning for infix:+<"; }
multi sub infix:+<($x)         { $x }
multi sub infix:+<($x,$y)      { $x.Numeric.Int +< $y.Numeric.Int }

proto sub infix:+>(Mu $?, Mu $?) is pure { * }
multi sub infix:+>()           { fail "No zero-arg meaning for infix:+>"; }
multi sub infix:+>($x)         { $x }
multi sub infix:+>($x,$y)      { $x.Numeric.Int +> $y.Numeric.Int }

proto sub prefix:<+^>(Mu $) is pure { * }
multi sub prefix:<+^>($x)        { +^ $x.Numeric.Int }

# From 'src/core/Real.pm'

my class Complex { ... }

my role Real does Numeric {
    method Rat(Real:D: Real $epsilon = 1.0e-6) { self.Bridge.Rat($epsilon) }
    method abs()  { self < 0 ?? -self !! self }
    proto method sign(|) {*}
    multi method sign(Real:U:) { Mu }
    multi method sign(Real:D:) { self < 0 ?? -1 !! self == 0 ?? 0 !! 1 }
    method conj(Real:D:) { self }
    method sqrt() { self.Bridge.sqrt }
    method rand() { self.Bridge.rand }
    method sin()  { self.Bridge.sin }
    method asin() { self.Bridge.asin }
    method cos()  { self.Bridge.cos }
    method acos() { self.Bridge.acos }
    method tan()  { self.Bridge.tan }
    method atan() { self.Bridge.atan }
    proto method atan2(|) {*}
    multi method atan2(Real $x = 1e0) { self.Bridge.atan2($x.Bridge) }
    multi method atan2(Cool $x = 1e0) { self.Bridge.atan2($x.Numeric.Bridge) }
    method sec() { self.Bridge.sec }
    method asec() { self.Bridge.asec }
    method cosec() { self.Bridge.cosec }
    method acosec() { self.Bridge.acosec }
    method cotan()  { self.Bridge.cotan }
    method acotan() { self.Bridge.acotan }
    method sinh() { self.Bridge.sinh }
    method asinh() { self.Bridge.asinh }
    method cosh() { self.Bridge.cosh }
    method acosh() { self.Bridge.acosh }
    method tanh() { self.Bridge.tanh }
    method atanh() { self.Bridge.atanh }
    method sech() { self.Bridge.sech }
    method asech() { self.Bridge.asech }
    method cosech() { self.Bridge.cosech }
    method acosech() { self.Bridge.acosech }
    method cotanh() { self.Bridge.cotanh }
    method acotanh() { self.Bridge.acotanh }
    method floor() { self.Bridge.floor }
    method ceiling() { self.Bridge.ceiling }

    proto method round(|) { * }
    multi method round(Real:D:) {
        (self + 1/2).floor; # Rat NYI here, so no .5
    }
    multi method round(Real:D: Real() $scale) {
        (self / $scale + 1/2).floor * $scale;
    }

    method unpolar(Real $angle) {
        Complex.new(self * $angle.cos, self * $angle.sin);
    }
    method cis() {
        Complex.new(self.cos, self.sin);
    }
    method Complex() { Complex.new(self.Num, 0e0) }
    proto method log(|) {*}
    multi method log(Real:D: )           { self.Bridge.log               }
    multi method log(Real:D: Real $base) { self.Bridge.log($base.Bridge) }
    proto method exp(|) {*}
    multi method exp(Real:D: )           { self.Bridge.exp               }
    method truncate(Real:D:) {
        self == 0 ?? 0 !! self < 0  ?? self.ceiling !! self.floor
    }
    method isNaN { Bool::False }

    method polymod(Real:D: *@mods) {
        my $more = self;
        my $inf = @mods.elems == Inf;
        fail X::OutOfRange.new(what => 'invocant to polymod', got => $more, range => "0..*") if $more < 0;
        gather {
            for @mods -> $mod {
                last if $inf and not $more;
                fail X::Numeric::DivideByZero.new(using => 'polymod') unless $mod;
                take my $rem = $more % $mod;
                $more -= $rem;
                $more /= $mod;
            }
            take $more unless $inf;
        }
    }

    method base(Int:D $base, $digits?) {
        my $prec = $digits // 1e8.log($base.Num).Int;
        my Int $int_part = self.Int;
        my $frac = abs(self - $int_part);
        my @frac_digits;
        my @conversion := <0 1 2 3 4 5 6 7 8 9
                           A B C D E F G H I J
                           K L M N O P Q R S T
                           U V W X Y Z>;
        for ^$prec {
            last unless $digits // $frac;
            $frac = $frac * $base;
            push @frac_digits, $frac.Int;
            $frac = $frac - $frac.Int;
        }
        if 2 * $frac >= 1 {
            if @frac_digits {
                for @frac_digits-1 ... 0 -> $x {
                    last if ++@frac_digits[$x] < $base;
                    @frac_digits[$x] = 0;
                    $int_part++ if $x == 0
                }
            }
            else {
                $int_part++;
            }
        }
        my Str $r = $int_part.base($base);
        $r ~= '.' ~ @conversion[@frac_digits].join if @frac_digits;
        # if $int_part is 0, $int_part.base doesn't see the sign of self
        $int_part == 0 && self < 0 ?? '-' ~ $r !! $r;
    }

    method Real(Real:D:) { self }
    method Bridge(Real:D:) { self.Num }
    method Int(Real:D:) { self.Bridge.Int }
    method Num(Real:D:) { self.Bridge.Num }
    multi method Str(Real:D:) { self.Bridge.Str }

    method sleep() {
        DEPRECATED('sub form of sleep', '2015.02', '2016.01');
        sleep self;
    }
}

proto sub cis($) {*}
multi sub cis(Real $a) { $a.cis }

multi sub infix:<+>(Real \a, Real \b)   { a.Bridge + b.Bridge }

multi sub infix:<->(Real \a, Real \b)   { a.Bridge - b.Bridge }

multi sub infix:<*>(Real \a, Real \b)   { a.Bridge * b.Bridge }

multi sub infix:</>(Real \a, Real \b)   { a.Bridge / b.Bridge }

multi sub infix:<%>(Real \a, Real \b)   { a.Bridge % b.Bridge }

multi sub infix:<**>(Real \a, Real \b)  { a.Bridge ** b.Bridge }

multi sub infix:<=>(Real \a, Real \b) { a.Bridge <=> b.Bridge }

multi sub infix:<==>(Real \a, Real \b)  { a.Bridge == b.Bridge }

multi sub infix:<(Real \a, Real \b)   { a.Bridge < b.Bridge }

multi sub infix:<=(Real \a, Real \b)  { a.Bridge <= b.Bridge }

multi sub infix:>(Real \a, Real \b)   { a.Bridge > b.Bridge }

multi sub infix:>=(Real \a, Real \b)  { a.Bridge >= b.Bridge }

multi sub prefix:<->(Real:D \a)            { -a.Bridge }

proto sub infix:<mod>($, $) {*}
multi sub infix:<mod>(Real $a, Real $b) {
    $a - ($a div $b) * $b;
}

multi sub abs(Real \a) {
    a < 0 ?? -a !! a;
}

proto sub truncate($) {*}
multi sub truncate(Real:D $x) { $x.truncate }
multi sub truncate(Cool:D $x) { $x.Numeric.truncate }


proto sub atan2($, $?)    { * }
multi sub atan2(Real \a, Real \b = 1e0) { a.Bridge.atan2(b.Bridge) }
multi sub atan2(     \a,      \b = 1e0) { a.Numeric.atan2(b.Numeric) }

proto sub unpolar($, $) {*}
multi sub unpolar(Real $mag, Real $angle) { $mag.unpolar($angle) }

# From 'src/core/Int.pm'

my class Rat { ... }
my class X::Numeric::DivideByZero { ... }

my class Int { ... }
my subset UInt of Int where * >= 0;

my class Int does Real { # declared in BOOTSTRAP
    # class Int is Cool {
    #     has bigint $!value is box_target;

    multi method WHICH(Int:D:) {
        nqp::box_s(
            nqp::concat(
                nqp::concat(nqp::unbox_s(self.^name), '|'),
                nqp::tostr_I(self)
            ),
            ObjAt
        );
    }
    multi method perl(Int:D:) {
        self.Str;
    }
    multi method Bool(Int:D:) {
        nqp::p6bool(nqp::bool_I(self));
    }

    method Int() { self }

    multi method Str(Int:D:) {
        nqp::p6box_s(nqp::tostr_I(self));
    }

    method Num(Int:D:) {
        nqp::p6box_n(nqp::tonum_I(self));
    }

    method Rat(Int:D: $?) {
        Rat.new(self, 1);
    }
    method FatRat(Int:D: $?) {
        FatRat.new(self, 1);
    }

    method abs(Int:D:) {
        nqp::abs_I(self, Int)
    }

    method Bridge(Int:D:) {
        nqp::p6box_n(nqp::tonum_I(self));
    }

    method chr(Int:D:) {
        nqp::p6box_s(nqp::chr(nqp::unbox_i(self)));
    }

    method sqrt(Int:D:) { nqp::p6box_n(nqp::sqrt_n(nqp::tonum_I(self))) }

    method base(Int:D: Cool $base, $digits = 0) {
        fail("base must be between 2 and 36, got $base") unless 2 <= $base <= 36;
        my int $b = nqp::unbox_i($base.Int);
        nqp::p6box_s(nqp::base_I(self, $b)) ~ ($digits ?? '.' ~ '0' x $digits !! '');
    }

    # If self is Int, we assume mods are Ints also.  (div fails otherwise.)
    # If do-not-want, user should cast invocant to proper domain.
    method polymod(Int:D: *@mods) {
        my $more = self;
        my $inf = @mods.elems == Inf;
        fail X::OutOfRange.new(what => 'invocant to polymod', got => $more, range => "0..*") if $more < 0;
        gather {
            for @mods -> $mod {
                last if $inf and not $more;
                fail X::Numeric::DivideByZero.new(using => 'polymod') unless $mod;
                take $more mod $mod;
                $more div= $mod;
            }
            take $more unless $inf;
        }
    }

    method expmod(Int:D: Int:D \base, Int:D \mod) {
        nqp::expmod_I(self, nqp::decont(base), nqp::decont(mod), Int);
    }
    method is-prime(Int:D: Int:D $tries = 100) returns Bool:D {
        nqp::p6bool(nqp::isprime_I(self, nqp::unbox_i($tries)));
    }

    method floor(Int:D:) { self }
    method ceiling(Int:D:) { self }
    proto method round(|) {*}
    multi method round(Int:D:) { self }
    multi method round(Int:D: Real(Cool) $scale) { (self / $scale + 1/2).floor * $scale }

    method lsb(Int:D:) {
        return Nil if self == 0;
        my $lsb = 0;
        my $x = self.abs;
        while $x +& 0xff == 0 { $lsb += 8; $x +>= 8; }
        while $x +& 0x01 == 0 { $lsb++; $x +>= 1; }
        $lsb;
    }

    method msb(Int:D:) {
        return Nil if self == 0;
        return 0 if self == -1;
        my $msb = 0;
        my $x = self;
        $x = ($x + 1) * -2 if $x < 0;   # handle negative conversions
        while $x > 0xff   { $msb += 8; $x +>= 8; }
        if    $x > 0x0f   { $msb += 4; $x +>= 4; }
        if    $x +& 0x8   { $msb += 3; }
        elsif $x +& 0x4   { $msb += 2; }
        elsif $x +& 0x2   { $msb += 1; }
        $msb;
    }

    method narrow(Int:D:) { self }

    my constant $?BITS = do {
        my int $a = 0x1ffffffff;
        nqp::iseq_i($a,8589934591) ?? 64 !! 32;
    }

    method Range(Int:U:) {
        given self {
            when int  { $?BITS == 64 ??  int64.Range !!  int32.Range }
            when uint { $?BITS == 64 ?? uint64.Range !! uint32.Range }

            when int64  { Range.new(-9223372036854775808, 9223372036854775807) }
            when int32  { Range.new(         -2147483648, 2147483647         ) }
            when int16  { Range.new(              -32768, 32767              ) }
            when int8   { Range.new(                -128, 127                ) }
            when int4   { Range.new(                  -8, 7                  ) }
            when int2   { Range.new(                  -2, 1                  ) }
            when int1   { Range.new(                  -1, 0                  ) }

            when uint64 { Range.new( 0, 18446744073709551615 ) }
            when uint32 { Range.new( 0, 4294967295           ) }
            when uint16 { Range.new( 0, 65535                ) }
            when uint8  { Range.new( 0, 255                  ) }
            when uint4  { Range.new( 0, 15                   ) }
            when uint2  { Range.new( 0, 3                    ) }
            when uint1  { Range.new( 0, 1                    ) }

            when Int    {  # smartmatch matches both UInt and Int
                .^name eq 'UInt'
                  ?? Range.new(    0, Inf )
                  !! Range.new( -Inf, Inf )
                }

            default {
                fail "Unknown integer type: {self.^name}";
            }
        }
    }
}

multi sub prefix:<++>(Int:D $a is rw) {
    $a = nqp::add_I(nqp::decont($a), 1, Int);
}
multi sub prefix:<++>(int $a is rw) {
    $a = nqp::add_i($a, 1);
}
multi sub prefix:<-->(Int:D $a is rw) {
    $a = nqp::sub_I(nqp::decont($a), 1, Int);
}
multi sub prefix:<-->(int $a is rw) {
    $a = nqp::sub_i($a, 1);
}
multi sub postfix:<++>(Int:D $a is rw) {
    my \b = nqp::decont($a);
    $a = nqp::add_I(b, 1, Int);
    b
}
multi sub postfix:<++>(int $a is rw) {
    my int $b = $a;
    $a = nqp::add_i($b, 1);
    $b
}
multi sub postfix:<-->(Int:D $a is rw) {
    my \b = nqp::decont($a);
    $a = nqp::sub_I(b, 1, Int);
    b
}
multi sub postfix:<-->(int $a is rw) {
    my int $b = $a;
    $a = nqp::sub_i($b, 1);
    $b
}

multi sub prefix:<->(Int:D \a) returns Int {
    nqp::neg_I(nqp::decont(a), Int);
}
multi sub prefix:<->(int $a) returns int {
    nqp::neg_i($a)
}

multi sub abs(Int:D \a) returns Int:D {
    nqp::abs_I(nqp::decont(a), Int);
}
multi sub abs(int $a) returns int {
    nqp::abs_i($a)
}

multi sub infix:<+>(Int:D \a, Int:D \b) returns Int:D {
    nqp::add_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<+>(int $a, int $b) returns int {
    nqp::add_i($a, $b)
}

multi sub infix:<->(Int:D \a, Int:D \b) returns Int:D {
    nqp::sub_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<->(int $a, int $b) returns int {
    nqp::sub_i($a, $b)
}

multi sub infix:<*>(Int:D \a, Int:D \b) returns Int {
    nqp::mul_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<*>(int $a, int $b) returns int {
    nqp::mul_i($a, $b)
}

multi sub infix:<div>(Int:D \a, Int:D \b) {
    fail X::Numeric::DivideByZero.new unless b;
    nqp::div_I(nqp::decont(a), nqp::decont(b), Int)
}
multi sub infix:<div>(int $a, int $b) returns int {
    # relies on opcode or hardware to detect division by 0
    nqp::div_i($a, $b)
}

multi sub infix:<%>(Int:D \a, Int:D \b) returns Int {
    fail X::Numeric::DivideByZero.new(using => 'infix:<%>') unless b;
    nqp::mod_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<%>(int $a, int $b) returns int {
    # relies on opcode or hardware to detect division by 0
    nqp::mod_i($a, $b)
}

multi sub infix:<**>(Int:D \a, Int:D \b) {
    nqp::pow_I(nqp::decont(a), nqp::decont(b), Num, Int);
}

multi sub infix:<lcm>(Int:D \a, Int:D \b) returns Int {
    nqp::lcm_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<lcm>(int $a, int $b) returns int {
    nqp::lcm_i($a, $b)
}

multi sub infix:<gcd>(Int:D \a, Int:D \b) returns Int {
    nqp::gcd_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<gcd>(int $a, int $b) returns int {
    nqp::gcd_i($a, $b)
}

multi sub infix:<===>(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::iseq_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<===>(int $a, int $b) {
    # hey, the optimizer is smart enough to figure that one out for us, no?
    $a == $b
}

multi sub infix:<==>(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::iseq_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<==>(int $a, int $b) {
    nqp::p6bool(nqp::iseq_i($a, $b))
}

multi sub infix:<!=>(int $a, int $b) {
    nqp::p6bool(nqp::isne_i($a, $b))
}

multi sub infix:<(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::islt_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<(int $a, int $b) {
    nqp::p6bool(nqp::islt_i($a, $b))
}

multi sub infix:<=(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::isle_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<=(int $a, int $b) {
    nqp::p6bool(nqp::isle_i($a, $b))
}

multi sub infix:>(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::isgt_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:>(int $a, int $b) {
    nqp::p6bool(nqp::isgt_i($a, $b))
}

multi sub infix:>=(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::isge_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:>=(int $a, int $b) {
    nqp::p6bool(nqp::isge_i($a, $b))
}

multi sub infix:<+|>(Int:D \a, Int:D \b) {
    nqp::bitor_I(nqp::decont(a), nqp::decont(b), Int)
}
multi sub infix:<+|>(int $a, int $b) {
    nqp::bitor_i($a, $b)
}

multi sub infix:<+&>(Int:D \a, Int:D \b) {
    nqp::bitand_I(nqp::decont(a), nqp::decont(b), Int)
}
multi sub infix:<+&>(int $a, int $b) {
    nqp::bitand_i($a, $b)
}

multi sub infix:<+^>(Int:D \a, Int:D \b) {
    nqp::bitxor_I(nqp::decont(a), nqp::decont(b), Int)
}
multi sub infix:<+^>(int $a, int $b) {
    nqp::bitxor_i($a, $b);
}

multi sub infix:+<(Int:D \a, Int:D \b) returns Int:D {
    nqp::bitshiftl_I(nqp::decont(a), nqp::unbox_i(b), Int)
}
multi sub infix:+<(int $a, int $b) {
    nqp::bitshiftl_i($a, $b);
}

multi sub infix:+>(Int:D \a, Int:D \b) returns Int:D {
    nqp::bitshiftr_I(nqp::decont(a), nqp::unbox_i(b), Int)
}
multi sub infix:+>(int $a, int $b) {
    nqp::bitshiftr_i($a, $b)
}

multi sub prefix:<+^>(Int:D \a) {
    nqp::bitneg_I(nqp::decont(a), Int);
}
multi sub prefix:<+^>(int $a) {
    nqp::bitneg_i($a);
}

proto sub chr($) is pure  {*}
multi sub chr(Int:D  \x) returns Str:D { x.chr     }
multi sub chr(Cool \x) returns Str:D { x.Int.chr }
multi sub chr(int $x) returns str {
    nqp::chr($x);
}

proto sub is-prime($, $?) is pure  {*}
multi sub is-prime(Int:D \i, Int:D $tries = 100) {
    nqp::p6bool(nqp::isprime_I(nqp::decont(i), nqp::unbox_i($tries)));
}
multi sub is-prime(\i, $tries = 100) {
    nqp::p6bool(nqp::isprime_I(nqp::decont(i.Int), nqp::unbox_i($tries.Int)));
}

proto sub expmod($, $, $) is pure  {*}
multi sub expmod(Int:D \base, Int:D \exp, Int:D \mod) {
    nqp::expmod_I(nqp::decont(base), nqp::decont(exp), nqp::decont(mod), Int);
}
multi sub expmod(\base, \exp, \mod) {
    nqp::expmod_I(nqp::decont(base.Int), nqp::decont(exp.Int), nqp::decont(mod.Int), Int);
}

proto sub lsb($) {*}
multi sub lsb(Int:D \i) { i.lsb }

proto sub msb($) {*}
multi sub msb(Int:D \i) { i.msb }

# From 'src/core/Order.pm'

## Order enumeration, for cmp and <=>
my enum Order (:Less(-1), :Same(0), :More(1));

sub ORDER(int $i) {
    $i == 0 ?? Same !! $i <  0 ?? Less !! More
}

proto sub infix:<cmp>(Mu $, Mu $) { * }
multi sub infix:<cmp>(\a, \b) {
    return Order::Less if a === -Inf || b === Inf;
    return Order::More if a ===  Inf || b === -Inf;
    a.Stringy cmp b.Stringy
}
multi sub infix:<cmp>(Real \a, Real \b) { a.Bridge cmp b.Bridge }
multi sub infix:<cmp>(Int:D \a, Int:D \b) {
    ORDER(nqp::cmp_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<cmp>(int $a, int $b) {
    ORDER(nqp::cmp_i($a, $b))
}

multi sub infix:<=>(Int:D \a, Int:D \b) {
    ORDER(nqp::cmp_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<=>(int $a, int $b) {
    ORDER(nqp::cmp_i($a, $b))
}

# From 'src/core/UInt64.pm'

my Int $UINT64_UPPER = nqp::pow_I(2, 64, Num, Int);
subset UInt64 of Int where { 0 <= $_ < $UINT64_UPPER }

# From 'src/core/Num.pm'

my class X::Numeric::DivideByZero { ... };

my class Num does Real { # declared in BOOTSTRAP
    # class Num is Cool {
    #     has num $!value is box_target;

    multi method WHICH(Num:D:) {
        nqp::box_s(
            nqp::concat(
                nqp::concat(nqp::unbox_s(self.^name), '|'),
                nqp::unbox_n(self)
            ),
            ObjAt
        );
    }
    method Num() { self }
    method Bridge(Num:D:) { self }
    method Range(Num:U:) { Range.new(-Inf,Inf) }

    method Int(Num:D:) {
        nqp::isnanorinf(nqp::unbox_n(self)) ??
            fail("Cannot coerce Inf or NaN to an Int") !!
            nqp::fromnum_I(nqp::unbox_n(self), Int);
    }

    multi method new() { nqp::box_n(0e0, self) }
    multi method new($n) { nqp::box_n($n.Num, self) }

    multi method perl(Num:D:) {
        my $res = self.Str;
        if nqp::isnanorinf(nqp::unbox_n(self))
           || $res.index('e').defined
           || $res.index('E').defined {
            $res;
        } else {
            $res ~ 'e0';
        }
    }

    method Rat(Num:D: Real $epsilon = 1.0e-6, :$fat) {
        if nqp::isnanorinf(nqp::unbox_n(self)) {
            return self;
        }

        (self == Inf || self == -Inf) && fail("Cannot coerce Inf to a Rat");

        my Num $num = self;
        my Int $signum = $num < 0 ?? -1 !! 1;
        $num = -$num if $signum == -1;

        # Find convergents of the continued fraction.

        my Int $q = nqp::fromnum_I($num, Int);
        my num $r = $num - floor($num);
        my Int $a = 1;
        my Int $b = $q;
        my Int $c = 0;
        my Int $d = 1;

        while $r != 0e0 && abs($num - ($b / $d)) > $epsilon {
            my num $modf_arg = 1e0 / $r;
            $q = nqp::fromnum_I($modf_arg, Int);
            $r = $modf_arg - floor($modf_arg);

            my $orig_b = $b;
            $b = $q * $b + $a;
            $a = $orig_b;

            my $orig_d = $d;
            $d = $q * $d + $c;
            $c = $orig_d;
        }

        # Note that this result has less error than any Rational with a
        # smaller denominator but it is not (necessarily) the Rational
        # with the smallest denominator that has less than $epsilon error.
        # However, to find that Rational would take more processing.
        $fat ?? FatRat.new($signum * $b, $d) !! ($signum * $b) / $d;
    }
    method FatRat(Num:D: Real $epsilon = 1.0e-6) {
        self.Rat($epsilon, :fat);
    }

    multi method atan2(Num:D: Num:D $x = 1e0) {
        nqp::p6box_n(nqp::atan2_n(nqp::unbox_n(self), nqp::unbox_n($x)));
    }

    multi method Str(Num:D:) {
        nqp::p6box_s(nqp::unbox_n(self));
    }

    method succ(Num:D:) { self + 1e0 }

    method pred(Num:D:) { self - 1e0 }

    method isNaN(Num:D: ) {
        self != self;
    }

    method abs(Num:D: ) {
        nqp::p6box_n(nqp::abs_n(nqp::unbox_n(self)));
    }

    multi method exp(Num:D: ) {
        nqp::p6box_n(nqp::exp_n(nqp::unbox_n(self)));
    }

    proto method log(|) {*}
    multi method log(Num:D: ) {
        nqp::p6box_n(nqp::log_n(nqp::unbox_n(self)));
    }
    multi method log(Num:D: Num \base) {
        self.log() / base.log();
    }

    proto method sqrt(|) {*}
    multi method sqrt(Num:D: ) {
        nqp::p6box_n(nqp::sqrt_n(nqp::unbox_n(self)));
    }

    method rand(Num:D: ) {
        nqp::p6box_n(nqp::rand_n(nqp::unbox_n(self)));
    }

    method ceiling(Num:D: ) {
        nqp::isnanorinf(nqp::unbox_n(self))
            ?? self
            !! nqp::fromnum_I(nqp::ceil_n(nqp::unbox_n(self)), Int);
    }
    method floor(Num:D: ) {
        nqp::isnanorinf(nqp::unbox_n(self))
            ?? self
            !! nqp::fromnum_I(nqp::floor_n(nqp::unbox_n(self)), Int);
    }

    proto method sin(|) {*}
    multi method sin(Num:D: ) {
        nqp::p6box_n(nqp::sin_n(nqp::unbox_n(self)));
    }
    proto method asin(|) {*}
    multi method asin(Num:D: ) {
        nqp::p6box_n(nqp::asin_n(nqp::unbox_n(self)));
    }
    proto method cos(|) {*}
    multi method cos(Num:D: ) {
        nqp::p6box_n(nqp::cos_n(nqp::unbox_n(self)));
    }
    proto method acos(|) {*}
    multi method acos(Num:D: ) {
        nqp::p6box_n(nqp::acos_n(nqp::unbox_n(self)));
    }
    proto method tan(|) {*}
    multi method tan(Num:D: ) {
        nqp::p6box_n(nqp::tan_n(nqp::unbox_n(self)));
    }
    proto method atan(|) {*}
    multi method atan(Num:D: ) {
        nqp::p6box_n(nqp::atan_n(nqp::unbox_n(self)));
    }
    proto method sec(|) {*}
    multi method sec(Num:D: ) {
        nqp::p6box_n(nqp::sec_n(nqp::unbox_n(self)));
    }
    proto method asec(|) {*}
    multi method asec(Num:D: ) {
        nqp::p6box_n(nqp::asec_n(nqp::unbox_n(self)));
    }
    method cosec(Num:D:) {
        nqp::p6box_n(nqp::div_n(1e0, nqp::sin_n(nqp::unbox_n(self))));
    }
    method acosec(Num:D:) {
        nqp::p6box_n(nqp::asin_n(nqp::div_n(1e0, nqp::unbox_n(self))));
    }
    method cotan(Num:D:) {
        nqp::p6box_n(nqp::div_n(1e0, nqp::tan_n(nqp::unbox_n(self))));
    }
    method acotan(Num:D:) {
        nqp::p6box_n(nqp::atan_n(nqp::div_n(1e0, nqp::unbox_n(self))));
    }
    proto method sinh(|) {*}
    multi method sinh(Num:D: ) {
        nqp::p6box_n(nqp::sinh_n(nqp::unbox_n(self)));
    }
    proto method asinh(|) {*}
    multi method asinh(Num:D: ) {
        (self + (self * self + 1e0).sqrt).log;
    }
    proto method cosh(|) {*}
    multi method cosh(Num:D: ) {
        nqp::p6box_n(nqp::cosh_n(nqp::unbox_n(self)));
    }
    proto method acosh(|) {*}
    multi method acosh(Num:D: ) {
        (self + (self * self - 1e0).sqrt).log;
    }
    proto method tanh(|) {*}
    multi method tanh(Num:D: ) {
        nqp::p6box_n(nqp::tanh_n(nqp::unbox_n(self)));
    }
    proto method atanh(|) {*}
    multi method atanh(Num:D: ) {
        ((1e0 + self) / (1e0 - self)).log / 2e0;
    }
    proto method sech(|) {*}
    multi method sech(Num:D: ) {
        nqp::p6box_n(nqp::sech_n(nqp::unbox_n(self)));
    }
    proto method asech(|) {*}
    multi method asech(Num:D: ) {
        (1e0 / self).acosh;
    }
    proto method cosech(|) {*}
    multi method cosech(Num:D: ) {
        nqp::p6box_n(nqp::div_n(1e0, nqp::sinh_n(nqp::unbox_n(self))));
    }
    proto method acosech(|) {*}
    multi method acosech(Num:D: ) {
        (1e0 / self).asinh;
    }
    proto method cotanh(|) {*}
    multi method cotanh(Num:D: ) {
        nqp::p6box_n(nqp::div_n(1e0, nqp::tanh_n(nqp::unbox_n(self))));
    }
    proto method acotanh(|) {*}
    multi method acotanh(Num:D: ) {
        (1e0 / self).atanh;
    }

    method narrow(Num:D:) {
        my $i := self.Int;
        $i.defined && $i.Num == self
            ?? $i
            !! self
    }
}

my constant pi = 3.14159_26535_89793_238e0;
my constant e  = 2.71828_18284_59045_235e0;

my constant  := pi;

multi sub prefix:<++>(Num:D $a is rw) {
    $a = nqp::p6box_n(nqp::add_n(nqp::unbox_n($a), 1e0))
}
multi sub prefix:<++>(Num:U $a is rw) {
    $a = 1e0;
}
multi sub prefix:<++>(num $a is rw) {
    $a = nqp::add_n($a, 1e0)
}
multi sub prefix:<-->(Num:D $a is rw) {
    $a = nqp::p6box_n(nqp::sub_n(nqp::unbox_n($a), 1e0))
}
multi sub prefix:<-->(Num:U $a is rw) {
    $a = -1e0;
}
multi sub prefix:<-->(num $a is rw) {
    $a = nqp::sub_n($a, 1e0)
}
multi sub postfix:<++>(Num:D $a is rw) {
    my $b = $a;
    $a = nqp::p6box_n(nqp::add_n(nqp::unbox_n($a), 1e0));
    $b
}
multi sub postfix:<++>(Num:U $a is rw) {
    $a = 1e0;
    0
}
multi sub postfix:<++>(num $a is rw) {
    my num $b = $a;
    $a = nqp::add_n($a, 1e0);
    $b
}
multi sub postfix:<-->(Num:D $a is rw) {
    my $b = $a;
    $a = nqp::p6box_n(nqp::sub_n(nqp::unbox_n($a), 1e0));
    $b
}
multi sub postfix:<-->(Num:U $a is rw) {
    $a = -1e0;
    0e0
}
multi sub postfix:<-->(num $a is rw) {
    my num $b = $a;
    $a = nqp::sub_n($a, 1e0);
    $b
}

multi sub prefix:<->(Num:D \a) {
    nqp::p6box_n(nqp::neg_n(nqp::unbox_n(a)))
}
multi sub prefix:<->(num $a) {
    nqp::neg_n($a);
}

multi sub abs(Num:D \a) {
    nqp::p6box_n(nqp::abs_n(nqp::unbox_n(a)))
}
multi sub abs(num $a) {
    nqp::abs_n($a)
}

multi sub infix:<+>(Num:D \a, Num:D \b) {
    nqp::p6box_n(nqp::add_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<+>(num $a, num $b) {
    nqp::add_n($a, $b)
}

multi sub infix:<->(Num:D \a, Num:D \b) {
    nqp::p6box_n(nqp::sub_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<->(num $a, num $b) {
    nqp::sub_n($a, $b)
}

multi sub infix:<*>(Num:D \a, Num:D \b) {
    nqp::p6box_n(nqp::mul_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<*>(num $a, num $b) {
    nqp::mul_n($a, $b)
}

multi sub infix:</>(Num:D \a, Num:D \b) {
    fail X::Numeric::DivideByZero.new unless b;
    nqp::p6box_n(nqp::div_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:</>(num $a, num $b) {
    fail X::Numeric::DivideByZero.new unless $b;
    nqp::div_n($a, $b)
}

multi sub infix:<%>(Num:D \a, Num:D \b) {
    fail X::Numeric::DivideByZero.new(:using<%>) unless b;
    nqp::p6box_n(nqp::mod_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<%>(num $a, num $b) {
    fail X::Numeric::DivideByZero.new(:using<%>) unless $b;
    nqp::mod_n($a, $b)
}

multi sub infix:<**>(Num:D \a, Num:D \b) {
    nqp::p6box_n(nqp::pow_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<**>(num $a, num $b) {
    nqp::pow_n($a, $b)
}


multi sub infix:<cmp>(Num:D \a, Num:D \b) {
    ORDER(nqp::cmp_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<cmp>(num $a, num $b) {
    ORDER(nqp::cmp_n($a, $b))
}

multi sub infix:<=>(Num:D \a, Num:D \b) {
    ORDER(nqp::cmp_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<=>(num $a, num $b) {
    ORDER(nqp::cmp_n($a, $b))
}

multi sub infix:<===>(Num:D \a, Num:D \b) {
    nqp::p6bool(nqp::iseq_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<===>(NaN, NaN) {
    True;
}
multi sub infix:<===>(num $a, num $b) returns Bool:D {
    nqp::p6bool(nqp::iseq_n($a, $b))
}

multi sub infix:<==>(Num:D \a, Num:D \b) returns Bool:D  {
    nqp::p6bool(nqp::iseq_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<==>(num $a, num $b) returns Bool:D  {
    nqp::p6bool(nqp::iseq_n($a, $b))
}

multi sub infix:<!=>(num $a, num $b) returns Bool:D {
    nqp::p6bool(nqp::isne_n($a, $b))
}

multi sub infix:<(Num:D \a, Num:D \b) returns Bool:D {
    nqp::p6bool(nqp::islt_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<(num $a, num $b) returns Bool:D {
    nqp::p6bool(nqp::islt_n($a, $b))
}

multi sub infix:<=(Num:D \a, Num:D \b) returns Bool:D {
    nqp::p6bool(nqp::isle_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<=(num $a, num $b) returns Bool:D {
    nqp::p6bool(nqp::isle_n($a, $b))
}

multi sub infix:>(Num:D \a, Num:D \b) returns Bool:D {
    nqp::p6bool(nqp::isgt_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:>(num $a, num $b) returns Bool:D {
    nqp::p6bool(nqp::isgt_n($a, $b))
}

multi sub infix:>=(Num:D \a, Num:D \b) returns Bool:D {
    nqp::p6bool(nqp::isge_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:>=(num $a, num $b) returns Bool:D {
    nqp::p6bool(nqp::isge_n($a, $b))
}

sub rand() returns Num:D {
    nqp::p6box_n(nqp::rand_n(1e0));
}

sub srand(Int $seed) returns Int:D {
    nqp::p6box_i(nqp::srand($seed))
}

multi sub atan2(Num:D $a, Num:D $b = 1e0) {
    nqp::p6box_n(nqp::atan2_n(nqp::unbox_n($a), nqp::unbox_n($b)));
}

multi sub cosec(Num:D \x) {
    nqp::p6box_n(nqp::div_n(1e0, nqp::sin_n(nqp::unbox_n(x))));
}
multi sub acosec(Num:D \x) {
    nqp::p6box_n(nqp::asin_n(nqp::div_n(1e0, nqp::unbox_n(x))));
}

multi sub log(num $x) {
    nqp::log_n($x);
}

multi sub sin(num $x) {
    nqp::sin_n($x);
}
multi sub asin(num $x) {
    nqp::asin_n($x);
}
multi sub cos(num $x) {
    nqp::cos_n($x);
}
multi sub acos(num $x) {
    nqp::acos_n($x);
}
multi sub tan(num $x) {
    nqp::tan_n($x);
}
multi sub atan(num $x) {
    nqp::atan_n($x);
}
multi sub sec(num $x) {
    nqp::sec_n($x);
}
multi sub asec(num $x) {
    nqp::asec_n($x);
}

multi sub cotan(num $x) {
    nqp::div_n(1e0, nqp::tan_n($x));
}
multi sub acotan(num $x) {
    nqp::div_n(1e0, nqp::atan_n($x));
}
multi sub sinh(num $x) {
    nqp::sinh_n($x);
}
multi sub asinh(num $x) {
    log($x + ($x * $x + 1e0));
}

multi sub cosh(num $x) {
    nqp::cosh_n($x);
}
multi sub acosh(num $x) {
    log($x + ($x * $x - 1e0))
}
multi sub tanh(num $x) {
    nqp::tanh_n($x);
}
multi sub atanh(num $x) {
    log((1e0 + $x) / (1e0 - $x)) / 2e0;
}
multi sub sech(num $x) {
    nqp::sech_n($x);
}
multi sub asech(num $x) {
    acosh(1e0 / $x);
}
multi sub cosech(num $x) {
    1e0 / sinh($x)
}
multi sub acosech(num $x) {
    asinh(1e0 / $x);
}
multi sub cotanh(num $x) {
    1e0 / tanh($x);
}
multi sub acotanh(num $x) {
    atanh(1e0 / $x)
}

multi sub floor(num $a) returns num {
    nqp::floor_n($a)
}
multi sub ceiling(num $a) returns num {
    nqp::ceil_n($a)
}
multi sub sqrt(num $a) returns num {
    nqp::sqrt_n($a)
}

# From 'src/core/Buf.pm'

my class X::Buf::AsStr          { ... }
my class X::Buf::Pack           { ... }
my class X::Buf::Pack::NonASCII { ... }

my role Blob[::T = uint8] does Positional[T] does Stringy is repr('VMArray') is array_type(T) {
    proto method new(|) { * }
    multi method new() {
        nqp::create(self)
    }
    multi method new(@values) {
        my $buf := nqp::create(self);
        my int $n = @values.elems;
        my int $i;
        nqp::setelems($buf, $n);
        while $i < $n {
            nqp::bindpos_i($buf, $i, @values.AT-POS($i));
            $i = $i + 1;
        }
        $buf
    }
    multi method new(*@values) {
        self.new(@values)
    }

    multi method EXISTS-POS(Blob:D: int \pos) {
        nqp::p6bool(
          nqp::islt_i(pos,nqp::elems(self)) && nqp::isge_i(pos,0)
        );
    }
    multi method EXISTS-POS(Blob:D: Int:D \pos) {
        pos < nqp::elems(self) && pos >= 0;
    }

    multi method AT-POS(Blob:D: int \pos) {
        fail X::OutOfRange.new(
          :what<Index>,
          :got(pos),
          :range("0..{nqp::elems(self)-1}")
        ) if nqp::isge_i(pos,nqp::elems(self)) || nqp::islt_i(pos,0);
        nqp::atpos_i(self, pos);
    }
    multi method AT-POS(Blob:D: Int:D \pos) {
        my int $pos = nqp::unbox_i(pos);
        fail X::OutOfRange.new(
          :what<Index>,
          :got(pos),
          :range("0..{nqp::elems(self)-1}")
        ) if nqp::isge_i($pos,nqp::elems(self)) || nqp::islt_i($pos,0);
        nqp::atpos_i(self,$pos);
    }

    multi method Bool(Blob:D:) {
        nqp::p6bool(nqp::elems(self));
    }

    method elems(Blob:D:) {
        nqp::p6box_i(nqp::elems(self));
    }
    method bytes(Blob:D:) {
        ceiling(self.elems * ::T.^nativesize / 8);
    }
    method chars(Blob:D:)       { X::Buf::AsStr.new(method => 'chars').throw }
    multi method Str(Blob:D:)   { X::Buf::AsStr.new(method => 'Str'  ).throw }
    multi method Stringy(Blob:D:) { X::Buf::AsStr.new(method => 'Stringy' ).throw }

    method Numeric(Blob:D:) { self.elems }
    method Int(Blob:D:)     { self.elems }

    method decode(Blob:D: $encoding = 'utf-8') {
        nqp::p6box_s(nqp::decode(self, NORMALIZE_ENCODING($encoding)))
    }

    method list(Blob:D:) {
        my @l;
        my int $n = nqp::elems(self);
        my int $i = 0;
        while $i < $n {
            @l[$i] = nqp::atpos_i(self, $i);
            $i = $i + 1;
        }
        @l;
    }

    multi method gist(Blob:D:) {
        self.^name ~ ':0x<' ~ self.list.fmt('%02x', ' ') ~ '>'
    }
    multi method perl(Blob:D:) {
        self.^name ~ '.new(' ~ self.list.join(', ') ~ ')';
    }

    method subbuf(Blob:D: $from = 0, $len is copy = self.elems - $from) {

        if ($len < 0) {
            X::OutOfRange.new(
                what => "Len element to subbuf",
                got  => $len,
                range => (0..self.elems)).fail;
        }


        my $ret := nqp::create(self);

        my int $ifrom = nqp::unbox_i(
            nqp::istype($from, Callable)
                ?? $from(nqp::p6box_i(self.elems))
                !! $from.Int);

        if ($ifrom < 0) {
            X::OutOfRange.new(
                what    => 'From argument to subbuf',
                got     => $from,
                range   => (0..self.elems),
                comment => "use *{$ifrom} if you want to index relative to the end"
            ).fail;
        }

        if ($ifrom > self.elems) {
            X::OutOfRange.new(
                what => 'From argument to subbuf',
                got  => $from,
                range => (0..self.elems),
            ).fail;
        }

        return $ret
            if $ifrom == self.elems;

        $len = self.elems - $ifrom
            if $ifrom + $len > self.elems;

        my int $llen = $len.Int;
        nqp::setelems($ret, $llen);
        my int $i = 0;
        while $i < $llen {
            nqp::bindpos_i($ret, $i, nqp::atpos_i(self, $ifrom));
            $i = $i + 1;
            $ifrom = $ifrom + 1;
        }
        $ret
    }

    method unpack(Blob:D: $template) {
        my @bytes = self.list;
        my @fields;
        for $template.comb(/<[a..zA..Z]>[\d+|'*']?/) -> $unit {
            my $directive = substr($unit,0,1);
            my $amount    = substr($unit,1);
            my $pa = $amount eq ''  ?? 1            !!
                     $amount eq '*' ?? @bytes.elems !! +$amount;

            given $directive {
                when 'a' | 'A' | 'Z' {
                    @fields.push: @bytes.splice(0, $pa).map(&chr).join;
                }
                when 'H' {
                    my str $hexstring = '';
                    for ^$pa {
                        my $byte = shift @bytes;
                        $hexstring ~= ($byte +> 4).fmt('%x')
                                    ~ ($byte % 16).fmt('%x');
                    }
                    @fields.push($hexstring);
                }
                when 'x' {
                    splice @bytes, 0, $pa;
                }
                when 'C' {
                    @fields.push: @bytes.splice(0, $pa);
                }
                when 'S' | 'v' {
                    for ^$pa {
                        @fields.push: shift(@bytes)
                                    + (shift(@bytes) +< 0x08);
                    }
                }
                when 'L' | 'V' {
                    for ^$pa {
                        @fields.push: shift(@bytes)
                                    + (shift(@bytes) +< 0x08)
                                    + (shift(@bytes) +< 0x10)
                                    + (shift(@bytes) +< 0x18);
                    }
                }
                when 'n' {
                    for ^$pa {
                        @fields.push: (shift(@bytes) +< 0x08)
                                    + shift(@bytes);
                    }
                }
                when 'N' {
                    for ^$pa {
                        @fields.push: (shift(@bytes) +< 0x18)
                                    + (shift(@bytes) +< 0x10)
                                    + (shift(@bytes) +< 0x08)
                                    + shift(@bytes);
                    }
                }
                X::Buf::Pack.new(:$directive).throw;
            }
        }

        return |@fields;
    }

    # XXX: the pack.t spectest file seems to require this method
    # not sure if it should be changed to list there...
    method contents(Blob:D:) { self.list }

    method encoding() { Any }
}

constant blob8 = Blob[uint8];
constant blob16 = Blob[uint16];
constant blob32 = Blob[uint32];
constant blob64 = Blob[uint64];

my class utf8 does Blob[uint8] is repr('VMArray') {
    method decode(utf8:D: $encoding = 'utf-8') {
        my $enc = NORMALIZE_ENCODING($encoding);
        die "Can not decode a utf-8 buffer as if it were $encoding"
            unless $enc eq 'utf8';
        nqp::p6box_s(nqp::decode(self, 'utf8'))
    }
    method encoding() { 'utf-8' }
    multi method Str(utf8:D:) { self.decode }
    multi method Stringy(utf8:D:) { self.decode }
}

my class utf16 does Blob[uint16] is repr('VMArray') {
    method decode(utf16:D: $encoding = 'utf-16') {
        my $enc = NORMALIZE_ENCODING($encoding);
        die "Can not decode a utf-16 buffer as if it were $encoding"
            unless $enc eq 'utf16';
        nqp::p6box_s(nqp::decode(self, 'utf16'))
    }
    method encoding() { 'utf-16' }
    multi method Str(utf16:D:) { self.decode }
    multi method Stringy(utf16:D:) { self.decode }
}

my class utf32 does Blob[uint32] is repr('VMArray') {
    method decode(utf32:D: $encoding = 'utf-32') {
        my $enc = NORMALIZE_ENCODING($encoding);
        die "Can not decode a utf-32 buffer as if it were $encoding"
            unless $enc eq 'utf32';
        nqp::p6box_s(nqp::decode(self, 'utf32'))
    }
    method encoding() { 'utf-32' }
    multi method Str(utf32:D:) { self.decode }
    multi method Stringy(utf32:D:) { self.decode }
}

my role Buf[::T = uint8] does Blob[T] is repr('VMArray') is array_type(T) {
    multi method AT-POS(Buf:D: int \pos) {
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i(pos,0);
        nqp::atposref_i(self, pos);
    }
    multi method AT-POS(Buf:D: Int:D \pos) {
        my int $pos = nqp::unbox_i(pos);
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i($pos,0);
        nqp::atposref_i(self,$pos);
    }

    multi method ASSIGN-POS(Buf:D: int \pos, Mu \assignee) {
        X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>).throw
          if nqp::islt_i(pos,0);
        nqp::bindpos_i(self,\pos,assignee)
    }
    multi method ASSIGN-POS(Buf:D: Int:D \pos, Mu \assignee) is rw {
        my int $pos = nqp::unbox_i(pos);
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i($pos,0);
        nqp::bindpos_i(self,$pos,assignee)
    }
}

constant buf8 = Buf[uint8];
constant buf16 = Buf[uint16];
constant buf32 = Buf[uint32];
constant buf64 = Buf[uint64];

multi sub pack(Str $template, *@items) {
    my @bytes;
    for $template.comb(/<[a..zA..Z]>[\d+|'*']?/) -> $unit {
        my $directive = substr($unit,0,1);
        my $amount    = substr($unit,1);

        given $directive {
            when 'A' {
                my $ascii = shift @items // '';
                my $data = $ascii.ords;
                if $amount eq '*' {
                    $amount = +$data;
                }
                if $amount eq '' {
                    $amount = 1;
                }
                for (@$data, 0x20 xx *).flat[^$amount] -> $byte {
                    X::Buf::Pack::NonASCII.new(:char($byte.chr)).throw if $byte > 0x7f;
                    @bytes.push: $byte;
                }
            }
            when 'a' {
                my $data = shift @items // Buf.new;
                $data.=encode if nqp::istype($data,Str);
                if $amount eq '*' {
                    $amount = +@$data;
                }
                if $amount eq '' {
                    $amount = 1;
                }
                for (@$data, 0 xx *).flat[^$amount] -> $byte {
                    @bytes.push: $byte;
                }
            }
            when 'H' {
                my $hexstring = shift @items // '';
                if $hexstring.chars % 2 {
                    $hexstring ~= '0';
                }
                @bytes.push: map { :16($_) }, $hexstring.comb(/../);
            }
            when 'x' {
                if $amount eq '*' {
                    $amount = 0;
                }
                elsif $amount eq '' {
                    $amount = 1;
                }
                @bytes.push: 0x00 xx $amount;
            }
            when 'C' {
                my $number = shift(@items);
                @bytes.push: $number % 0x100;
            }
            when 'S' | 'v' {
                my $number = shift(@items);
                @bytes.push: ($number, $number +> 0x08) >>%>> 0x100;
            }
            when 'L' | 'V' {
                my $number = shift(@items);
                @bytes.push: ($number, $number +> 0x08,
                              $number +> 0x10, $number +> 0x18) >>%>> 0x100;
            }
            when 'n' {
                my $number = shift(@items);
                @bytes.push: ($number +> 0x08, $number) >>%>> 0x100;
            }
            when 'N' {
                my $number = shift(@items);
                @bytes.push: ($number +> 0x18, $number +> 0x10,
                              $number +> 0x08, $number) >>%>> 0x100;
            }
            X::Buf::Pack.new(:$directive).throw;
        }
    }

    return Buf.new(@bytes);
}

multi sub infix:<~>(Blob:D $a, Blob:D $b) {
    my $res := ($a.WHAT === $b.WHAT ?? $a !! Buf).new;
    my $adc := nqp::decont($a);
    my $bdc := nqp::decont($b);
    my int $alen = nqp::elems($adc);
    my int $blen = nqp::elems($bdc);
    nqp::setelems($res, $alen + $blen);
    my int $s = 0;
    my int $d = 0;
    while $s < $alen {
        nqp::bindpos_i($res, $d, nqp::atpos_i($adc, $s));
        $s = $s + 1;
        $d = $d + 1;
    }
    $s = 0;
    while $s < $blen {
        nqp::bindpos_i($res, $d, nqp::atpos_i($bdc, $s));
        $s = $s + 1;
        $d = $d + 1;
    }
    $res
}

multi sub prefix:<~^>(Blob:D $a) {
    $a ~~ Blob[int16] ?? $a.new($a.list.map: 0xFFFF - *) !!
    $a ~~ Blob[int32] ?? $a.new($a.list.map: 0xFFFFFFFF - *) !!
                         $a.new($a.list.map: 0xFF - *);
}

multi sub infix:<~&>(Blob:D $a, Blob:D $b) {
    my $minlen := $a.elems min $b.elems;
    my @anded-contents = $a.list[^$minlen] >>+&<< $b.list[^$minlen];
    @anded-contents.push: 0 xx ($a.elems - @anded-contents.elems);
    @anded-contents.push: 0 xx ($b.elems - @anded-contents.elems);
    ($a.WHAT === $b.WHAT ?? $a !! Buf).new(@anded-contents);
}

multi sub infix:<~|>(Blob:D $a, Blob:D $b) {
    my $minlen = $a.elems min $b.elems;
    my @ored-contents = $a.list[^$minlen] +| $b.list[^$minlen];
    @ored-contents.push: $a.list[@ored-contents.elems ..^ $a.elems];
    @ored-contents.push: $b.list[@ored-contents.elems ..^ $b.elems];
    ($a.WHAT === $b.WHAT ?? $a !! Buf).new(@ored-contents);
}

multi sub infix:<~^>(Blob:D $a, Blob:D $b) {
    my $minlen = $a.elems min $b.elems;
    my @xored-contents = $a.list[^$minlen] +^ $b.list[^$minlen];
    @xored-contents.push: $a.list[@xored-contents.elems ..^ $a.elems];
    @xored-contents.push: $b.list[@xored-contents.elems ..^ $b.elems];
    ($a.WHAT === $b.WHAT ?? $a !! Buf).new(@xored-contents);
}

multi sub infix:<eqv>(Blob:D $a, Blob:D $b) {
    if $a.WHAT === $b.WHAT && $a.elems == $b.elems {
        my int $n  = $a.elems;
        my int $i  = 0;
        my Mu $da := nqp::decont($a);
        my Mu $db := nqp::decont($b);
        while $i < $n {
            return False unless nqp::iseq_i(nqp::atpos_i($da, $i), nqp::atpos_i($db, $i));
            $i = $i + 1;
        }
        True
    }
    else {
        False
    }
}

multi sub infix:<cmp>(Blob:D $a, Blob:D $b) {
    [||] $a.list Z<=> $b.list or $a.elems <=> $b.elems
}

multi sub infix:<eq>(Blob:D $a, Blob:D $b) {
    $a.elems == $b.elems && $a.list eq $b.list
}

multi sub infix:<ne>(Blob:D $a, Blob:D $b) {
    not $a eq $b;
}

multi sub infix:<lt>(Blob:D $a, Blob:D $b) {
    ($a cmp $b) == -1
}

multi sub infix:<gt>(Blob:D $a, Blob:D $b) {
    ($a cmp $b) ==  1
}

multi sub infix:<le>(Blob:D $a, Blob:D $b) {
    ($a cmp $b) !=  1
}

multi sub infix:<ge>(Blob:D $a, Blob:D $b) {
    ($a cmp $b) != -1
}

sub subbuf-rw($b is rw, $from = 0, $elems = $b.elems - $from) {
    my Blob $subbuf = $b.subbuf($from, $elems);
    Proxy.new(
        FETCH   => sub ($) { $subbuf },
        STORE   => sub ($, Blob $new) {
            $b = $b.subbuf(0, $from)
               ~ $new
               ~ $b.subbuf($from + $elems);
        }
    );
}

# From 'src/core/Str.pm'

my class Cursor {... }
my class Range  {... }
my class Match  {... }
my class X::Str::Numeric  { ... }
my class X::Str::Match::x { ... }
my class X::Str::Trans::IllegalKey { ... }
my class X::Str::Trans::InvalidArg { ... }
my class X::Numeric::Confused { ... }

my constant $?TABSTOP = 8;

sub NORMALIZE_ENCODING(Str:D $s) {
    state %map = (
        # fast mapping for identicals
        'utf8'              => 'utf8',
        'utf16'             => 'utf16',
        'utf32'             => 'utf32',
        'ascii'             => 'ascii',
        'iso-8859-1'        => 'iso-8859-1',
        # with dash
        'utf-8'             => 'utf8',
        'utf-16'            => 'utf16',
        'utf-32'            => 'utf32',
        # according to http://de.wikipedia.org/wiki/ISO-8859-1
        'iso_8859-1:1987'   => 'iso-8859-1',
        'iso_8859-1'        => 'iso-8859-1',
        'iso-ir-100'        => 'iso-8859-1',
        'latin1'            => 'iso-8859-1',
        'latin-1'           => 'iso-8859-1',
        'csisolatin1'       => 'iso-8859-1',
        'l1'                => 'iso-8859-1',
        'ibm819'            => 'iso-8859-1',
        'cp819'             => 'iso-8859-1',
    );
    %map{$s} // %map{lc $s} // lc $s;
}

my class Str does Stringy { # declared in BOOTSTRAP
    # class Str is Cool {
    #     has str $!value is box_target;

    multi method WHY('Life, the Universe, and Everything':) { 42 }

    multi method WHICH(Str:D:) {
        nqp::box_s(
            nqp::concat(
                nqp::concat(nqp::unbox_s(self.^name), '|'),
                $!value
            ),
            ObjAt
        );
    }
    submethod BUILD(Str() :$value = '') {
        nqp::bindattr_s(self, Str, '$!value', nqp::unbox_s($value))
    }

    multi method Bool(Str:D:) {
        nqp::p6bool(nqp::chars($!value) && nqp::isne_s($!value,"0"));
    }

    multi method Str(Str:D:)     { self }
    multi method Stringy(Str:D:) { self }
    multi method DUMP(Str:D:) { self.perl }

    method Int(Str:D:) { self.Numeric.Int; }
    method Num(Str:D:) { self.Numeric.Num; }

    multi method ACCEPTS(Str:D: Str:D \other) {
        nqp::p6bool(nqp::iseq_s(nqp::unbox_s(other),$!value));
    }
    multi method ACCEPTS(Str:D: Any:U \other) {
        False;
    }
    multi method ACCEPTS(Str:D: Any:D \other) {
        nqp::p6bool(nqp::iseq_s(nqp::unbox_s(other.Str),$!value));
    }

    method chomp(Str:D:) {
        my str $sself = nqp::unbox_s(self);
        my int $chars = nqp::chars($sself);
        return '' if $chars == 0;

        my int $last = nqp::ordat($sself, $chars - 1);
        if $last == 10 {
            if $chars > 1 && nqp::iseq_i(nqp::ordat($sself, $chars - 2),  13) {
                nqp::p6box_s(nqp::substr($sself, 0, $chars - 2));
            }
            else {
                nqp::p6box_s(nqp::substr($sself, 0, $chars - 1));
            }
        }
        elsif $last == 13 {
            nqp::p6box_s(nqp::substr($sself, 0, $chars - 1));
        }
        else {
            self;
        }
    }

    method chop(Str:D: $chars = 1) {
        my str $sself = nqp::unbox_s(self);
        nqp::p6box_s(nqp::substr($sself, 0, nqp::chars($sself) - $chars))
    }

    # chars used to handle ranges for pred/succ
    my str $RANGECHAR =
        "01234567890"                                # arabic digits
        ~ "ABCDEFGHIJKLMNOPQRSTUVWXYZA"              # latin uppercase
        ~ "abcdefghijklmnopqrstuvwxyza"              # latin lowercase
        ~ "\x[391,392,393,394,395,396,397,398,399,39A,39B,39C,39D,39E,39F,3A0,3A1,3A3,3A4,3A5,3A6,3A7,3A8,3A9,391]" # greek uppercase
        ~ "\x[3B1,3B2,3B3,3B4,3B5,3B6,3B7,3B8,3B9,3BA,3BB,3BC,3BD,3BE,3BF,3C0,3C1,3C3,3C4,3C5,3C6,3C7,3C8,3C9,3B1]" # greek lowercase
        ~ "\x[5D0,5D1,5D2,5D3,5D4,5D5,5D6,5D7,5D8,5D9,5DA,5DB,5DC,5DD,5DE,5DF,5E0,5E1,5E2,5E3,5E4,5E5,5E6,5E7,5E8,5E9,5EA,5D0]" # hebrew
        ~ "\x[410,411,412,413,414,415,416,417,418,419,41A,41B,41C,41D,41E,41F,420,421,422,423,424,425,426,427,428,429,42A,42B,42C,42D,42E,42F,410]" # cyrillic uppercase
        ~ "\x[430,431,432,433,434,435,436,437,438,439,43A,43B,43C,43D,43E,43F,440,441,442,443,444,445,446,447,448,449,44A,44B,44C,44D,44E,44F,430]" # cyrillic lowercase
        ~ "\x[660,661,662,663,664,665,666,667,668,669,660]" # arabic-indic digits
        ~ "\x[966,967,968,969,96A,96B,96C,96D,96E,96F,966]" # devanagari digits
        ~ "\x[9E6,9E7,9E8,9E9,9EA,9EB,9EC,9ED,9EE,9EF,9E6]" # bengali digits
        ~ "\x[A66,A67,A68,A69,A6A,A6B,A6C,A6D,A6E,A6F,A66]" # gurmukhi digits
        ~ "\x[AE6,AE7,AE8,AE9,AEA,AEB,AEC,AED,AEE,AEF,AE6]" # gujarati digits
        ~ "\x[B66,B67,B68,B69,B6A,B6B,B6C,B6D,B6E,B6F,B66]" # oriya digits
        ~ "\x[FF10,FF11,FF12,FF13,FF14,FF15,FF16,FF17,FF18,FF19,FF10]" # fullwidth digits
        ~ "\x[2070,2071,00B2,00B3,2074,2075,2076,2077,2078,2079]" # superscripts
        ~ "\x[2080,2081,2082,2083,2084,2085,2086,2087,2088,2089]" # subscripts
        ~ "\x[2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,216a,216b,2160]" # clock roman uc
        ~ "\x[2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,217a,217b,2170]" # clock roman lc
        ~ "\x[2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,246A,246B,246C,246D,246E,246F,2470,2471,2472,2473,2460]" # circled digits 1..20
        ~ "\x[2474,2475,2476,2477,2478,2479,247A,247B,247C,247D,247E,247F,2480,2481,2482,2483,2484,2485,2486,2487,2474]" # parenthesized digits 1..20
        ~ "\x[249C,249D,249E,249F,24A0,24A1,24A2,24A3,24A4,24A5,24A6,24A7,24A8,24A9,24AA,24AB,24AC,24AD,24AE,24AF,24B0,24B1,24B2,24B3,24B4,24B5,249C]" # parenthesized latin lc
        ~ "\x[2581,2582,2583,2584,2585,2586,2587,2588]" # lower blocks
        ~ "\x[2680,2681,2682,2683,2684,2685,2680]" # die faces
        ~ "\x[2776,2777,2778,2779,277A,277B,277C,277D,277E,277F,2776]"; # dingbat negative circled 1..10

    # digit to extend the string with if carried past first rangechar position
    my $carrydigit := nqp::hash(
       '0',      '1',      # arabic
       "\x0660", "\x0661", # arabic-indic
       "\x0966", "\x0967", # devanagari
       "\x09E6", "\x09E7", # bengali
       "\x0A66", "\x0A67", # gurmukhi
       "\x0AE6", "\x0AE7", # gujarati
       "\x0B66", "\x0B67", # oriya
       "\xFF10", "\xFF11", # fullwidth XXX: should be treated as digit?
       "\x2070", "\x2071", # superscripts XXX: should be treated as digit?
       "\x2080", "\x2081", # subscripts XXX: should be treated as digit?
    );
    # calculate the beginning and ending positions of <!after '.'><rangechar+>
    my sub RANGEPOS(str $str) {
        my int $pos = nqp::chars($str);
        while $pos > 0 {
            $pos = $pos - 1;
            my str $ch = nqp::substr($str, $pos, 1);
            if nqp::isge_i(nqp::index($RANGECHAR, $ch, 0), 0) {
                my int $end = $pos;
                while $pos > 0 {
                    $pos = $pos - 1;
                    $ch = nqp::substr($str, $pos, 1);
                    last if nqp::iseq_s($ch, '.');
                    return ($pos+1, $end)
                        unless nqp::isge_i(nqp::index($RANGECHAR, $ch, 0), 0);
                }
                return ($pos, $end) unless nqp::iseq_s($ch, '.');
            }
        }
        return (0, -1);
    }

    method pred(Str:D:) {
        my str $str = self;
        my Int ($Ir0, $Ir1) = RANGEPOS($str);
        my int $r0 = $Ir0;
        my int $r1 = $Ir1;
        while $r1 >= $r0 {
            my str $ch0  = nqp::substr($str, $r1, 1);
            my int $ipos = nqp::index($RANGECHAR, $ch0);
            $ipos = $RANGECHAR.index($ch0, $ipos+1) // $ipos;
            my str $ch1 = nqp::substr($RANGECHAR, $ipos-1, 1);
            $str = nqp::replace($str, $r1, 1, $ch1);
            # return if no carry
            return $str if $ch0 gt $ch1;
            # carry to previous position
            $r1 = $r1 - 1;
        }
        # cannot carry beyond first rangechar position
        fail('Decrement out of range');
    }

    method succ(Str:D:) {
        my str $str = self;
        my Int ($Ir0, $Ir1) = RANGEPOS($str);
        my int $r0 = $Ir0;
        my int $r1 = $Ir1;
        while $r1 >= $r0 {
            my str $ch0  = nqp::substr($str, $r1, 1);
            my int $ipos = nqp::index($RANGECHAR, $ch0);
            my str $ch1  = nqp::substr($RANGECHAR, $ipos+1, 1);
            $str = nqp::replace($str, $r1, 1, $ch1);
            return $str if $ch1 gt $ch0;
            # carry to previous position
            $r1 = $r1 - 1;
            # extend string if carried past first rangechar position
            $str = nqp::replace($str, $r0, 0,
                       nqp::existskey($carrydigit, $ch1)
                           ?? nqp::atkey($carrydigit, $ch1)
                           !! $ch1)
                if $r1 < $r0;
        }
        $str;
    }


    # TODO:
    # * Additional numeric styles:
    #   + fractions in [] radix notation:  :100[10,'.',53]
    # * Performance tuning
    # * Fix remaining XXXX

    multi method Numeric(Str:D: :$strict = True) {
        my str $str = nqp::unbox_s(self);
        my int $eos = nqp::chars($str);

        # S02:3276-3277: Ignore leading and trailing whitespace
        my int $pos = nqp::findnotcclass(nqp::const::CCLASS_WHITESPACE,
                                                  $str, 0, $eos);
        my int $end = nqp::sub_i($eos, 1);

        $end = nqp::sub_i($end, 1)
            while nqp::isge_i($end, $pos)
               && nqp::iscclass(nqp::const::CCLASS_WHITESPACE, $str, $end);

        # Return 0 if no non-whitespace characters in string
        return 0 if nqp::islt_i($end, $pos);

        # Reset end-of-string after trimming
        $eos = nqp::add_i($end, 1);

        # Fail all the way out when parse failures occur
        my &parse_fail := -> $msg {
            fail X::Str::Numeric.new(
                    source => self,
                    reason => $msg,
                    :$pos,
            );
        };

        my sub parse-simple-number () {
            # Handle NaN here, to make later parsing simpler
            if nqp::iseq_s(nqp::substr($str, $pos, 3), 'NaN') {
                $pos = nqp::add_i($pos, 3);
                return nqp::p6box_n(nqp::nan());
            }

            # Handle any leading +/- sign
            my int $ch  = nqp::ord($str, $pos);
            my int $neg = nqp::iseq_i($ch, 45);                # '-'
            if nqp::iseq_i($ch, 45) || nqp::iseq_i($ch, 43) {  # '-', '+'
                $pos = nqp::add_i($pos, 1);
                $ch  = nqp::islt_i($pos, $eos) && nqp::ord($str, $pos);
            }

            # nqp::radix_I parse results, and helper values
            my Mu  $parse;
            my str $prefix;
            my int $radix;
            my int $p;

            my sub parse-int-frac-exp () {
                # Integer part, if any
                my Int:D $int := 0;
                if nqp::isne_i($ch, 46) {  # '.'
                    $parse := nqp::radix_I($radix, $str, $pos, $neg, Int);
                    $p      = nqp::atpos($parse, 2);
                    parse_fail "base-$radix number must begin with valid digits or '.'"
                        if nqp::iseq_i($p, -1);
                    $pos    = $p;

                    $int   := nqp::atpos($parse, 0);
                    if nqp::isge_i($pos, $eos) {
                        return $int;
                    }
                    else {
                        $ch = nqp::ord($str, $pos);
                    }
                }

                # Fraction, if any
                my Int:D $frac := 0;
                my Int:D $base := 0;
                if nqp::iseq_i($ch, 46) {  # '.'
                    $pos    = nqp::add_i($pos, 1);
                    $parse := nqp::radix_I($radix, $str, $pos,
                                           nqp::add_i($neg, 4), Int);
                    $p      = nqp::atpos($parse, 2);
                    parse_fail 'radix point must be followed by one or more valid digits'
                        if nqp::iseq_i($p, -1);
                    $pos    = $p;

                    $frac  := nqp::atpos($parse, 0);
                    $base  := nqp::atpos($parse, 1);
                    $ch     = nqp::islt_i($pos, $eos) && nqp::ord($str, $pos);
                }

                # Exponent, if 'E' or 'e' are present (forces return type Num)
                if nqp::iseq_i($ch, 69) || nqp::iseq_i($ch, 101) {  # 'E', 'e'
                    parse_fail "'E' or 'e' style exponent only allowed on decimal (base-10) numbers, not base-$radix"
                        unless nqp::iseq_i($radix, 10);

                    $pos    = nqp::add_i($pos, 1);
                    $parse := nqp::radix_I(10, $str, $pos, 2, Int);
                    $p      = nqp::atpos($parse, 2);
                    parse_fail "'E' or 'e' must be followed by decimal (base-10) integer"
                        if nqp::iseq_i($p, -1);
                    $pos    = $p;

                    my num $exp  = nqp::atpos($parse, 0).Num;
                    my num $coef = $frac ?? nqp::add_n($int.Num, nqp::div_n($frac.Num, $base.Num)) !! $int.Num;
                    return nqp::p6box_n(nqp::mul_n($coef, nqp::pow_n(10e0, $exp)));
                }

                # Multiplier with exponent, if single '*' is present
                # (but skip if current token is '**', as otherwise we
                # get recursive multiplier parsing stupidity)
                if nqp::iseq_i($ch, 42)
                && nqp::isne_s(substr($str, $pos, 2), '**') {  # '*'
                    $pos           = nqp::add_i($pos, 1);
                    my $mult_base := parse-simple-number();

                    parse_fail "'*' multiplier base must be an integer"
                        unless $mult_base.WHAT === Int;
                    parse_fail "'*' multiplier base must be followed by '**' and exponent"
                        unless nqp::iseq_s(nqp::substr($str, $pos, 2), '**');

                    $pos           = nqp::add_i($pos, 2);
                    my $mult_exp  := parse-simple-number();

                    parse_fail "'**' multiplier exponent must be an integer"
                        unless $mult_exp.WHAT === Int;

                    my $mult := $mult_base ** $mult_exp;
                    $int     := $int  * $mult;
                    $frac    := $frac * $mult;
                }

                # Return an Int if there was no radix point
                return $int unless $base;

                # Otherwise, return a Rat
                my Int:D $numerator := $int * $base + $frac;
                return Rat.new($numerator, $base);
            }

            # Look for radix specifiers
            if nqp::iseq_i($ch, 58) {  # ':'
                # A string of the form :16<FE_ED.F0_0D> or :60[12,34,56]
                $pos    = nqp::add_i($pos, 1);
                $parse := nqp::radix_I(10, $str, $pos, 0, Int);
                $p      = nqp::atpos($parse, 2);
                parse_fail "radix (in decimal) expected after ':'"
                    if nqp::iseq_i($p, -1);
                $pos    = $p;

                $radix  = nqp::atpos($parse, 0);
                $ch     = nqp::islt_i($pos, $eos) && nqp::ord($str, $pos);
                if    nqp::iseq_i($ch, 60) {  # '<'
                    $pos = nqp::add_i($pos, 1);

                    my $result := parse-int-frac-exp();

                    parse_fail "malformed ':$radix<>' style radix number, expecting '>' after the body"
                        unless nqp::islt_i($pos, $eos)
                            && nqp::iseq_i(nqp::ord($str, $pos), 62);  # '>'

                    $pos = nqp::add_i($pos, 1);
                    return $result;
                }
                elsif nqp::iseq_i($ch, 171) {  # ''
                    $pos = nqp::add_i($pos, 1);

                    my $result := parse-int-frac-exp();

                    parse_fail "malformed ':$radix' style radix number, expecting '' after the body"
                        unless nqp::islt_i($pos, $eos)
                            && nqp::iseq_i(nqp::ord($str, $pos), 187);  # ''

                    $pos = nqp::add_i($pos, 1);
                    return $result;
                }
                elsif nqp::iseq_i($ch, 91) {  # '['
                    $pos = nqp::add_i($pos, 1);
                    my Int:D $result := 0;
                    my Int:D $digit  := 0;
                    while nqp::islt_i($pos, $eos)
                       && nqp::isne_i(nqp::ord($str, $pos), 93) {  # ']'
                        $parse := nqp::radix_I(10, $str, $pos, 0, Int);
                        $p      = nqp::atpos($parse, 2);
                        parse_fail "malformed ':$radix[]' style radix number, expecting comma separated decimal values after opening '['"
                            if nqp::iseq_i($p, -1);
                        $pos    = $p;

                        $digit := nqp::atpos($parse, 0);
                        parse_fail "digit is larger than {$radix - 1} in ':$radix[]' style radix number"
                            if $digit >= $radix;

                        $result := $result * $radix + $digit;
                        $pos     = nqp::add_i($pos, 1)
                            if nqp::islt_i($pos, $eos)
                            && nqp::iseq_i(nqp::ord($str, $pos), 44);  # ','
                    }
                    parse_fail "malformed ':$radix[]' style radix number, expecting ']' after the body"
                        unless nqp::islt_i($pos, $eos)
                            && nqp::iseq_i(nqp::ord($str, $pos), 93);  # ']'
                    $pos = nqp::add_i($pos, 1);

                    # XXXX: Handle fractions!
                    # XXXX: Handle exponents!
                    return $neg ?? -$result !! $result;
                }
                else {
                    parse_fail "malformed ':$radix' style radix number, expecting '<' or '[' after the base";
                }
            }
            elsif nqp::iseq_i($ch, 48)  # '0'
              and $radix = nqp::index('  b     o d     x',
                                      nqp::substr($str, nqp::add_i($pos, 1), 1))
              and nqp::isge_i($radix, 2) {
                # A string starting with 0x, 0d, 0o, or 0b,
                # followed by one optional '_'
                $pos   = nqp::add_i($pos, 2);
                $pos   = nqp::add_i($pos, 1)
                    if nqp::islt_i($pos, $eos)
                    && nqp::iseq_i(nqp::ord($str, $pos), 95);  # '_'

                return parse-int-frac-exp();
            }
            elsif nqp::iseq_s(nqp::substr($str, $pos, 3), 'Inf') {
                # 'Inf'
                $pos = nqp::add_i($pos, 3);
                return $neg ?? -Inf !! Inf;
            }
            else {
                # Last chance: a simple decimal number
                $radix = 10;
                return parse-int-frac-exp();
            }
        }

        my sub parse-real () {
            # Parse a simple number or a Rat numerator
            my $result := parse-simple-number();
            return $result if nqp::iseq_i($pos, $eos);

            # Check for '/' indicating Rat denominator
            if nqp::iseq_i(nqp::ord($str, $pos), 47) {  # '/'
                $pos = nqp::add_i($pos, 1);
                parse_fail "denominator expected after '/'"
                    unless nqp::islt_i($pos, $eos);

                my $denom := parse-simple-number();

                $result := nqp::istype($result, Int) && nqp::istype($denom, Int)
                        ?? Rat.new($result, $denom)
                        !! $result / $denom;
            }

            return $result;
        }

        # Parse a real number, magnitude of a pure imaginary number,
        # or real part of a complex number
        my $result := parse-real();
        return $result if nqp::iseq_i($pos, $eos);

        # Check for 'i' or '\\i' indicating first parsed number was
        # the magnitude of a pure imaginary number
        if nqp::iseq_i(nqp::ord($str, $pos), 105) {  # 'i'
            $pos = nqp::add_i($pos, 1);
            $result := Complex.new(0, $result);
        }
        elsif nqp::iseq_s(nqp::substr($str, $pos, 2), '\\i') {
            $pos = nqp::add_i($pos, 2);
            $result := Complex.new(0, $result);
        }
        # Check for '+' or '-' indicating first parsed number was
        # the real part of a complex number
        elsif nqp::iseq_i(nqp::ord($str, $pos), 45)    # '-'
           || nqp::iseq_i(nqp::ord($str, $pos), 43) {  # '+'
            # Don't move $pos -- we want parse-real() to see the sign
            my $im := parse-real();
            parse_fail "imaginary part of complex number must be followed by 'i' or '\\i'"
                unless nqp::islt_i($pos, $eos);

            if nqp::iseq_i(nqp::ord($str, $pos), 105) {  # 'i'
                $pos = nqp::add_i($pos, 1);
            }
            elsif nqp::iseq_s(nqp::substr($str, $pos, 2), '\\i') {
                $pos = nqp::add_i($pos, 2);
            }
            else {
                parse_fail "imaginary part of complex number must be followed by 'i' or '\\i'"
            }

            $result := Complex.new($result, $im);
        }

        # Check for trailing garbage
        parse_fail "trailing characters after number"
            if nqp::islt_i($pos, $eos);

        return $result;
    }

    my %esc = (
        '$' => '\$',  '@' => '\@',  '%' => '\%',  '&' => '\&',  '{' => '\{',
        "\b" => '\b', "\n" => '\n', "\r" => '\r', "\t" => '\t', '"' => '\"',
        '\\' => '\\\\' );

    multi method gist(Str:D:) { self }
    multi method perl(Str:D:) {
        my $result = '"';
        for ^self.chars -> $i {
            my $ch = substr(self,$i, 1);
            $result ~= %esc{$ch}
                       //  (nqp::iscclass( nqp::const::CCLASS_PRINTING,
                                                  nqp::unbox_s($ch), 0)
                           ?? $ch
                           !! $ch.ord.fmt('\x[%x]')
                           );
        }
        $result ~ '"'
    }

    multi method comb(Str:D:) {
        my str $self = nqp::unbox_s(self);
        (^self.chars).map({ nqp::p6box_s(nqp::substr($self, $_, 1)) });
    }
    multi method comb(Str:D: Regex $pat, $limit = Inf, :$match) {
        my $x;
        $x = (1..$limit) unless nqp::istype($limit, Whatever) || $limit == Inf;
        $match
            ?? self.match(:g, :$x, $pat)
            !! self.match(:g, :$x, $pat).map: { .Str }
    }

    method match($pat,
                  :continue(:$c), :pos(:$p),
                  :global(:$g), :overlap(:$ov), :exhaustive(:$ex),
                  # :st(:nd(:rd(:th($nth)))) is cute, but slow
                  :st(:$nd), :rd(:$th), :$nth = $nd // $th, :$x) {
        my $caller_dollar_slash := nqp::getlexcaller('$/');
        my %opts;
        if $p.defined { %opts<p> = $p }
        else { %opts<c> = $c // 0; }
        my $patrx := nqp::istype($pat,Code) ?? $pat !! / "$pat": /;
        my $cur := $patrx(Cursor.'!cursor_init'(self, |%opts));

        %opts<ov> = $ov if $ov;
        %opts<ex> = $ex if $ex;

        my @matches := gather {
            while $cur.pos >= 0 {
                take $cur.MATCH_SAVE;
                $cur := $cur.'!cursor_more'(|%opts);
            }
        }
        my $multi = $g || $ov || $ex;

        if $nth.defined {
            $multi = Positional.ACCEPTS($nth);
            my @nlist := $nth.list;
            my @src   := @matches;
            @matches  := gather {
                my $max = 0;
                while @nlist {
                    my $n = shift @nlist;
                    $n = $n(+@src) + 1 if nqp::istype($n, Callable);
                    fail "Attempt to retrieve negative match :nth($n)" if $n < 1;
                    if $n > $max { take @src[$n-1]; $max = $n; }
                }
            }
        }

        if $x.defined {
            $multi = True;
            if nqp::istype($x, Int) {
                @matches := @matches.gimme($x) >= $x
                            ?? @matches[^$x]
                            !! ().list
            }
            elsif nqp::istype($x, Range) {
                my $min = $x.min.ceiling;
                my $max = $x.max;
                $min++ while $min <= $max && $min !~~ $x;
                if @matches.gimme($min) >= $min && $min ~~ $x {
                    my @src := @matches;
                    @matches := gather {
                        my $n = 0;
                        while @src && ($n < $min || $n+1 ~~ $x) {
                            take @src.shift;
                            $n++;
                        }
                    }
                }
                else { @matches := ().list }
            }
            elsif nqp::istype($x, Whatever) { }
            else {
                X::Str::Match::x.new(got => $x).fail;
            }
        }

        if $multi {
            if nqp::istype($pat, Regex) {
                try $caller_dollar_slash = +@matches
                    ?? @matches[ +@matches - 1 ]
                    !! Cursor.'!cursor_init'(nqp::unbox_s('self')).'!cursor_start_cur'().MATCH;
            }
            $caller_dollar_slash = @matches;
            @matches
        }
        else {
            try $caller_dollar_slash = (@matches[0] // $cur.MATCH_SAVE);
            (@matches[0] // $cur.MATCH_SAVE)
        }
    }

    multi method subst-mutate($self is rw: $matcher, $replacement,
                       :ii(:$samecase), :ss(:$samespace),
                       :$SET_CALLER_DOLLAR_SLASH, *%options) {
        my $global = %options<g> || %options<global>;
        my $caller_dollar_slash := nqp::getlexcaller('$/');
        my $SET_DOLLAR_SLASH     = $SET_CALLER_DOLLAR_SLASH || nqp::istype($matcher, Regex);

        try $caller_dollar_slash = $/ if $SET_DOLLAR_SLASH;
        my @matches              = self.match($matcher, |%options);

        if !@matches || (@matches == 1 && !@matches[0]) {
            Nil;
        }
        else {
            $self = $self!APPLY-MATCHES(
              @matches,
              $replacement,
              $caller_dollar_slash,
              $SET_DOLLAR_SLASH,
              $samecase,
              $samespace,
            );
            $global ?? (@matches,).list !! @matches[0];
        }
    }

    multi method subst(Str:D: Str \from, Str \to, :$global!, *%adverbs) {
        if $global && !%adverbs {
            TRANSPOSE(self,from,to);
        }
        else {
            $/ := nqp::getlexdyn('$/');
            self.subst(from, to, |%adverbs);
        }
    }
    multi method subst(Str:D: $matcher, $replacement,
                       :ii(:$samecase), :ss(:$samespace),
                       :$SET_CALLER_DOLLAR_SLASH, *%options) {

        my $caller_dollar_slash := nqp::getlexcaller('$/');
        my $SET_DOLLAR_SLASH     = $SET_CALLER_DOLLAR_SLASH || nqp::istype($matcher, Regex);

        # nothing to do
        try $caller_dollar_slash = $/ if $SET_DOLLAR_SLASH;
        my @matches = self.match($matcher, |%options);

        !@matches || (@matches == 1 && !@matches[0])
          ?? self
          !! self!APPLY-MATCHES(
               @matches,
               $replacement,
               $caller_dollar_slash,
               $SET_DOLLAR_SLASH,
               $samecase,
               $samespace,
             );
    }

    method !APPLY-MATCHES(\matches,$replacement,\cds,\SDS,\case,\space) {
        my \callable       := nqp::istype($replacement,Callable);

        my int $prev;
        my str $str    = nqp::unbox_s(self);
        my Mu $result := nqp::list_s();
        try cds = $/ if SDS;

        # need to do something special
        if SDS || case || space || callable {
            my \noargs         := callable ?? $replacement.count == 0 !! False;
            my \case-or-space  := case || space;
            my \case-and-space := case && space;

            for matches -> $m {
                try cds = $m if SDS;
                nqp::push_s(
                  $result,nqp::substr($str,$prev,nqp::unbox_i($m.from) - $prev)
                );

                if case-or-space {
                    my $it := ~(callable
                      ?? (noargs ?? $replacement() !! $replacement($m))
                      !! $replacement
                    );
                    if case-and-space {
                        my $mstr := $m.Str;
                        nqp::push_s($result,nqp::unbox_s(
                          $it.samecase($mstr).samespace($mstr)
                        ) );
                    }
                    elsif case {
                        nqp::push_s($result,nqp::unbox_s($it.samecase(~$m)));
                    }
                    else { # space
                        nqp::push_s($result,nqp::unbox_s($it.samespace(~$m)));
                    }
                }
                else {
                    nqp::push_s($result,nqp::unbox_s( ~(callable
                      ?? (noargs ?? $replacement() !! $replacement($m))
                      !! $replacement
                    ) ) );
                }
                $prev = nqp::unbox_i($m.to);
            }
            nqp::push_s($result,nqp::substr($str,$prev));
            nqp::p6box_s(nqp::join('',$result));
        }

        # simple string replacement
        else {
            for matches -> $m {
                nqp::push_s(
                  $result,nqp::substr($str,$prev,nqp::unbox_i($m.from) - $prev)
                );
                $prev = nqp::unbox_i($m.to);
            }
            nqp::push_s($result,nqp::substr($str,$prev));
            nqp::p6box_s(nqp::join(nqp::unbox_s(~$replacement),$result));
        }
    }

    method ords(Str:D:) {
        my str $ns = nqp::unbox_s(self);
        (^self.chars).map: { nqp::p6box_i(nqp::ord(nqp::substr($ns, $_, 1))) }
    }

    # constant ???
    my str $CRLF = nqp::unbox_s("\r\n");

    multi method lines(Str:D:) {
        my str $str   = nqp::unbox_s(self);
        my int $chars = nqp::chars($str);
        my int $left;
        my int $pos;
        my int $nextpos;
        my int $found;

        gather while ($left = $chars - $pos) > 0 {
            $nextpos =
              nqp::findcclass(nqp::const::CCLASS_NEWLINE, $str, $pos, $left);
            take ($found = $nextpos - $pos)
              ?? nqp::box_s(nqp::substr( $str, $pos, $found ), Str)
              !! '';
            $pos = $nextpos + 1 + nqp::eqat($str, $CRLF, $nextpos);
        }
    }
    multi method lines(Str:D: :$eager!) {  # can probably go after GLR
        return self.lines if !$eager;

        my str $str   = nqp::unbox_s(self);
        my int $chars = nqp::chars($str);
        my int $left;
        my int $pos;
        my int $nextpos;
        my int $found;
        my Mu $rpa := nqp::list();

        while ($left = $chars - $pos) > 0 {
            $nextpos =
              nqp::findcclass(nqp::const::CCLASS_NEWLINE, $str, $pos, $left);
            nqp::push($rpa, ($found = $nextpos - $pos)
              ?? nqp::box_s(nqp::substr( $str, $pos, $found ), Str)
              !! ''
            );
            $pos = $nextpos + 1 + nqp::eqat($str, $CRLF, $nextpos);
        }
        nqp::p6parcel($rpa, Nil);
    }
    multi method lines(Str:D: :$count!) {
        return self.lines if !$count;

        my str $str   = nqp::unbox_s(self);
        my int $chars = nqp::chars($str);
        my int $left;
        my int $pos;
        my int $nextpos;
        my int $lines;

        while ($left = $chars - $pos) > 0 {
            $nextpos =
              nqp::findcclass(nqp::const::CCLASS_NEWLINE, $str, $pos, $left);
            $lines = $lines + 1;
            $pos   = $nextpos + 1 + nqp::eqat($str, $CRLF, $nextpos);
        }
        nqp::box_i($lines, Int);
    }
    multi method lines(Str:D: Whatever $, :$eager) {
        self.lines(:$eager);
    }
    multi method lines(Str:D: $limit, :$eager ) {
        return self.lines(:$eager) if $limit == Inf;

        my str $str   = nqp::unbox_s(self);
        my int $chars = nqp::chars($str);
        my int $left;
        my int $pos;
        my int $nextpos;
        my int $found;
        my int $count = $limit + 1;
        my Mu $rpa := nqp::list();

        while ($count = $count - 1) and ($left = $chars - $pos) > 0 {
            $nextpos =
              nqp::findcclass(nqp::const::CCLASS_NEWLINE, $str, $pos, $left);
            nqp::push($rpa, ($found = $nextpos - $pos)
              ?? nqp::box_s(nqp::substr( $str, $pos, $found ), Str)
              !! ''
            );
            $pos = $nextpos + 1 + nqp::eqat($str, $CRLF, $nextpos);
        }
        nqp::p6parcel($rpa, Nil);
    }

    multi method split(Str:D: Regex $pat, $limit = *, :$all) {
        return ().list
          if nqp::istype($limit,Numeric) && $limit <= 0;
        my @matches = nqp::istype($limit, Whatever)
          ?? self.match($pat, :g)
          !! self.match($pat, :x(1..$limit-1), :g);

        # add dummy for last
        push @matches, Match.new( :from(self.chars) );
        my $prev-pos = 0;

        if ($all) {
            my $elems = +@matches;
            map {
                my $value = substr(self,$prev-pos, .from - $prev-pos);
                $prev-pos = .to;
                # we don't want the dummy object
                --$elems ?? ($value, $_) !! $value;
            }, @matches;
        }
        else {
            map {
                my $value = substr(self,$prev-pos, .from - $prev-pos);
                $prev-pos = .to;
                $value;
            }, @matches;
        }
    }

    multi method split(Str:D: Cool $delimiter, $limit = *, :$all) {
        my $delim-str        = $delimiter.Str;
        my str $self-string  = self;
        my str $match-string = $delim-str;
        return unless nqp::chars($self-string) || nqp::chars($match-string);

        my int $l = nqp::istype($limit, Whatever) || $limit == Inf
            ?? nqp::chars($self-string) + 1
            !! $limit.Int;
        return ().list     if $l <= 0;
        return (self).list if $l == 1;

        my int $c = 0;
        my int $done = 0;
        if nqp::chars($match-string) {
            my int $width = nqp::chars($match-string);
            map {
                last if $done;

                my int $m = nqp::index($self-string, $match-string, $c);
                if $m >= 0 and ($l = $l - 1) {
                    my \value = nqp::p6box_s(nqp::substr($self-string, $c, $m - $c));
                    $c = $m + $width;
                    $all ?? (value, $match-string) !! value;
                }
                else {
                    $done = 1;
                    nqp::p6box_s(nqp::substr($self-string, $c));
                }
            }, 1 .. $l;
        } else {
            my int $chars = nqp::chars($self-string);
            map {
                last if $done;

                if ($chars = $chars - 1) and ($l = $l - 1) {
                    my \value = nqp::p6box_s(nqp::substr($self-string, $c, 1));
                    $c = $c + 1;
                    value
                }
                else {
                    $done = 1;
                    nqp::p6box_s(nqp::substr($self-string, $c));
                }
            }, 1 .. $l;
        }
    }

    method samecase(Str:D: Str $pattern) {
        my str $str = nqp::unbox_s(self);
        my str $pat = nqp::unbox_s($pattern);
        my int $min = min(nqp::chars($str),nqp::chars($pattern));
        my int $i = 0;
        my int $j = 0;
        my int $case = 0;
        my int $last-case;
        my Mu $ret := nqp::list_s();
        my str $substr;
        while $i < $min {
            repeat {
                $last-case = $case;
                $case = nqp::iscclass(nqp::const::CCLASS_LOWERCASE, $pat, $j) ?? 1 !!
                        nqp::iscclass(nqp::const::CCLASS_UPPERCASE, $pat, $j) ?? 2 !! 0;
                last if $case != $last-case;
                $j = $j + 1;
            } while $j < $min;
            $substr = nqp::substr($str, $i, $j - $i);
            nqp::push_s($ret, $last-case == 1 ?? nqp::lc($substr) !!
                              $last-case == 2 ?? nqp::uc($substr) !! $substr);
            $i = $j
        }
        $substr = nqp::substr($str,$i);
        nqp::push_s($ret, $case == 1 ?? nqp::lc($substr) !!
                          $case == 2 ?? nqp::uc($substr) !! $substr);
        nqp::join("",$ret);
    }


    method samespace(Str:D: Str:D $pat) {
        my @self-chunks  = self.split(rx/\s+/, :all).flat;
        my @pat-chunks  := $pat.split(rx/\s+/, :all).flat;
        loop (my $i = 1; $i < @pat-chunks && $i < @self-chunks; $i += 2) {
            @self-chunks[$i] = @pat-chunks[$i];
        }
        @self-chunks.join;
    }

    method trim-leading(Str:D:) {
        my str $str = nqp::unbox_s(self);
        my int $pos = nqp::findnotcclass(
                          nqp::const::CCLASS_WHITESPACE,
                          $str, 0, nqp::chars($str));
        $pos ?? nqp::p6box_s(nqp::substr($str, $pos)) !! self;
    }

    method trim-trailing(Str:D:) {
        my str $str = nqp::unbox_s(self);
        my int $pos = nqp::chars($str) - 1;
        $pos = $pos - 1
            while nqp::isge_i($pos, 0)
               && nqp::iscclass(nqp::const::CCLASS_WHITESPACE, $str, $pos);
        nqp::islt_i($pos, 0) ?? '' !! nqp::p6box_s(nqp::substr($str, 0, $pos + 1));
    }

    method trim(Str:D:) {
        my str $str  = nqp::unbox_s(self);
        my int $pos  = nqp::chars($str) - 1;
        my int $left = nqp::findnotcclass(
                           nqp::const::CCLASS_WHITESPACE, $str, 0, $pos + 1);
        $pos = $pos - 1
            while nqp::isge_i($pos, $left)
               && nqp::iscclass(nqp::const::CCLASS_WHITESPACE, $str, $pos);
        nqp::islt_i($pos, $left) ?? '' !! nqp::p6box_s(nqp::substr($str, $left, $pos + 1 - $left));
    }

    multi method words(Str:D:) {
        my str $str   = nqp::unbox_s(self);
        my int $chars = nqp::chars($str);
        my int $pos   = nqp::findnotcclass(
          nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);
        my int $left;
        my int $nextpos;

        gather while ($left = $chars - $pos) > 0 {
            $nextpos = nqp::findcclass(
              nqp::const::CCLASS_WHITESPACE, $str, $pos, $left);
            take nqp::box_s(nqp::substr( $str, $pos, $nextpos - $pos ), Str);
            last unless $left = $chars - $nextpos;

            $pos = nqp::findnotcclass(
              nqp::const::CCLASS_WHITESPACE, $str, $nextpos, $left);
        }
    }
    multi method words(Str:D: :$eager!) {  # can probably go after GLR
        return self.words if !$eager;

        my str $str   = nqp::unbox_s(self);
        my int $chars = nqp::chars($str);
        my int $pos   = nqp::findnotcclass(
          nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);
        my int $left;
        my int $nextpos;
        my Mu $rpa := nqp::list();

        while ($left = $chars - $pos) > 0 {
            $nextpos = nqp::findcclass(
              nqp::const::CCLASS_WHITESPACE, $str, $pos, $left);
            nqp::push($rpa,
              nqp::box_s(nqp::substr( $str, $pos, $nextpos - $pos ), Str));
            last unless $left = $chars - $nextpos;

            $pos = nqp::findnotcclass(
              nqp::const::CCLASS_WHITESPACE, $str, $nextpos, $left);
        }
        nqp::p6parcel($rpa, Nil);
    }
    multi method words(Str:D: :$autoderef!) { # in Actions.postprocess_words
        my @list := self.words(:eager);
        return @list == 1 ?? @list[0] !! @list;
    }
    multi method words(Str:D: :$count!) {
        return self.words if !$count;

        my str $str   = nqp::unbox_s(self);
        my int $chars = nqp::chars($str);
        my int $pos   = nqp::findnotcclass(
          nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);
        my int $left;
        my int $nextpos;
        my int $words;

        while ($left = $chars - $pos) > 0 {
            $nextpos = nqp::findcclass(
              nqp::const::CCLASS_WHITESPACE, $str, $pos, $left);
            $words = $words + 1;
            last unless $left = $chars - $nextpos;

            $pos = nqp::findnotcclass(
              nqp::const::CCLASS_WHITESPACE, $str, $nextpos, $left);
        }
        nqp::box_i($words, Int);
    }
    multi method words(Str:D: Whatever $, :$eager) {
        self.words(:$eager);
    }
    multi method words(Str:D: $limit, :$eager) {
        return self.words(:$eager) if $limit == Inf;

        my str $str   = nqp::unbox_s(self);
        my int $chars = nqp::chars($str);
        my int $pos   = nqp::findnotcclass(
          nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);
        my int $left;
        my int $nextpos;
        my int $count = $limit + 1;
        my Mu $rpa := nqp::list();

        while ($count = $count - 1) and ($left = $chars - $pos) > 0 {
            $nextpos = nqp::findcclass(
              nqp::const::CCLASS_WHITESPACE, $str, $pos, $left);
            nqp::push($rpa,
              nqp::box_s(nqp::substr( $str, $pos, $nextpos - $pos ), Str));
            last unless $left = $chars - $nextpos;

            $pos = nqp::findnotcclass(
              nqp::const::CCLASS_WHITESPACE, $str, $nextpos, $left);
        }
        nqp::p6parcel($rpa, Nil);
    }

    my %enc_type = utf8 => utf8, utf16 => utf16, utf32 => utf32;
    method encode(Str:D $encoding = 'utf8') {
        my $enc      := NORMALIZE_ENCODING($encoding);
        my $enc_type := %enc_type.EXISTS-KEY($enc) ?? %enc_type{$enc} !! blob8;
        nqp::encode(nqp::unbox_s(self), nqp::unbox_s($enc), nqp::decont($enc_type.new))
    }

    method wordcase(Str:D: :&filter = &tclc, Mu :$where = True) {
        self.subst(:g, / [<:L> \w* ] +% <['\-]> /, -> $m {
            my Str $s = $m.Str;
            $s ~~ $where ?? filter($s) !! $s;
        });
    }

    my class LSM {
        has Str $!source;
        has @!substitutions;

        has int $!index;
        has int $!next_match;
        has $!next_substitution;
        has $!substitution_length;

        has str $.unsubstituted_text;
        has str $.substituted_text;

        submethod BUILD(:$!source) { }

        method add_substitution($key, $value) {
            push @!substitutions, $key => $value;
        }

        submethod compare_substitution($substitution, Int $pos, Int $length) {
            if $!next_match > $pos
               || $!next_match == $pos && $!substitution_length < $length {

                $!next_match = $pos;
                $!substitution_length = $length;
                $!next_substitution = $substitution;
            }
        }

        proto method triage_substitution(|) {*}
        multi method triage_substitution($_ where { nqp::istype(.key,Regex) }) {
            my $m := $!source.match(.key, :continue($!index));
            return unless $m;
            self.compare_substitution($_, $m.from, $m.to - $m.from);
            True
        }

        multi method triage_substitution($_ where { nqp::istype(.key,Cool) }) {
            my $pos := index($!source, .key, $!index);
            return unless defined $pos;
            self.compare_substitution($_, $pos, .key.chars);
            True
        }

        multi method triage_substitution($_) {
            X::Str::Trans::IllegalKey.new(key => $_).throw;
        }

        proto method increment_index(|) {*}
        multi method increment_index(Regex $s) {
            substr($!source,$!index) ~~ $s;
            $!index = $!next_match + $/.chars;
        }

        multi method increment_index(Cool $s) {
            $!index = $!next_match + nqp::chars($s.Str);
        }

        method next_substitution() {
            $!next_match = $!source.chars;

            # triage_substitution has a side effect!
            @!substitutions = @!substitutions.grep: {self.triage_substitution($_) }

            $!unsubstituted_text # = nqp::substr(nqp::unbox_s($!source), $!index,
                = substr($!source,$!index, $!next_match - $!index);
            if defined $!next_substitution {
                my $result = $!next_substitution.value;
                $!substituted_text
                    = nqp::unbox_s((nqp::istype($result,Callable) ?? $result() !! $result).Str);
                self.increment_index($!next_substitution.key);
            }

            return $!next_match < $!source.chars && @!substitutions;
        }
    }

    proto method trans(|) { * }
    multi method trans(Pair:D \what, *%n) {
        my $from = what.key;
        my $to   = what.value;
        return self.trans(|%n, (what,))
          if !nqp::istype($from,Str)   # from not a string
          || !$from.defined            # or a type object
          || !nqp::istype($to,Str)     # or to not a string
          || !$to.defined              # or a type object
          || %n;                       # or any named params passed

        return TRANSPOSE-ONE(self, $from, substr($to,0,1))  # 1 char to 1 char
          if $from.chars == 1 && $to.chars;

        sub expand(Str:D \x) {
            my str $s     = nqp::unbox_s(x);
            my int $found = nqp::index($s,'..',1);
            return x       #  not found or at the end without trail
              if nqp::iseq_i($found,-1) || nqp::iseq_i($found,nqp::chars($s)-2);

            my int $from   = nqp::ordat($s,$found - 1);
            my int $to     = nqp::ordat($s,$found + 2);
            my Mu $result := nqp::list_s();

            nqp::push_s($result,nqp::substr($s,0,$found - 1));
            while nqp::isle_i($from,$to) {
                nqp::push_s($result,nqp::chr($from));
                $from = $from + 1;
            }
            nqp::push_s($result,nqp::substr($s,$found + 3));

            expand(nqp::p6box_s(nqp::join('',$result)));
        }

        my str $sfrom  = nqp::unbox_s(expand($from));
        my str $str    = nqp::unbox_s(self);
        my str $chars  = nqp::chars($str);
        my Mu $result := nqp::list_s();
        my str $check;
        my int $i;

        # something to convert to
        if $to.chars -> $tochars {
            nqp::setelems($result,$chars);

            # all convert to one char
            if $tochars == 1 {
                my str $sto = nqp::unbox_s($to);

                while nqp::islt_i($i,$chars) {
                    $check = nqp::substr($str,$i,1);
                    nqp::bindpos_s(
                      $result, $i, nqp::iseq_i(nqp::index($sfrom,$check),-1)
                        ?? $check
                        !! $sto
                    );
                    $i = $i + 1;
                }
            }

            # multiple chars to convert to
            else {
                my str $sto   = nqp::unbox_s(expand($to));
                my int $sfl   = nqp::chars($sfrom);
                my int $found;

                # repeat until mapping complete
                $sto = $sto ~ $sto while nqp::islt_i(nqp::chars($sto),$sfl);

                while nqp::islt_i($i,$chars) {
                    $check = nqp::substr($str,$i,1);
                    $found = nqp::index($sfrom,$check);
                    nqp::bindpos_s($result, $i, nqp::iseq_i($found,-1)
                      ?? $check
                      !! nqp::substr($sto,$found,1)
                    );
                    $i = $i + 1;
                }
            }
        }

        # just remove
        else {
            while nqp::islt_i($i,$chars) {
                $check = nqp::substr($str,$i,1);
                nqp::push_s($result, $check)
                  if nqp::iseq_i(nqp::index($sfrom,$check),-1);
                $i = $i + 1;
            }
        }

        nqp::p6box_s(nqp::join('',$result));
    }
    multi method trans(Str:D: *@changes) {
        my sub expand($s) {
            return $s.list
              if nqp::istype($s,Iterable) || nqp::istype($s,Positional);
            $s.comb(/ (\w) '..' (\w) | . /, :match).map: {
                .[0] ?? ~.[0] .. ~.[1] !! ~$_
            };
        }

        my $lsm = LSM.new(:source(self));
        for (@changes) -> $p {
            X::Str::Trans::InvalidArg.new(got => $p).throw
              unless nqp::istype($p,Pair);
            if nqp::istype($p.key,Regex) {
                $lsm.add_substitution($p.key, $p.value);
            }
            elsif nqp::istype($p.value,Callable) {
                my @from = expand $p.key;
                for @from -> $f {
                    $lsm.add_substitution($f, $p.value);
                }
            }
            else {
                my @from = expand $p.key;
                my @to = expand $p.value;
                for @from Z (@to ?? @to xx ceiling(@from / @to) !! '' xx @from) -> $f, $t {
                    $lsm.add_substitution($f, $t);
                }
            }
        }

        my Mu $ret := nqp::list_s();
        while $lsm.next_substitution {
            nqp::push_s($ret, nqp::unbox_s($lsm.unsubstituted_text));
            nqp::push_s($ret, nqp::unbox_s($lsm.substituted_text));
        }
        nqp::push_s($ret, nqp::unbox_s($lsm.unsubstituted_text));
        return nqp::join('', $ret);
    }
    proto method indent($) {*}
    # Zero indent does nothing
    multi method indent(Int() $steps where { $_ == 0 }) {
        self;
    }

    # Positive indent does indent
    multi method indent(Int() $steps where { $_ > 0 }) {
    # We want to keep trailing \n so we have to .comb explicitly instead of .lines
        return self.comb(/:r ^^ \N* \n?/).map({
            given $_.Str {
                when /^ \n? $ / {
                    $_;
                }
                # Use the existing space character if they're all the same
                # (but tabs are done slightly differently)
                when /^(\t+) ([ \S .* | $ ])/ {
                    $0 ~ "\t" x ($steps div $?TABSTOP) ~
                         ' '  x ($steps mod $?TABSTOP) ~ $1
                }
                when /^(\h) $0* [ \S | $ ]/ {
                    $0 x $steps ~ $_
                }

                # Otherwise we just insert spaces after the existing leading space
                default {
                    $_ ~~ /^(\h*) (.*)$/;
                    $0 ~ (' ' x $steps) ~ $1
                }
            }
        }).join;
    }

    # Negative indent (outdent)
    multi method indent(Int() $steps where { $_ < 0 }) {
        return outdent(self, $steps);
    }

    # Whatever indent (outdent)
    multi method indent(Whatever $steps) {
        return outdent(self, $steps);
    }

    sub outdent($obj, $steps) {
        # Loop through all lines to get as much info out of them as possible
        my @lines = $obj.comb(/:r ^^ \N* \n?/).map({
            # Split the line into indent and content
            my ($indent, $rest) = @($_ ~~ /^(\h*) (.*)$/);

            # Split the indent into characters and annotate them
            # with their visual size
            my $indent-size = 0;
            my @indent-chars = $indent.comb.map(-> $char {
                my $width = $char eq "\t"
                    ?? $?TABSTOP - ($indent-size mod $?TABSTOP)
                    !! 1;
                $indent-size += $width;
                $char => $width;
            }).eager;

            { :$indent-size, :@indent-chars, :rest(~$rest) };
        });

        # Figure out the amount * should outdent by, we also use this for warnings
        my $common-prefix = min @lines.grep({ .<indent-size> ||  .<rest> ~~ /\S/}).map({ $_<indent-size> });
        return $obj if $common-prefix === Inf;

        # Set the actual outdent amount here
        my Int $outdent = nqp::istype($steps,Whatever)
          ?? $common-prefix
          !! -$steps;

        warn "Asked to remove $outdent spaces, but the shortest indent is $common-prefix spaces"
            if $outdent > $common-prefix;

        # Work backwards from the right end of the indent whitespace, removing
        # array elements up to # (or over, in the case of tab-explosion)
        # the specified outdent amount.
        @lines.map({
            my $pos = 0;
            while $_<indent-chars> and $pos < $outdent {
                $pos += $_<indent-chars>.pop.value;
            }
            $_<indent-chars>.key.join ~ ' ' x ($pos - $outdent) ~ $_<rest>;
        }).join;
    }

    method codes(Str:D:) returns Int:D {
        nqp::p6box_i(nqp::chars(nqp::unbox_s(self)))
    }

    method path(Str:D:) returns IO::Path:D {
        DEPRECATED('IO', |<2014.11 2015.11>);
        IO::Path.new(self)
    }

    method unival(Str:D:)  { unival(self.ord) };
    method univals(Str:D:) { univals(self) };
}


multi sub prefix:<~>(Str:D \a)  returns Str:D { a }
multi sub prefix:<~>(str $a)    returns str   { $a }

multi sub infix:<~>(Str:D \a, Str:D \b) returns Str:D {
    nqp::p6box_s(nqp::concat(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<~>(str $a, str $b) returns str { nqp::concat($a, $b) }
multi sub infix:<~>(*@args) returns Str:D { @args.join }

multi sub infix:<x>(Str:D $s, Int:D $repetition) returns Str:D {
    $repetition < 0
        ?? ''
        !!  nqp::p6box_s(nqp::x(nqp::unbox_s($s), nqp::unbox_i($repetition)))
}
multi sub infix:<x>(str $s, int $repetition) returns str {
    nqp::if(nqp::islt_i($repetition, 0), '', nqp::x($s, $repetition))
}

multi sub infix:<cmp>(Str:D \a, Str:D \b) returns Order:D {
    ORDER(nqp::cmp_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<cmp>(str $a, str $b) returns Order:D {
    ORDER(nqp::cmp_s($a, $b))
}

multi sub infix:<===>(Str:D \a, Str:D \b) returns Bool:D {
    nqp::p6bool(nqp::iseq_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<===>(str $a, str $b) returns Bool:D {
    nqp::p6bool(nqp::iseq_s($a, $b))
}

multi sub infix:<leg>(Str:D \a, Str:D \b) returns Order:D {
    ORDER(nqp::cmp_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<leg>(str $a, str $b) returns Order:D {
    ORDER(nqp::cmp_s($a, $b))
}

multi sub infix:<eq>(Str:D \a, Str:D \b) returns Bool:D {
    nqp::p6bool(nqp::iseq_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<eq>(str $a, str $b) returns Bool:D {
    nqp::p6bool(nqp::iseq_s($a, $b))
}

multi sub infix:<lt>(Str:D \a, Str:D \b) returns Bool:D {
    nqp::p6bool(nqp::islt_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<lt>(str $a, str $b) returns Bool:D {
    nqp::p6bool(nqp::islt_s($a, $b))
}

multi sub infix:<le>(Str:D \a, Str:D \b) returns Bool:D {
    nqp::p6bool(nqp::isle_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<le>(str $a, str $b) returns Bool:D {
    nqp::p6bool(nqp::isle_s($a, $b))
}

multi sub infix:<gt>(Str:D \a, Str:D \b) returns Bool:D {
    nqp::p6bool(nqp::isgt_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<gt>(str $a, str $b) returns Bool:D {
    nqp::p6bool(nqp::isgt_s($a, $b))
}

multi sub infix:<ge>(Str:D \a, Str:D \b) returns Bool:D {
    nqp::p6bool(nqp::isge_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<le>(str $a, str $b) returns Bool:D {
    nqp::p6bool(nqp::isle_s($a, $b))
}

multi sub infix:<~|>(Str:D \a, Str:D \b) returns Str:D {
    nqp::p6box_s(nqp::bitor_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<~|>(str $a, str $b) returns str { nqp::bitor_s($a, $b) }

multi sub infix:<~&>(Str:D \a, Str:D \b) returns Str:D {
    nqp::p6box_s(nqp::bitand_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<~&>(str $a, str $b) returns str { nqp::bitand_s($a, $b) }

multi sub infix:<~^>(Str:D \a, Str:D \b) returns Str:D {
    nqp::p6box_s(nqp::bitxor_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<~^>(str $a, str $b) returns str { nqp::bitxor_s($a, $b) }

multi sub prefix:<~^>(Str \a) {
    fail "prefix:<~^> NYI";   # XXX
}

multi sub infix:~>(Str:D \a, Int:D \b) returns Str:D {
    X::NYI.new(feature => "infix:~>").throw;
}
multi sub infix:~>(str $a, int $b) {
    X::NYI.new(feature => "infix:~>").throw;
}
multi sub infix:~<(Str:D \a, Int:D \b) returns Str:D {
    X::NYI.new(feature => "infix:~<").throw;
}
multi sub infix:~<(str $a, int $b) {
    X::NYI.new(feature => "infix:~<").throw;
}

multi sub ords(Str $s) returns List:D {
    my Int $c  = $s.chars;
    my str $ns = nqp::unbox_s($s);
    (^$c).map: { nqp::p6box_i(nqp::ord(nqp::substr($ns, $_, 1))) }
}

sub trim         (Str:D $s) returns Str:D { $s.trim }
sub trim-leading (Str:D $s) returns Str:D { $s.trim-leading }
sub trim-trailing(Str:D $s) returns Str:D { $s.trim-trailing }

proto sub UNBASE (|) { * }
multi sub UNBASE(Int:D $base, Cool:D $num) is hidden-from-backtrace {
    X::Numeric::Confused.new(:what($num)).throw;
}
multi sub UNBASE(Int:D $base, Str:D $str) is hidden-from-backtrace {
    my Str $prefix = substr($str,0, 2);
    if    $base <= 10 && $prefix eq any(<0x 0d 0o 0b>)
       or $base <= 24 && $prefix eq any <0o 0x>
       or $base <= 33 && $prefix eq '0x' {
        $str.Numeric;

    } else {
        ":{$base}<$str>".Numeric;
    }
}

sub UNBASE_BRACKET($base, @a) is hidden-from-backtrace {
    my $v = 0;
    my $denom = 1;
    my Bool $seen-dot = False;
    for @a {
        if $seen-dot {
            die "Only one decimal dot allowed" if $_ eq '.';
            $denom *= $base;
            $v += $_ / $denom
        }
        elsif $_ eq '.' {
            $seen-dot = True;
        }
        else {
            $v = $v * $base + $_;
        }
    }
    $v;
}

sub chrs(*@c) returns Str:D {
    @c.map({.chr}).join;
}

sub SUBSTR-START-OOR(\from,\max) {
    X::OutOfRange.new(
      :what<Start argument to substr>,
      :got(from),
      :range("0.." ~ max),
      :comment( nqp::istype(from, Callable) || -from > max
        ?? ''
        !! "use *{from} if you want to index relative to the end"),
    );
}
sub SUBSTR-CHARS-OOR(\chars) {
    X::OutOfRange.new(
      :what<Number of characters argument to substr>,
      :got(chars),
      :range("0..Inf"),
      :comment("use *{chars} if you want to index relative to the end"),
    );
}
sub SUBSTR-SANITY(Str \what, $start, $want, \from, \chars) is hidden-from-backtrace {
    my Int $max := what.chars;
    from = nqp::istype($start, Callable) ?? $start($max) !! $start.Int;
    SUBSTR-START-OOR(from,$max).fail
      if from < 0 || from > $max;

    chars = $want.defined
      ?? $want === Inf
        ?? $max - from
        !! nqp::istype($want,Callable)
          ?? $want($max - from)
          !! (nqp::istype($want,Int) ?? $want !! $want.Int)
      !! $max - from;
    chars < 0 ?? SUBSTR-CHARS-OOR(chars).fail !! 1;
}

proto sub substr(|) { * }
multi sub substr(Str:D \what, Int:D \start) {
    my str $str  = nqp::unbox_s(what);
    my int $max  = nqp::chars($str);
    my int $from = nqp::unbox_i(start);

    SUBSTR-START-OOR($from,$max).fail
      if nqp::islt_i($from,0) || nqp::isgt_i($from,$max);

    nqp::p6box_s(nqp::substr($str,$from));
}
multi sub substr(Str:D \what, Callable:D \start) {
    my str $str  = nqp::unbox_s(what);
    my int $max  = nqp::chars($str);
    my int $from = nqp::unbox_i((start)(nqp::p6box_i($max)));

    SUBSTR-START-OOR($from,$max).fail
      if nqp::islt_i($from,0) || nqp::isgt_i($from,$max);

    nqp::p6box_s(nqp::substr($str,$from));
}
multi sub substr(Str:D \what, Int:D \start, Int:D \want) {
    my str $str   = nqp::unbox_s(what);
    my int $max   = nqp::chars($str);
    my int $from  = nqp::unbox_i(start);

    SUBSTR-START-OOR($from,$max).fail
     if nqp::islt_i($from,0) || nqp::isgt_i($from,$max);

    my int $chars = nqp::unbox_i(want);
    SUBSTR-CHARS-OOR($chars).fail
      if nqp::islt_i($chars,0);

    nqp::p6box_s(nqp::substr($str,$from,$chars));
}
multi sub substr(Str() $what, \start, $want?) {

    # should really be int, but \ then doesn't work for rw access
    my $r := SUBSTR-SANITY($what, start, $want, my Int $from, my Int $chars);
    $r.defined
      ?? nqp::p6box_s(nqp::substr(
           nqp::unbox_s($what),nqp::unbox_i($from),nqp::unbox_i($chars)
         ))
      !! $r;
}

sub substr-rw(\what, \start, $want?) {
    my $Str := nqp::istype(what,Str) ?? what !! what.Str;
    
    # should really be int, but \ then doesn't work for rw access
    my $r := SUBSTR-SANITY($Str, start, $want, my Int $from, my Int $chars);
    $r.defined
      ?? Proxy.new(
           FETCH => sub ($) {
               nqp::p6box_s(nqp::substr(
                 nqp::unbox_s($Str), nqp::unbox_i($from), nqp::unbox_i($chars)
               ));
           },
           STORE => sub ($, $new) {
               my $str = nqp::unbox_s($Str);
               what = nqp::p6box_s(
                 nqp::concat(
                   nqp::substr($str,0,nqp::unbox_i($from)),
                   nqp::concat(
                     nqp::unbox_s($new),
                     nqp::substr($str,nqp::unbox_i($from + $chars))
                   )
                 )
               );
           },
         )
      !! $r;
}

sub TRANSPOSE(Str \string, Str \original, Str \final) {
    my str $str    = nqp::unbox_s(string);
    my int $chars  = nqp::chars($str);
    my str $needle = nqp::unbox_s(original);
    my int $skip   = nqp::chars($needle);
    my int $from;
    my int $to;
    my Mu  $parts := nqp::list_s();

    while $to < $chars {
        $to = nqp::index($str,$needle,$from);
        last if $to == -1;
        nqp::push_s($parts, $to > $from
              ?? nqp::substr($str,$from,$to - $from)
              !! ''
            );
        $to = $from = $to + $skip;
    }
    nqp::push_s( $parts, $from < $chars
      ?? nqp::substr($str,$from,$chars - $from)
      !! ''
    );

    nqp::elems($parts)
      ?? nqp::box_s(nqp::join(nqp::unbox_s(final),$parts),Str)
      !! string;
}

sub TRANSPOSE-ONE(Str \string, Str \original, Str \final) {
    my str $str     = nqp::unbox_s(string);
    my int $chars   = nqp::chars($str);
    my int $ordinal = ord(original);
    my int $from;
    my int $to;
    my $parts := nqp::list_s();

    while $to < $chars {
        if nqp::ordat($str,$to) == $ordinal {
            nqp::push_s($parts, $to > $from
              ?? nqp::substr($str,$from,$to - $from)
              !! ''
            );
            $from = $to + 1;
        }
        $to = $to + 1;
    }
    nqp::push_s( $parts, $from < $chars
      ?? nqp::substr($str,$from,$chars - $from)
      !! ''
    );

    nqp::elems($parts)
      ?? nqp::box_s(nqp::join(nqp::unbox_s(final),$parts),Str)
      !! string;
}


multi sub uniprop(|)  { die 'uniprop NYI on jvm backend' }
multi sub unibool(|)  { die 'unibool NYI on jvm backend' }
multi sub unival(|)   { die 'unival NYI on jvm backend' }
multi sub univals(|)  { die 'univals NYI on jvm backend' }
multi sub unimatch(|) { die 'unimatch NYI on jvm backend' }

my %propcodecache;
my %pvalcodecache;
proto sub uniname(|) {*}
multi sub uniname(Str $str) { uniname($str.ord) }
multi sub uniname(Int $code) { nqp::getuniname($code) }


# From 'src/core/Capture.pm'

my class Capture { # declared in BOOTSTRAP
    # class Capture is Any {
    #     has Mu $!list;   # positional parameters
    #     has Mu $!hash;   # named parameters

    method new(:@list,:%hash) {
        nqp::create(self).BUILD(:@list,:%hash);
    }

    method from-args(|c) { c }

    submethod BUILD(:@list, :%hash) {
        nqp::bindattr(self, Capture, '$!list',
            nqp::getattr(nqp::decont(@list.Parcel), Parcel, '$!storage')
        );
        my Mu $hs := nqp::getattr(nqp::decont(%hash), EnumMap, '$!storage');
        nqp::bindattr(self, Capture, '$!hash', nqp::ishash($hs) ?? $hs !! nqp::hash());
        self;
    }
    multi method WHICH (Capture:D:) {
        my $WHICH = self.^name;
        if $!list {
            $WHICH ~= '|';
            $WHICH ~= ( '(' ~ $_.WHICH ~ ')' )
              for $!list;
        }
        if $!hash {
            $WHICH ~= '|';
            $WHICH ~= ( $_ ~ '(' ~ nqp::atkey($!hash, nqp::unbox_s($_)).WHICH ~ ')' )
              for self.hash.keys.sort;
        }
        $WHICH;
    }

    multi method AT-KEY(Capture:D: \key) {
        my str $skey = nqp::unbox_s(key.Str);
        nqp::existskey($!hash,$skey) ?? nqp::atkey($!hash, $skey) !! Nil;
    }
    multi method AT-KEY(Capture:D: Str:D \key) {
        my str $skey = nqp::unbox_s(key);
        nqp::existskey($!hash,$skey) ?? nqp::atkey($!hash, $skey) !! Nil;
    }

    multi method AT-POS(Capture:D: int \pos) {
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i(pos,0);
        nqp::existspos($!list,pos) ?? nqp::atpos($!list,pos) !! Nil;
    }
    multi method AT-POS(Capture:D: Int:D \pos) {
        my int $pos = nqp::unbox_i(pos);
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i($pos,0);
        nqp::existspos($!list,$pos) ?? nqp::atpos($!list,$pos) !! Nil;
    }

    method hash(Capture:D:) {
        my $enum := nqp::create(EnumMap);
        nqp::bindattr($enum, EnumMap, '$!storage', $!hash);
        $enum;
    }

    multi method EXISTS-KEY(Capture:D: Str:D \key ) {
        nqp::p6bool(nqp::existskey($!hash, nqp::unbox_s(key)));
    }
    multi method EXISTS-KEY(Capture:D: \key ) {
        nqp::p6bool(nqp::existskey($!hash, nqp::unbox_s(key.Str)));
    }

    method list(Capture:D:) {
        nqp::p6list(nqp::clone($!list), List, Mu);
    }

    method elems(Capture:D:) {
        nqp::p6box_i(nqp::elems($!list))
    }

    multi method Str(Capture:D:) {
        my Mu $str := nqp::list_s();
        if $!list {
            my Mu $iter := nqp::iterator($!list);
            nqp::push_s($str, nqp::unbox_s(nqp::shift($iter).Str)) while $iter;
        }
        if $!hash {
            my Mu $iter := nqp::iterator($!hash);
            while $iter {
                my $kv := nqp::shift($iter);
                nqp::push_s($str, nqp::unbox_s((nqp::p6box_s($kv) => $kv.value).Str));
            }
        }
        nqp::p6box_s(nqp::join(' ', $str))
    }
    multi method gist(Capture:D:) { self.perl }
    multi method perl(Capture:D:) {
        my @list := self.list;
        my %hash := self.hash;
        if self.^name eq 'Capture' {
            "\\({
                join ', ', 
                    (@list[$_].perl for ^@list.elems),
                    %hash.sort.map( *.perl )
            })";
        } else {
            self.^name
              ~ '.new('
              ~ ( 'list => (' ~ (@list[$_].perl for ^@list.elems).join(', ') ~ ',)' if +@list)
              ~ (', ' if +@list and +%hash)
              ~ ( 'hash => {' ~ %hash.sort.map( *.perl ).join(', ') ~ '}' if +%hash)
              ~ ')';
        }
    }
    multi method Bool(Capture:D:) {
        $!list || $!hash ?? True !! False
    }

    method Capture(Capture:D:) {
        self
    }

    multi method Numeric(Capture:D:) {
        self.elems
    }

    method FLATTENABLE_LIST() { $!list ?? $!list !! nqp::list() }
    method FLATTENABLE_HASH() { $!hash ?? $!hash !! nqp::hash() }

    multi method keys(Capture:D:) {
        (self.list.keys, self.hash.keys).flat;
    }
    multi method kv(Capture:D:) {
        (self.list.kv, self.hash.kv).flat;
    }
    multi method values(Capture:D:) {
        (self.list.values, self.hash.values).flat;
    }
    multi method pairs(Capture:D:) {
        (self.list.pairs, self.hash.pairs).flat;
    }
    multi method antipairs(Capture:D:) {
        (self.list.antipairs, self.hash.antipairs).flat;
    }
}

multi sub infix:<eqv>(Capture $a, Capture $b) {
    $a.WHAT === $b.WHAT && $a.list eqv $b.list && $a.hash eqv $b.hash
}

# From 'src/core/Parcel.pm'

my class Parcel does Positional { # declared in BOOTSTRAP
    # class Parcel is Cool {
    #    has Mu $!storage;        # VM's array of Parcel's elements
    #    has Str $!WHICH;

    multi method new(|) {
        my Mu $args := nqp::p6argvmarray();
        nqp::shift($args);
        nqp::p6parcel($args, Nil)
    }

    multi method Bool(Parcel:D:)           { nqp::p6bool($!storage) }
    multi method Numeric(Parcel:D:)        { nqp::elems($!storage) }
    multi method Str(Parcel:D:)            { self.list.Str }

    multi method ACCEPTS(Parcel:D: $topic) {
        my $sseq = self.list;
        my $tseq = $topic.list;

        my int $spos = 0;
        my int $tpos = 0;
        while $spos < +$sseq {
            # if the next element is Whatever
            if nqp::istype($sseq[$spos],Whatever) {
                # skip over all of the Whatevers
                $spos = $spos + 1
                  while $spos <= +$sseq && nqp::istype($sseq[$spos],Whatever);
                # if nothing left, we're done
                return True if !($spos < +$sseq);
                # find a target matching our new target
                $tpos = $tpos + 1
                  while ($tpos < +$tseq) && $tseq[$tpos] !== $sseq[$spos];
                # return false if we ran out
                return False if !($tpos < +$tseq);
            }
            elsif $tpos >= +$tseq || $tseq[$tpos] !=== $sseq[$spos] {
                return False;
            }
            # skip matching elements
            $spos = $spos + 1;
            $tpos = $tpos + 1;
        }
        # If nothing left to match, we're successful.
        $tpos >= +$tseq;
    }


    multi method WHICH(Parcel:D:) {
        $!WHICH //= self.^name
          ~ '|'
          ~ (^self.elems).map( {'(' ~ self[$_].VAR.WHICH ~ ')'} ).join;
    }
    method Parcel()  { self }
    method Capture() {
        my $cap := nqp::create(Capture);
        my Mu $list := nqp::list();
        my Mu $hash := nqp::hash();
        my int $c = nqp::elems($!storage);
        my int $i = 0;
        while $i < $c {
            my $v := nqp::atpos($!storage, $i);
            nqp::istype($v, Pair) ??
                nqp::bindkey($hash, nqp::unbox_s($v.key), $v.value) !!
                nqp::push($list, $v);
            $i = $i + 1;
        }
        nqp::bindattr($cap, Capture, '$!list', $list);
        nqp::bindattr($cap, Capture, '$!hash', $hash);
        $cap
    }

    method elems() { nqp::elems($!storage) }
    method item()  { my $ = self }
    method flat()  { nqp::p6list(nqp::clone($!storage), List, Bool::True) }
    method list()  { nqp::p6list(nqp::clone($!storage), List, Mu) }
    method lol()   { nqp::p6list(nqp::clone($!storage), LoL, Mu) }
    method eager() { nqp::p6list(nqp::clone($!storage), List, Mu).eager }

    method reverse() {
        my Mu $reverse  := nqp::list();
        my Mu $original := nqp::clone($!storage);
        nqp::push($reverse, nqp::pop($original)) while $original;
        my $parcel := nqp::create(self.WHAT);
        nqp::bindattr($parcel, Parcel, '$!storage', $reverse);
        $parcel;
    }

    method rotate (Int $n is copy = 1) {
        my $elems := nqp::p6box_i(nqp::elems($!storage));
        return self if !$elems;

        $n %= $elems;
        return self if $n == 0;

        my Mu $storage := nqp::clone($!storage);
        if $n > 0 {
            nqp::push($storage, nqp::shift($storage)) while $n--;
        }
        elsif $n < 0 {
            nqp::unshift($storage, nqp::pop($storage)) while $n++;
        }
        my $parcel := nqp::create(self.WHAT);
        nqp::bindattr($parcel, Parcel, '$!storage', $storage);
        $parcel;
    }

    multi method EXISTS-POS(Parcel:D: int \pos) {
        nqp::p6bool(
          nqp::islt_i(pos,nqp::elems($!storage)) && nqp::isge_i(pos,0)
        );
    }
    multi method EXISTS-POS(Parcel:D: Int:D \pos) {
        pos < nqp::elems($!storage) && pos >= 0;
    }

    multi method AT-POS(Parcel:D: int \pos) is rw {
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i(pos,0);
        nqp::isge_i(pos,nqp::elems($!storage))
          ?? Nil
          !! nqp::atpos($!storage,pos);
    }
    multi method AT-POS(Parcel:D: Int:D \pos) is rw {
        my int $pos = nqp::unbox_i(pos);
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i($pos,0);
        nqp::isge_i($pos,nqp::elems($!storage))
          ?? Nil
          !! nqp::atpos($!storage,$pos);
    }

    multi method ASSIGN-POS(Parcel:D: int \pos, Mu \assignee) is rw {
        X::OutOfRange.new(
          :what<Index>,
          :got(pos),
          :range("0..{nqp::elems($!storage)-1}")
        ).throw
          if nqp::isge_i(pos,nqp::elems($!storage)) || nqp::islt_i(pos,0);
        nqp::atpos($!storage,pos) = assignee;
    }
    multi method ASSIGN-POS(Parcel:D: Int:D \pos, Mu \assignee) is rw {
        my int $pos = nqp::unbox_i(pos);
        X::OutOfRange.new(
          :what<Index>,
          :got(pos),
          :range("0..{nqp::elems($!storage)-1}")
        ).throw
          if nqp::isge_i($pos,nqp::elems($!storage)) || nqp::islt_i($pos,0);
        nqp::atpos($!storage,$pos) = assignee;
    }

    multi method gist(Parcel:D:) {
        my Mu $gist := nqp::list();
        my Mu $iter := nqp::iterator($!storage);
        nqp::push($gist, nqp::unbox_s(nqp::shift($iter).gist)) while $iter;
        nqp::p6box_s(nqp::join(' ', $gist))
    }

    multi method perl(Parcel:D \SELF:) {
        my Mu $rpa := nqp::clone($!storage);
        my $perl = nqp::iscont(SELF) ?? '$(' !! '(';
        if $rpa {
            $perl = $perl ~ nqp::shift($rpa).perl;
            if $rpa {
                $perl = $perl ~ ', ' ~ nqp::shift($rpa).perl while $rpa;
            }
            else {
                $perl = $perl ~ ',';
            }
            $perl ~ ')'
        }
        # because $() is *NOT* a Parcel but short for "$( $/.made // Str($/) )"
        elsif nqp::iscont(SELF) {
            $perl ~ ' )'
        }
        else {
            $perl ~ ')'
        }
    }

    method STORE(|) {
        # get the list of rvalues to store and lhs containers
        my Mu $args := nqp::p6argvmarray();
        nqp::shift($args);
        my $rhs := nqp::p6list($args, List, Bool::True);

        # first pass -- scan lhs containers and pick out
        # scalar versus list assignment.  This also reifies
        # the rhs values
        my Mu $lhs := nqp::clone($!storage);
        my Mu $tv := nqp::list();
        while ($lhs) {
            my Mu \x := nqp::shift($lhs);
            if nqp::iscont(x) {
                # container: scalar assignment
                nqp::push($tv, x);
                nqp::push($tv, $rhs.gimme(1) ?? nqp::decont($rhs.shift) !! Nil);
            }
            elsif nqp::istype(x, Whatever) {
                # Whatever: skip assigning value
                $rhs.shift;
            }
            elsif nqp::istype(x, Parcel) {
                # Parcel: splice into current lhs
                nqp::splice($lhs, nqp::getattr(x, Parcel, '$!storage'), 0, 0)
            }
            else {
                # store entire rhs
                nqp::push($tv, x);
                nqp::push($tv, $rhs);
                $rhs := ().list;
            }
        }

        # second pass, perform the assignments
        while ($tv) { my \x := nqp::shift($tv); x = nqp::shift($tv); }
        self
    }

    multi method DUMP(Parcel:D: :$indent-step = 4, :%ctx?) {
        return DUMP(self, :$indent-step) unless %ctx;

        my Mu $attrs := nqp::list();
        nqp::push($attrs, '$!storage');
        nqp::push($attrs,  $!storage );
        self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx);
    }

    method FLATTENABLE_LIST() { $!storage }
    method FLATTENABLE_HASH() { nqp::hash() }

    method fmt($format = '%s', $separator = ' ') {
        self.list.fmt($format, $separator);
    }
}


my sub infix:<,>(|) is pure {
    nqp::p6parcel(nqp::p6argvmarray(), nqp::null());
}

# From 'src/core/Iterable.pm'

my class Iterable { # declared in BOOTSTRAP
    # class Iterable is Any {

    method elems()    { self.list.elems }
    method item($self:) { $self }

    method fmt($format = '%s', $separator = ' ') {
        self.list.fmt($format, $separator)
    }

    method Int()      { self.elems }
    method Num()      { self.elems.Num }
    multi method Numeric(Iterable:D:)  { self.elems }
    multi method Str(Iterable:D:)      { self.list.Str }
}

# From 'src/core/Iterator.pm'

my class Iterator { # declared in BOOTSTRAP
    # class Iterator is Iterable {

    method iterator() { nqp::decont(self) }
}

# From 'src/core/Nil.pm'

my class Nil is Cool { # declared in BOOTSTRAP
    # class Nil is Iterator {

    method new(*@) { Nil }
    method iterator(*@) { self }
    method reify($n) { () }
    method gist(*@) { 'Nil' }
    method Str(*@) { '' }       # XXX still needs warning
    method sink(*@) { Nil }     # required by RESTRICTED setting

    method AT-POS(*@)     { Nil }
    method AT-KEY(*@)     { Nil }
#    method ACCEPTS(*@)    { Nil }  # XXX spec says Nil, but makes spectest hang

    method BIND-POS(*@)   { die "Attempted to BIND-POS to Nil." }
    method BIND-KEY(*@)   { fail X::Bind.new(target => 'Nil') }
    method ASSIGN-POS(*@) { die "Attempted to ASSIGN-POS to Nil." }
    method ASSIGN-KEY(*@) { die "Attempted to ASSIGN-KEY to Nil." }
    method STORE(*@)      { die "Attempted to STORE to Nil." }
    method push(*@)       { die "Attempted to push to Nil." }
    method unshift(*@)    { die "Attempted to unshift to Nil." }
}

Nil.^add_fallback(
    -> $, $name { True },
    -> $, $name {
        anon sub (|) { Nil }
    }
);

# From 'src/core/Range.pm'

my class X::Range::InvalidArg { ... }

my class Range is Iterable is Cool does Positional {
    has $.min;
    has $.max;
    has $.excludes-min;
    has $.excludes-max;

    proto method new(|) { * }
    # The order of "method new" declarations matters here, to ensure
    # appropriate candidate tiebreaking when mixed type arguments
    # are present (e.g., Range,Whatever or Real,Range).
    multi method new(Range $min, $max, :$excludes-min, :$excludes-max) {
        X::Range::InvalidArg.new(:got($min)).throw;
    }
    multi method new($min, Range $max, :$excludes-min, :$excludes-max) {
        X::Range::InvalidArg.new(:got($max)).throw;
    }
    multi method new(Whatever $min, Whatever $max, :$excludes-min, :$excludes-max) {
        nqp::create(self).BUILD(-Inf, Inf, $excludes-min, $excludes-max)
    }
    multi method new(Whatever $min, $max, :$excludes-min, :$excludes-max) {
        nqp::create(self).BUILD(-Inf, $max, $excludes-min, $excludes-max)
    }
    multi method new($min, Whatever $max, :$excludes-min, :$excludes-max) {
        nqp::create(self).BUILD($min, Inf, $excludes-min, $excludes-max)
    }
    multi method new(Real $min, $max, :$excludes-min, :$excludes-max) {
        nqp::create(self).BUILD($min, $max.Real, $excludes-min, $excludes-max)
    }
    multi method new($min is copy, $max, :$excludes-min, :$excludes-max) {
        $min = +$min
          if nqp::istype($min,List) || nqp::istype($min,Match) || nqp::istype($min,Parcel);
        nqp::create(self).BUILD($min, $max, $excludes-min, $excludes-max)
    }

    submethod BUILD($min, $max, $excludes-min, $excludes-max) {
        $!min = $min;
        $!max = $max;
        $!excludes-min = $excludes-min.Bool;
        $!excludes-max = $excludes-max.Bool;
        self;
    }

    multi method WHICH (Range:D:) {
        self.^name
          ~ "|$!min"
          ~ ("^" if $!excludes-min)
          ~ '..'
          ~ ("^" if $!excludes-max)
          ~ $!max;
    }

    multi method infinite(Range:D:) {
        nqp::p6bool(nqp::istype($!max, Num)) && $!max eq 'Inf';
    }

    method flat()     { nqp::p6list(nqp::list(self), List, Bool::True) }
    method iterator() { self }
    method list()     { self.flat }

    method bounds()   { ($!min, $!max) }

    multi method ACCEPTS(Range:D: Mu \topic) {
        (topic cmp $!min) > -(!$!excludes-min)
            and (topic cmp $!max) < +(!$!excludes-max)
    }

    multi method ACCEPTS(Range:D: Range \topic) {
        (topic.min > $!min
         || topic.min == $!min
            && !(!topic.excludes-min && $!excludes-min))
        &&
        (topic.max < $!max
         || topic.max == $!max
            && !(!topic.excludes-max && $!excludes-max))
    }

    method reify($n) {
        my $value = $!excludes-min ?? $!min.succ !! $!min;
        # Iterating a Str range delegates to iterating a sequence.
        if Str.ACCEPTS($value) {
            return $value after $!max
                     ?? ()
                     !! SEQUENCE($value, $!max, :exclude_end($!excludes-max)).iterator.reify($n)
        }
        my $count;
        if nqp::istype($n, Whatever) {
            $count = self.infinite ?? 10 !! Inf;
        }
        else {
            $count = $n.Num max 1024e0;
            fail "request for infinite elements from range"
              if $count == Inf && self.infinite;
        }
        my $cmpstop = $!excludes-max ?? 0 !! 1;
        my $realmax = nqp::istype($!min, Numeric) && !nqp::istype($!max, Callable) && !nqp::istype($!max, Whatever)
                      ?? $!max.Numeric
                      !! $!max;

        # Pre-size the buffer, to avoid reallocations.
        my Mu $rpa := nqp::list();
        nqp::setelems($rpa, $count == Inf ?? 256 !! $count.Int);
        nqp::setelems($rpa, 0);

        if nqp::istype($value, Int) && nqp::istype($!max, Int) && !nqp::isbig_I(nqp::decont $!max)
           || nqp::istype($value, Num) {
            # optimized for int/num ranges
            $value = $value.Num;
            my $max = $!max.Num;
            my $box_int = nqp::p6bool(nqp::istype($!min, Int));
            my num $nvalue = $value;
            my num $ncount = $count;
            my num $nmax = $max;
            my int $icmpstop = $cmpstop;
            my int $ibox_int = $box_int;
            nqp::while(
                (nqp::isgt_n($ncount, 0e0) && nqp::islt_i(nqp::cmp_n($nvalue, $nmax), $icmpstop)),
                nqp::stmts(
                    nqp::push($rpa, $ibox_int
                        ?? nqp::p6box_i($nvalue)
                        !! nqp::p6box_n($nvalue)),
                    ($nvalue = nqp::add_n($nvalue, 1e0)),
                    ($ncount = nqp::sub_n($ncount, 1e0))
                ));
            $value = nqp::p6box_i($nvalue);
        }
        else {
          SEQ(nqp::push($rpa, $value++); $count--)
              while $count > 0 && ($value cmp $realmax) < $cmpstop;
        }
        if ($value cmp $!max) < $cmpstop {
            nqp::push($rpa,
                ($value.succ cmp $!max < $cmpstop)
                   ?? nqp::create(self).BUILD($value, $!max, 0, $!excludes-max)
                   !! $value);
        }
        nqp::p6parcel($rpa, nqp::null());
    }

    multi method AT-POS(Range:D: int \pos) {
        self.flat.AT-POS(pos);
    }
    multi method AT-POS(Range:D: Int:D \pos) {
        self.flat.AT-POS(nqp::unbox_i(pos));
    }

    multi method perl(Range:D:) {
        $.min.perl
          ~ ('^' if $.excludes-min)
          ~ '..'
          ~ ('^' if $.excludes-max)
          ~ $.max.perl
    }

    proto method roll(|) { * }
    multi method roll(Range:D: Whatever) {
        gather loop { take self.roll }
    }
    multi method roll(Range:D:) {
        return self.list.roll unless nqp::istype($!min, Int) && nqp::istype($!max, Int);
        my Int:D $least = $!excludes-min ?? $!min + 1 !! $!min;
        my Int:D $elems = 1 + ($!excludes-max ?? $!max - 1 !! $!max) - $least;
        $elems ?? ($least + nqp::rand_I(nqp::decont($elems), Int)) !! Any;
    }
    multi method roll(Int(Cool) $num) {
        return self.list.roll($num) unless nqp::istype($!min, Int) && nqp::istype($!max, Int);
        return self.roll if $num == 1;
        my int $n = nqp::unbox_i($num);
        gather loop (my int $i = 0; $i < $n; $i = $i + 1) {
            take self.roll;
        }
    }

    proto method pick(|)        { * }
    multi method pick()          { self.roll };
    multi method pick(Whatever)  { self.list.pick(*) };
    multi method pick(Int(Cool) $n) {
        return self.list.pick($n) unless nqp::istype($!min, Int) && nqp::istype($!max, Int);
        return self.roll if $n == 1;
        my Int:D $least = $!excludes-min ?? $!min + 1 !! $!min;
        my Int:D $elems = 1 + ($!excludes-max ?? $!max - 1 !! $!max) - $least;
        return self.list.pick($n) unless $elems > 3 * $n;
        my %seen;
        my int $i_n = nqp::unbox_i($n);
        gather while $i_n > 0 {
            my Int $x = $least + nqp::rand_I(nqp::decont($elems), Int);
            unless %seen{$x} {
                %seen{$x} = 1;
                $i_n = $i_n - 1;
                take $x;
            }
        }
    }

    multi method Numeric (Range:D:) {
        nextsame unless nqp::istype($.max,Numeric) && nqp::istype($.min,Numeric);

        my $diff := $.max - $.min - $.excludes-min;

        # empty range
        return 0 if $diff < 0;

        my $floor := $diff.floor;
        return $floor + 1 - ($floor == $diff ?? $.excludes-max !! 0);
    }

    method excludes_min() { DEPRECATED('excludes-min', |<2014.12 2015.12>); $!excludes-min }
    method excludes_max() { DEPRECATED('excludes-max', |<2014.12 2015.12>); $!excludes-max }
}

sub infix:<..>($min, $max) {
    Range.new($min, $max)
}
sub infix:<^..>($min, $max) {
    Range.new($min, $max, :excludes-min)
}
sub infix:<..^>($min, $max) {
    Range.new($min, $max, :excludes-max)
}
sub infix:<^..^>($min, $max) is pure {
    Range.new($min, $max, :excludes-min, :excludes-max)
}
sub prefix:<^>($max) {
    Range.new(0, $max.Numeric, :excludes-max)
}

multi sub infix:<eqv>(Range:D \a, Range:D \b) {
       a.min eqv b.min
    && a.max eqv b.max
    && a.excludes-min eqv b.excludes-min
    && a.excludes-max eqv b.excludes-max
}

# From 'src/core/ListIter.pm'

my class List { ... }

my class ListIter { # declared in BOOTSTRAP
    # class ListIter is Iterator {
    #   has Mu $!reified;      # return value for already-reified iterator
    #   has Mu $!nextiter;     # next iterator in sequence, if any
    #   has Mu $!rest;         # VM's array of elements remaining to be reified
    #   has Mu $!list;         # List object associated with this iterator

    method reify($n, :$sink) {
        unless nqp::isconcrete($!reified) {
            my $eager := nqp::p6bool(nqp::istype($n, Whatever));
            my $flattens := nqp::p6bool(nqp::isconcrete($!list)) && $!list.flattens;
            my int $max = 100_000;
            my int $count;
            my $rpa := nqp::list();
            if $eager {
                $count = $max;
                nqp::setelems($rpa, 5);  # this number is highly speculative
            }
            else {
                $count = nqp::unbox_i(nqp::istype($n, Int) ?? $n !! $n.Int);
                $max = $count if $count > $max;
                nqp::setelems($rpa, $count);
            }
            nqp::setelems($rpa, 0);
            my int $index;
            my $want_types := $flattens
                ?? nqp::list(Iterable, Parcel)
                !! nqp::list(Iterable);
            nqp::p6shiftpush($rpa, $!rest, nqp::elems($!rest))
                if nqp::istype($!list, LoL);
            while $!rest && (nqp::elems($rpa) < $count) {
                $index = nqp::p6arrfindtypes($!rest, $want_types, 0, $max);
                nqp::p6shiftpush($rpa, $!rest, $index);
                if $!rest && (nqp::elems($rpa) < $count) {
                    my Mu $x := nqp::shift($!rest);
                    if nqp::isconcrete($x) {
                        SEQ(nqp::unshift($!rest, $x); last) if $eager && $x.infinite;
                        $x := $x.iterator.reify(
                                  $eager
                                    ?? Whatever
                                    !! nqp::p6box_i($count - nqp::elems($rpa)),
                                  :$sink)
                            if nqp::istype($x, Iterable);
                        nqp::splice($!rest, nqp::getattr($x, Parcel, '$!storage'), 0, 0);

                    }
                    elsif nqp::not_i(nqp::istype($x, Nil)) {
                        nqp::push($rpa, $x);
                    }
                }
            }
            my $reified := nqp::p6parcel($rpa, Any);
            nqp::bindattr(self, ListIter, '$!nextiter', nqp::p6listiter($!rest, $!list))
                if $!rest;
            $reified := $!list.REIFY($reified, $!nextiter) if nqp::isconcrete($!list);
            nqp::push( nqp::getattr($reified, Parcel, '$!storage'), $!nextiter)
                if $!rest;
            nqp::bindattr(self, ListIter, '$!reified', $reified);
            # free up $!list and $!rest
            nqp::bindattr(self, ListIter, '$!list', Mu);
            nqp::bindattr(self, ListIter, '$!rest', Mu);
        }
        $!reified;
    }

    multi method infinite(ListIter:D:) {
        $!rest
          ?? nqp::istype(nqp::atpos($!rest, 0), Iterable)
             && nqp::atpos($!rest,0).infinite
             || Nil
          !! False
    }

    method iterator() { self }
    method nextiter() { $!nextiter }

    multi method DUMP(ListIter:D: :$indent-step = 4, :%ctx?) {
        return DUMP(self, :$indent-step) unless %ctx;

        my $flags    := ("\x221e" if self.infinite);
        my Mu $attrs := nqp::list();
        nqp::push($attrs, '$!list'    );
        nqp::push($attrs,  $!list     );
        nqp::push($attrs, '$!reified' );
        nqp::push($attrs,  $!reified  );
        nqp::push($attrs, '$!nextiter');
        nqp::push($attrs,  $!nextiter );
        nqp::push($attrs, '$!rest'    );
        nqp::push($attrs,  $!rest     );
        self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx, :$flags);
    }
}

# From 'src/core/MapIter.pm'

my class MapIter is Iterator {
    has $!reified;             # Parcel we return after reifying
    has Mu $!listiter;         # the list we're consuming
    has Mu $!flattens;         # flag to flatten input list
    has $!block;               # the block we're applying
    has $!first;               # Is this the first iterator in the sequence?
    has Mu $!items;            # reified items we haven't consumed yet
    has Mu $!label;            # The label that might be attached to us

    method new($list, $block, Mu $flattens = Bool::True, :$label) {
        nqp::create(self).BUILD(
          nqp::p6listiter(nqp::list(nqp::decont($list)), self),
          $block, $flattens, True, :$label);
    }

    submethod BUILD(Mu \listiter, \block, Mu \flattens, $first, :$label) {
        nqp::bindattr(listiter, ListIter, '$!list', self)
          if nqp::isconcrete(listiter);
        $!listiter := listiter;
        $!block = block;
        $!first = $first;
        $!flattens = flattens;
        $!label := $label;
        self
    }

    method flattens() { $!flattens }

    method reify($n, :$sink) {
        unless nqp::isconcrete($!reified) {
            my $argc   := $!block.count;
            $argc := 1 if $argc < 1 || $argc == Inf;
            my $block  := nqp::decont($!block);
            my Mu $rpa := nqp::list();

            if $!first {
                $!items := nqp::list();
                nqp::p6setfirstflag($block)
                  if (nqp::can($block, 'phasers') && $block.phasers('FIRST'));
            }

            my $count := $n;
            if nqp::istype($count, Whatever) {
                $!listiter.reify($argc)
                if $!listiter && nqp::elems($!items) < $argc;
                $count := (nqp::elems($!items) / $argc).floor;
                $count := 1 if $count < 1;
                $count := 100000 if $count > 100000;
            }

            my int $NEXT        = nqp::can($block, 'fire_phasers')
                                  && +$block.phasers('NEXT');
            my int $is_sink     = $sink ?? 1 !! 0;
            my int $did_iterate = 0;
            my Mu $label       := $!label;

            my int $state = 1;
            my int $itmp;
            my Mu $items := $!items;
            my Mu $args := nqp::list();
            my Mu $arg;

            # Pre-size (set to count we want, then back to zero, which leaves
            # the backing array at $count).
            nqp::setelems($rpa, $count min 1024) unless $sink;
            nqp::setelems($rpa, 0);

            if $argc == 1 && !$NEXT {
                # Fast path case: only 1 argument for each block, no NEXT phaser.
                $!label ??
                nqp::while(($state && nqp::islt_i(nqp::elems($rpa), $count)), nqp::handle(
                    nqp::stmts(
                        nqp::if(nqp::iseq_i($state, 1), nqp::stmts(
                            nqp::unless(nqp::elems($items), nqp::stmts(
                                nqp::if($!listiter, $!listiter.reify(1))
                            )),
                            nqp::if($items,
                                nqp::stmts(($arg := nqp::shift($items)), $state = 2),
                                $state = 0)
                        )),
                        nqp::if(nqp::iseq_i($state, 2), nqp::stmts(
                            ($sink ?? SEQ($did_iterate = 1; $block($arg))
                                   !! nqp::push($rpa, $block($arg))),
                            $state = 1
                        ))
                    ),
                    'LABELED', nqp::decont($label),
                    'LAST', nqp::stmts(
                        ($!items := Any),
                        ($!listiter := Any),
                        ($state = 0)
                    ),
                    'REDO', $state = 2,
                    'NEXT', $state = 1
                )) !!
                nqp::while(($state && nqp::islt_i(nqp::elems($rpa), $count)), nqp::handle(
                    nqp::stmts(
                        nqp::if(nqp::iseq_i($state, 1), nqp::stmts(
                            nqp::unless(nqp::elems($items), nqp::stmts(
                                nqp::if($!listiter, $!listiter.reify(1))
                            )),
                            nqp::if($items,
                                nqp::stmts(($arg := nqp::shift($items)), $state = 2),
                                $state = 0)
                        )),
                        nqp::if(nqp::iseq_i($state, 2), nqp::stmts(
                            ($sink ?? SEQ($did_iterate = 1; $block($arg))
                                   !! nqp::push($rpa, $block($arg))),
                            $state = 1
                        ))
                    ),
                    'LAST', nqp::stmts(
                        ($!items := Any),
                        ($!listiter := Any),
                        ($state = 0)
                    ),
                    'REDO', $state = 2,
                    'NEXT', $state = 1
                ));
            }
            else {
                $!label ??
                nqp::while(($state && nqp::islt_i(nqp::elems($rpa), $count)), nqp::handle(
                    nqp::stmts(
                        nqp::if(nqp::iseq_i($state, 1), nqp::stmts(
                            ($itmp = nqp::elems($items)),
                            nqp::unless($itmp >= $argc, nqp::stmts(
                                ($itmp = $argc - $itmp),
                                nqp::if($!listiter, $!listiter.reify($itmp))
                            )),
                            nqp::setelems($args, 0),
                            nqp::p6shiftpush($args, $items, $argc),
                            nqp::if($args, $state = 2, $state = 0)
                        )),
                        nqp::if(nqp::iseq_i($state, 2), nqp::stmts(
                            ($sink
                                ?? SEQ($did_iterate = 1; nqp::p6invokeflat($block, $args))
                                !! nqp::push($rpa, nqp::p6invokeflat($block, $args))),
                            $state = 3
                        )),
                        nqp::if(nqp::iseq_i($state, 3), nqp::stmts(
                            nqp::if($NEXT, $block.fire_phasers('NEXT')),
                            ($state = 1)
                        ))
                    ),
                    'LABELED', nqp::decont($label),
                    'LAST', nqp::stmts(
                        ($!items := Any),
                        ($!listiter := Any),
                        ($state = 0)
                    ),
                    'REDO', $state = 2,
                    'NEXT', $state = 3
                )) !!
                nqp::while(($state && nqp::islt_i(nqp::elems($rpa), $count)), nqp::handle(
                    nqp::stmts(
                        nqp::if(nqp::iseq_i($state, 1), nqp::stmts(
                            ($itmp = nqp::elems($items)),
                            nqp::unless($itmp >= $argc, nqp::stmts(
                                ($itmp = $argc - $itmp),
                                nqp::if($!listiter, $!listiter.reify($itmp))
                            )),
                            nqp::setelems($args, 0),
                            nqp::p6shiftpush($args, $items, $argc),
                            nqp::if($args, $state = 2, $state = 0)
                        )),
                        nqp::if(nqp::iseq_i($state, 2), nqp::stmts(
                            ($sink
                                ?? SEQ($did_iterate = 1; nqp::p6invokeflat($block, $args))
                                !! nqp::push($rpa, nqp::p6invokeflat($block, $args))),
                            $state = 3
                        )),
                        nqp::if(nqp::iseq_i($state, 3), nqp::stmts(
                            nqp::if($NEXT, $block.fire_phasers('NEXT')),
                            ($state = 1)
                        ))
                    ),
                    'LAST', nqp::stmts(
                        ($!items := Any),
                        ($!listiter := Any),
                        ($state = 0)
                    ),
                    'REDO', $state = 2,
                    'NEXT', $state = 3
                ));
            }

            if $!items || $!listiter {
                my $nextiter := nqp::create(self).BUILD($!listiter, $!block, $!flattens, False, :$!label);
                nqp::bindattr($nextiter, MapIter, '$!items', $!items);
                nqp::push($rpa, $nextiter);
            }
            elsif ($did_iterate || nqp::elems($rpa) || $rpa) && nqp::can($block, 'fire_phasers') {
                $block.fire_phasers('LAST');
            }

            $!reified := nqp::p6parcel($rpa, nqp::null());
            # release references to objects we no longer need/own
            $!items := Any;
            $!listiter := Any;
            $!block := Any;

        }
        $!reified;
    }

    method REIFY(Parcel \parcel, Mu \nextiter) {
        nqp::splice($!items, nqp::getattr(parcel, Parcel, '$!storage'),
                    nqp::elems($!items), 0);
        $!listiter := nextiter;
        parcel
    }

    multi method DUMP(MapIter:D: :$indent-step = 4, :%ctx?) {
        return DUMP(self, :$indent-step) unless %ctx;

        my Mu $attrs := nqp::list();
        nqp::push($attrs, '$!flattens');
        nqp::push($attrs,  $!flattens );
        nqp::push($attrs, '$!first'   );
        nqp::push($attrs,  $!first    );
        nqp::push($attrs, '$!reified' );
        nqp::push($attrs,  $!reified  );
        nqp::push($attrs, '$!items'   );
        nqp::push($attrs,  $!items    );
        nqp::push($attrs, '$!listiter');
        nqp::push($attrs,  $!listiter );
        nqp::push($attrs, '$!block'   );
        nqp::push($attrs,  $!block    );
        self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx);
    }
}

# From 'src/core/GatherIter.pm'

class GatherIter is Iterator {
    has Mu $!coro;             # coroutine to execute for more pairs
    has $!reified;             # Parcel of this iterator's results
    has $!infinite;            # true if iterator is known infinite

    my $GATHER_PROMPT = Mu.new;
    my $SENTINEL := Mu.new;
    method new($block, Mu :$infinite) {
        my Mu $takings;
        my Mu $state;
        my &yield := {
            nqp::continuationcontrol(0, $GATHER_PROMPT, -> Mu \c { $state := c; });
        }
        $state := {
            nqp::handle( $block(),
                'TAKE', SEQ($takings := nqp::getpayload(nqp::exception()); yield(); nqp::resume(nqp::exception())));
            $takings := $SENTINEL; yield();
        };
        my $coro := { nqp::continuationreset($GATHER_PROMPT, $state); $takings };
        my Mu $new := nqp::create(self);
        nqp::bindattr($new, GatherIter, '$!coro', $coro);
        nqp::bindattr($new, GatherIter, '$!infinite', $infinite);
        $new;
    }

    multi method DUMP(GatherIter:D: :$indent-step = 4, :%ctx?) {
        return DUMP(self, :$indent-step) unless %ctx;

        my $flags    := ("\x221e" if self.infinite);
        my Mu $attrs := nqp::list();
        nqp::push($attrs, '$!reified' );
        nqp::push($attrs,  $!reified  );
        nqp::push($attrs, '$!coro'    );
        nqp::push($attrs,  $!coro     );
        self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx, :$flags);
    }

    method reify($n) {
        if !$!reified.defined {
            my Mu $rpa := nqp::list();
            my Mu $parcel;
            my int $end;
            my int $count =
              nqp::unbox_i(nqp::istype($n,Whatever) ?? 1000 !! $n);
            while nqp::not_i($end) && nqp::isgt_i($count,0) {
                $parcel := $!coro();
                $end = nqp::eqaddr($parcel, $SENTINEL);
                nqp::push($rpa, $parcel) if nqp::not_i($end);
                $count = $count - 1;
            }
            nqp::push($rpa,
                nqp::p6bindattrinvres(
                    nqp::p6bindattrinvres(
                        nqp::create(self), GatherIter, '$!coro', $!coro),
                    GatherIter, '$!infinite', $!infinite))
                if nqp::not_i($end);
            $!reified := nqp::p6parcel($rpa, nqp::null());
        }
        $!reified
    }

    multi method infinite(GatherIter:D:) { $!infinite }

}


sub GATHER(\block, Mu :$infinite) {
    GatherIter.new( block, :$infinite ).list;
}

# From 'src/core/List.pm'

my class X::TypeCheck { ... }
my class X::Cannot::Infinite { ... }
my class X::Cannot::Empty { ... }
my role Supply { ... }

my sub combinations($n, $k) {
    my @result;
    my @stack;

    return ([],) unless $k;

    @stack.push(0);
    gather while @stack {
        my $index = @stack - 1;
        my $value = @stack.pop;

        while $value < $n {
            @result[$index++] = $value++;
            @stack.push($value);
            if $index == $k {
                take [@result];
                $value = $n;  # fake a last
            }
        }
    }
}

my sub permutations(Int $n) {
    $n == 1 ?? ( [0,] ) !!
    gather for ^$n -> $i {
        my @i = grep none($i), ^$n;
        take [$i, @i[@$_]] for permutations($n - 1);
    }
}

my class List does Positional { # declared in BOOTSTRAP
    # class List is Iterable is Cool
    #   has Mu $!items;        # VM's array of our reified elements
    #   has Mu $!flattens;     # true if this list flattens its parcels
    #   has Mu $!nextiter;     # iterator for generating remaining elements

    method new(|) {
        my Mu $args := nqp::p6argvmarray();
        nqp::shift($args);

        nqp::p6list($args, self.WHAT, Mu);
    }

    multi method Bool(List:D:)    { self.gimme(1).Bool }
    multi method Int(List:D:)     { self.elems }
    multi method end(List:D:)     { self.elems - 1 }
    multi method Numeric(List:D:) { self.elems }
    multi method Str(List:D:)     { self.join(' ') }

    # Pretend we're a Match assuming we're a list of Matches
    method to()         { self.elems ?? self[self.end].to !! Nil }
    method from()       { self.elems ?? self[0].from !! Nil }

    method fmt($format = '%s', $separator = ' ') {
        self.map({ .fmt($format) }).join($separator);
    }

    method flat() { self.flattens
                    ?? self
                    !! nqp::p6list(nqp::list(self), List, Bool::True)
    }
    method list() { self }
    method lol() {
        self.gimme(0);
        my Mu $rpa := nqp::clone($!items);
        nqp::push($rpa, $!nextiter) if $!nextiter.defined;
        nqp::p6list($rpa, LoL, Mu);
    }

    method flattens() { $!flattens }

    method Capture() {
        self.gimme(*);
        my $cap := nqp::create(Capture);
        nqp::bindattr($cap, Capture, '$!list', $!items);
        $cap
    }

    method Parcel() {
        my Mu $rpa := nqp::clone(nqp::p6listitems(self));
        nqp::push($rpa, $!nextiter) if $!nextiter.defined;
        nqp::p6parcel($rpa, Any);
    }

    method Supply(List:D:) { Supply.from-list(self) }

    multi method AT-POS(List:D: int \pos) is rw {
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i(pos,0);
        self.EXISTS-POS(pos) ?? nqp::atpos($!items,pos) !! Nil;
    }
    multi method AT-POS(List:D: Int:D \pos) is rw {
        my int $pos = nqp::unbox_i(pos);
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i($pos,0);
        self.EXISTS-POS($pos) ?? nqp::atpos($!items,$pos) !! Nil;
    }

    method eager() { self.gimme(*); self }

    method elems() {
        return 0 unless self.DEFINITE;
        return nqp::elems(nqp::p6listitems(self)) unless nqp::defined($!nextiter);
        # Get as many elements as we can.  If gimme stops before
        # reaching the end of the list, assume the list is infinite.
        my $n := self.gimme(*);
        nqp::defined($!nextiter) ?? Inf !! $n
    }

    multi method EXISTS-POS(List:D: int $pos) {
        return False if nqp::islt_i($pos,0);
        self.gimme($pos + 1);
        nqp::p6bool(
          nqp::not_i(nqp::isnull(nqp::atpos($!items,$pos)))
        );
    }
    multi method EXISTS-POS(List:D: Int:D $pos) {
        return False if $pos < 0;
        self.gimme($pos + 1);
        nqp::p6bool(
          nqp::not_i(nqp::isnull(nqp::atpos($!items,nqp::unbox_i($pos))))
        );
    }

    method gimme($n, :$sink) {
        return unless self.DEFINITE;
        # loop through iterators until we have at least $n elements
        my int $count = nqp::elems(nqp::p6listitems(self));
        if nqp::istype($n, Whatever) || nqp::istype($n, Num) && nqp::istrue($n == Inf) {
            while $!nextiter.DEFINITE && !$!nextiter.infinite {
                $!nextiter.reify(*, :$sink);
                $count = nqp::elems($!items);
            }
        }
        else {
            my int $target = $n.Int;
            while nqp::isconcrete($!nextiter) && $count < $target {
                $!nextiter.reify($target - $count, :$sink);
                $count = nqp::elems($!items);
            }
        }

        # return the number of elements we have now
        $count
    }

    multi method infinite(List:D:) { $!nextiter.infinite }

    method iterator() {
        # Return a reified ListIter containing our currently reified elements
        # and any subsequent iterator.
        my $iter := nqp::create(ListIter);
        nqp::bindattr($iter, ListIter, '$!nextiter', $!nextiter);
        nqp::bindattr($iter, ListIter, '$!reified', self.Parcel());
        $iter;
    }

    method munch($n is copy) {
        $n = 0 if $n < 0;
        $n = self.gimme($n) if nqp::not_i(nqp::istype($n, Int))
                               || nqp::not_i(nqp::islist($!items))
                               || nqp::islt_i(nqp::elems($!items), nqp::unbox_i($n));
        nqp::p6parcel(
            nqp::p6shiftpush(nqp::list(), $!items, nqp::unbox_i($n)),
            Any
        )
    }

    proto method pick(|) { * }
    multi method pick() {
        fail X::Cannot::Infinite.new(:action<.pick from>) if self.infinite;
        my $elems = self.elems;
        $elems ?? self.AT-POS($elems.rand.floor) !! Nil;
    }
    multi method pick($n is copy) {
        fail X::Cannot::Infinite.new(:action<.pick from>) if self.infinite;
        ## We use a version of Fisher-Yates shuffle here to
        ## replace picked elements with elements from the end
        ## of the list, resulting in an O(n) algorithm.
        my $elems = self.elems;
        return unless $elems;
        $n = Inf if nqp::istype($n, Whatever);
        $n = $elems if $n > $elems;
        return self.AT-POS($elems.rand.floor) if $n == 1;
        my Mu $rpa := nqp::clone($!items);
        my $i;
        my Mu $v;
        gather while $n > 0 {
            $i = nqp::rand_I(nqp::decont($elems), Int);
            $elems--; $n--;
            $v := nqp::atpos($rpa, nqp::unbox_i($i));
            # replace selected element with last unpicked one
            nqp::bindpos($rpa, nqp::unbox_i($i),
                         nqp::atpos($rpa, nqp::unbox_i($elems)));
            take-rw $v;
        }
    }

    method pop() is parcel {
        my $elems = self.gimme(*);
        fail X::Cannot::Infinite.new(:action<.pop from>) if $!nextiter.defined;
        $elems > 0
          ?? nqp::pop($!items)
          !! fail X::Cannot::Empty.new(:action<.pop>, :what(self.^name));
    }

    method shift() is parcel {
        # make sure we have at least one item, then shift+return it
        nqp::islist($!items) && nqp::existspos($!items, 0) || self.gimme(1)
          ?? nqp::shift($!items)
          !! fail X::Cannot::Empty.new(:action<.shift>, :what(self.^name));
    }

    my &list_push = multi method push(List:D: *@values) {
        fail X::Cannot::Infinite.new(:action<.push>, :what(self.^name))
          if @values.infinite;
        nqp::p6listitems(self);
        my $elems = self.gimme(*);
        fail X::Cannot::Infinite.new(:action<.push to>) if $!nextiter.DEFINITE;

        # push is always eager
        @values.gimme(*);

        # need type checks?
        my $of := self.of;

        unless $of =:= Mu {
            X::TypeCheck.new(
              operation => '.push',
              expected  => $of,
              got       => $_,
            ).throw unless nqp::istype($_, $of) for @values;
        }

        nqp::splice($!items,
                nqp::getattr(@values, List, '$!items'),
                $elems, 0);

        self;
    }

    multi method push(List:D: \value) {
        if nqp::iscont(value) || nqp::not_i(nqp::istype(value, Iterable)) && nqp::not_i(nqp::istype(value, Parcel)) {
            $!nextiter.DEFINITE && self.gimme(*);
            fail X::Cannot::Infinite.new(:action<.push to>)
              if $!nextiter.DEFINITE;
            nqp::p6listitems(self);
            nqp::istype(value, self.of)
                ?? nqp::push($!items, nqp::assign(nqp::p6scalarfromdesc(nqp::null), value))
                !! X::TypeCheck.new(
                      operation => '.push',
                      expected  => self.of,
                      got       => value,
                    ).throw;
            self
        }
        else {
            list_push(self, value)
        }
    }

    multi method unshift(List:D: \value) {
        if nqp::iscont(value) || !(nqp::istype(value, Iterable) || nqp::istype(value, Parcel)) {
            nqp::p6listitems(self);
            value.gimme(*) if nqp::istype(value, List); # fixes #121994
            nqp::istype(value, self.of)
                ?? nqp::unshift($!items, my $ = value)
                !! X::TypeCheck.new(
                      operation => '.push',
                      expected  => self.of,
                      got       => value,
                    ).throw;
            self
        }
        else {
            callsame();
        }
    }

    multi method unshift(List:D: *@values) {
        fail X::Cannot::Infinite.new(:action<.unshift>, :what(self.^name))
          if @values.infinite;
        nqp::p6listitems(self);

        # don't bother with type checks
        my $of := self.of;
        if ( $of =:= Mu ) {
            nqp::unshift($!items, @values.pop) while @values;
        }

        # we must check types
        else {
            while @values {
                my $value := @values.pop;
                if nqp::istype($value, $of) {
                    nqp::unshift($!items, $value);
                }

                # huh?
                else {
                    X::TypeCheck.new(
                      operation => '.unshift',
                      expected  => $of,
                      got       => $value,
                    ).throw;
                }
            }
        }

        self
    }

    method plan(List:D: |args) {
        nqp::p6listitems(self);
        my $elems = self.gimme(*);
        fail X::Cannot::Infinite.new(:action<.plan to>) if $!nextiter.defined;

#        # need type checks?
#        my $of := self.of;
#
#        unless $of =:= Mu {
#            X::TypeCheck.new(
#              operation => '.push',
#              expected  => $of,
#              got       => $_,
#            ).throw unless nqp::istype($_, $of) for @values;
#        }

        nqp::bindattr(self, List, '$!nextiter', nqp::p6listiter(nqp::list(args.list), self));
        Nil;
    }

    proto method roll(|) { * }
    multi method roll() {
        fail X::Cannot::Infinite.new(:action<.roll from>) if self.infinite;
        my $elems = self.elems;
        $elems ?? self.AT-POS($elems.rand.floor) !! Nil;
    }
    multi method roll($n is copy) {
        fail X::Cannot::Infinite.new(:action<.roll from>) if self.infinite;
        my $elems = self.elems;
        return unless $elems;
        $n = Inf if nqp::istype($n, Whatever);
        return self.AT-POS($elems.rand.floor) if $n == 1;

        gather while $n > 0 {
            take nqp::atpos($!items, nqp::unbox_i($elems.rand.floor.Int));
            $n--;
        }
    }

    method reverse() {
        self.gimme(*);
        fail X::Cannot::Infinite.new(:action<.reverse>) if $!nextiter.defined;
        my Mu $rev  := nqp::list();
        my Mu $orig := nqp::clone($!items);
        nqp::push($rev, nqp::pop($orig)) while $orig;
        my $rlist := nqp::create(self.WHAT);
        nqp::bindattr($rlist, List, '$!items', $rev);
        $rlist;
    }

    method rotate(Int $n is copy = 1) {
        self.gimme(*);
        fail X::Cannot::Infinite.new(:action<.rotate>) if $!nextiter.defined;
        my $items = nqp::p6box_i(nqp::elems($!items));
        return self if !$items;

        $n %= $items;
        return self if $n == 0;

        my Mu $res := nqp::clone($!items);
        if $n > 0 {
            nqp::push($res, nqp::shift($res)) while $n--;
        }
        elsif $n < 0 {
            nqp::unshift($res, nqp::pop($res)) while $n++;
        }
        my $rlist := nqp::create(self.WHAT);
        nqp::bindattr($rlist, List, '$!items', $res);
        $rlist;
    }

    method splice($offset = 0, $size?, *@values) {
        self.gimme(*);
        my $o = $offset;
        my $s = $size;
        my $elems = self.elems;
        $o = $o($elems) if nqp::istype($o, Callable);
        X::OutOfRange.new(
            what => 'offset argument to List.splice',
            got  => $offset,
            range => (0..^self.elems),
        ).fail if $o < 0;
        $s //= self.elems - ($o min $elems);
        $s = $s(self.elems - $o) if nqp::istype($s, Callable);
        X::OutOfRange.new(
            what => 'size argument to List.splice',
            got  => $size,
            range => (0..^(self.elems - $o)),
        ).fail if $s < 0;

        my @ret = self[$o..($o + $s - 1)];
        nqp::splice($!items,
                    nqp::getattr(@values.eager, List, '$!items'),
                    $o.Int, $s.Int);
        @ret;
    }

    method sort($by = &infix:<cmp>) {
        fail X::Cannot::Infinite.new(:action<.sort>) if self.infinite; #MMD?

        # Instead of sorting elements directly, we sort a Parcel of
        # indices from 0..^$list.elems, then use that Parcel as
        # a slice into self. This is for historical reasons: on
        # Parrot we delegate to RPA.sort. The JVM implementation
        # uses a Java collection sort. MoarVM has its sort algorithm
        # implemented in NQP.

        # nothing to do here
        my $elems := self.elems;
        return self if $elems < 2;

        # Range is currently optimized for fast Parcel construction.
        my $index := Range.new(0, $elems, :excludes-max).reify(*);
        my Mu $index_rpa := nqp::getattr($index, Parcel, '$!storage');

        # if $by.arity < 2, then we apply the block to the elements
        # for sorting.
        if ($by.?count // 2) < 2 {
            my $list = self.map($by).eager;
            nqp::p6sort($index_rpa, -> $a, $b { $list.AT-POS($a) cmp $list.AT-POS($b) || $a <=> $b });
        }
        else {
            my $list = self.eager;
            nqp::p6sort($index_rpa, -> $a, $b { $by($list.AT-POS($a), $list.AT-POS($b)) || $a <=> $b });
        }
        self[$index];
    }

    multi method ACCEPTS(List:D: $topic) { self }

    method uniq(|c) {
        DEPRECATED('unique', |<2014.11 2015.11>);
        self.unique(|c);
    }

    proto method unique(|) {*}
    multi method unique() {
        my $seen := nqp::hash();
        my str $target;
        gather for @.list {
            $target = nqp::unbox_s($_.WHICH);
            unless nqp::existskey($seen, $target) {
                nqp::bindkey($seen, $target, 1);
                take $_;
            }
        }
    }
    multi method unique( :&as!, :&with! ) {
        my @seen;  # should be Mu, but doesn't work in settings :-(
        my Mu $target;
        gather for @.list {
            $target = &as($_);
            if first( { with($target,$_) }, @seen ) =:= Nil {
                @seen.push($target);
                take $_;
            }
        };
    }
    multi method unique( :&as! ) {
        my $seen := nqp::hash();
        my str $target;
        gather for @.list {
            $target = &as($_).WHICH;
            unless nqp::existskey($seen, $target) {
                nqp::bindkey($seen, $target, 1);
                take $_;
            }
        }
    }
    multi method unique( :&with! ) {
        nextwith() if &with === &[===]; # use optimized version

        my @seen;  # should be Mu, but doesn't work in settings :-(
        my Mu $target;
        gather for @.list {
            $target := $_;
            if first( { with($target,$_) }, @seen ) =:= Nil {
                @seen.push($target);
                take $_;
            }
        }
    }

    my @secret;
    proto method squish(|) {*}
    multi method squish( :&as!, :&with = &[===] ) {
        my $last = @secret;
        my str $which;
        gather for @.list {
            $which = &as($_).Str;
            unless with($which,$last) {
                $last = $which;
                take $_;
            }
        }
    }
    multi method squish( :&with = &[===] ) {
        my $last = @secret;
        gather for @.list {
            unless with($_,$last) {
                $last = $_;
                take $_;
            }
        }
    }

    proto method rotor(|) {*}
    multi method rotor(1, 0) { self }
    multi method rotor($elems = 2, $overlap = 1) {
        X::OutOfRange.new(
            what => 'Overlap argument to List.rotor',
            got  => $overlap,
            range => (0 .. $elems - 1),
        ).fail unless 0 <= $overlap < $elems;
        X::OutOfRange.new(
            what => 'Elements argument to List.rotor',
            got  => $elems,
            range => (0 .. *),
        ).fail unless 0 <= $elems;

        my $finished = 0;
        gather while $finished + $overlap < self.gimme($finished + $elems) {
            take item self[$finished ..^ $finished + $elems];
            $finished += $elems - $overlap
        }
    }

    multi method gist(List:D:) {
        @(self).map( -> $elem {
            given ++$ {
                when 101 { '...' }
                when 102 { last }
                default  { $elem.gist }
            }
        } ).join: ' ';
    }
    multi method perl(List:D \SELF:) {
        self.gimme(*);
        (nqp::iscont(SELF) ?? '$' !! '') ~ self.Parcel.perl;
    }

    method REIFY(Parcel \parcel, Mu \nextiter) {
        nqp::splice($!items, nqp::getattr(parcel, Parcel, '$!storage'),
                    nqp::elems($!items), 0);
        nqp::bindattr(self, List, '$!nextiter', nextiter);
        parcel
    }

    method FLATTENABLE_LIST() { self.gimme(*); $!items }
    method FLATTENABLE_HASH() { nqp::hash() }

    multi method DUMP(List:D: :$indent-step = 4, :%ctx?) {
        return DUMP(self, :$indent-step) unless %ctx;

        my $flags    := ("\x221e" if self.infinite);
        my Mu $attrs := nqp::list();
        nqp::push($attrs, '$!flattens');
        nqp::push($attrs,  $!flattens );
        nqp::push($attrs, '$!items'   );
        nqp::push($attrs,  $!items    );
        nqp::push($attrs, '$!nextiter');
        nqp::push($attrs,  $!nextiter );
        self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx, :$flags);
    }

    multi method keys(List:D:) {
        self.values.map: { (state $)++ }
    }
    multi method kv(List:D:) {
        gather for self.values {
            take (state $)++;
            take-rw $_;
        }
    }
    multi method values(List:D:) {
        my Mu $rpa := nqp::clone(nqp::p6listitems(self));
        nqp::push($rpa, $!nextiter) if $!nextiter.defined;
        nqp::p6list($rpa, List, self.flattens);
    }
    multi method pairs(List:D:) {
        self.values.map: { (state $)++ => $_ }
    }
    multi method antipairs(List:D:) {
        self.values.map: { $_ => (state $)++ }
    }

    multi method invert(List:D:) {
        self.map({ nqp::decont(.value) => .key }).flat
    }

    method reduce(List: &with) {
        return unless self.DEFINITE;
        return self.values if self.elems < 2;
        if &with.count > 2 and &with.count < Inf {
            my $moar = &with.count - 1;
            my \vals = self.values;
            if try &with.prec<assoc> eq 'right' {
                my Mu $val = vals.pop;
                $val = with(|vals.splice(*-$moar,$moar), $val) while vals >= $moar;
                return $val;
            }
            else {
                my Mu $val = vals.shift;
                $val = with($val, |vals.splice(0,$moar)) while vals >= $moar;
                return $val;
            }
        }
        my $reducer = find-reducer-for-op(&with);
        $reducer(&with)(self) if $reducer;
    }

    method sink() {
        self.gimme(*, :sink) if self.DEFINITE && $!nextiter.DEFINITE;
        Nil;
    }

    # this is a remnant of a previous implementation of .push(), which
    # apparently is used by LoL.  Please remove when no longer necessary.
    method STORE_AT_POS(Int \pos, Mu \v) is rw {
        nqp::bindpos($!items, nqp::unbox_i(pos), v)
    }

    proto method combinations($?) {*}
    multi method combinations( Int $of ) {
        ([self[@$_]] for combinations(self.elems, $of).eager)
    }
    multi method combinations( Range $of = 0 .. * ) {
        gather for @$of {
            last if $_ > self.elems;
            take self.combinations($_);
        }
    }

    method permutations() {
        # need block on Moar because of RT#121830
        gather { take [self[@$_]] for permutations(self.elems).eager }
    }

    method CALL-ME(List:U: |c) {
        self.new(|c);
    }
}

sub EAGER(|) {
    nqp::p6list(nqp::p6argvmarray(), List, Bool::True).eager
}

sub flat(|) {
    nqp::p6list(nqp::p6argvmarray(), List, Bool::True)
}

sub list(|) {
    nqp::p6list(nqp::p6argvmarray(), List, Mu)
}

proto sub infix:<xx>(|)       { * }
multi sub infix:<xx>()        { fail "No zero-arg meaning for infix:<xx>" }
multi sub infix:<xx>(Mu \x)   { x }
multi sub infix:<xx>(Mu \x, Int() $n is copy, :$thunked!) {
    GatherIter.new({ take x.() while --$n >= 0; }, :infinite($n == Inf)).list
}
multi sub infix:<xx>(Mu \x, Whatever, :$thunked!) {
    GatherIter.new({ loop { take x.() } }, :infinite(True)).list
}
multi sub infix:<xx>(Mu \x, Whatever) {
    GatherIter.new({ loop { take x } }, :infinite(True)).list
}
multi sub infix:<xx>(Mu \x, Int() $n) {
    my int $size = $n + 1;

    my Mu $rpa := nqp::list();
    if $size > 1 {
        nqp::setelems($rpa, $size);
        nqp::setelems($rpa, 0);

        nqp::push($rpa,x) while $size = $size - 1;
    }

    nqp::p6parcel($rpa, Any);
}

proto sub pop(@) {*}
multi sub pop(@a) { @a.pop }

proto sub shift(@) {*}
multi sub shift(@a) { @a.shift }

proto sub unshift(|) {*}
multi sub unshift(\a, \elem) { a.unshift: elem }
multi sub unshift(\a, *@elems) { a.unshift: @elems }

proto sub push(|) {*}
multi sub push(\a, \elem) { a.push: elem }
multi sub push(\a, *@elems) { a.push: @elems }

sub reverse(*@a)            { @a.reverse }
sub rotate(@a, Int $n = 1)  { @a.rotate($n) }
sub reduce (&with, *@list)  { @list.reduce(&with) }
sub splice(@arr, $offset = 0, $size?, *@values) {
    @arr.splice($offset, $size, @values)
}

multi sub infix:<cmp>(@a, @b) { (@a Zcmp @b).first(&prefix:<?>) || @a <=> @b }

# From 'src/core/LoL.pm'

class LoL { # declared in BOOTSTRAP
    # class LoL is List {
    #     has Mu $!descriptor;

    method new(|) {
        my Mu $args := nqp::p6argvmarray();
        nqp::shift($args);
        nqp::p6list($args, self.WHAT, Mu);
    }

    method AT-POS($pos is copy) {
        $pos = $pos.Int;
        self.EXISTS-POS($pos)
          ?? nqp::findmethod(List, 'AT-POS')(self, $pos)
          !! nqp::p6bindattrinvres(my $v, Scalar, '$!whence',
                 -> { nqp::findmethod(List, 'STORE_AT_POS')(self, $pos, $v) } )
    }

    multi method perl(LoL:D \SELF:) {
        '(' ~ self.map({.list.map({.perl}).join(', ')}).join('; ') ~ ')'
            ~ ('.item' if nqp::iscont(SELF));
    }

    method REIFY(Parcel \parcel, Mu \nextiter) {
        my Mu $rpa := nqp::getattr(parcel, Parcel, '$!storage');
        my Mu $iter := nqp::iterator($rpa);
        my int $i = 0;
        while $iter {
            nqp::bindpos($rpa, $i, my $v = nqp::shift($iter));
            $i = $i + 1;
        }
        nqp::findmethod(List, 'REIFY')(self, parcel, nextiter)
    }

    method STORE_AT_POS(\pos, Mu $v is copy) {
        nqp::findmethod(List, 'STORE_AT_POS')(self, pos, $v);
    }

}

sub lol (**@l) { @l }

sub find-reducer-for-op($op) {
    try my %prec := $op.prec;
    return &METAOP_REDUCE_LEFT if (nqp::isnull(%prec) or ! %prec);
    my $reducer = %prec<prec> eq 'f='
        ?? 'listinfix'
        !! %prec<assoc> // 'left';
    ::('&METAOP_REDUCE_' ~ $reducer.uc);
}

sub infix:<X>(|lol) {
    if lol.hash {
        my $op = lol.hash<with>;
        return METAOP_CROSS($op, find-reducer-for-op($op))(|lol.list) if $op;
    }
    my int $n = lol.elems - 1;
    my $Inf = False;
    my @l = eager for 0..$n -> $i {
        my \elem = lol[$i];         # can't use mapping here, mustn't flatten
        $Inf = True if $i and elem.infinite;
        if nqp::iscont(elem) { (elem,).list.item }
        else                 { (elem,).flat.item }
    }

    # eagerize 2nd and subsequent lists if finite
    my Mu $end := nqp::list_i();
    if !$Inf {
        for 1 .. $n -> $i {
            nqp::bindpos_i($end,$i,@l[$i].elems);
        }
    }

    my Mu $v := nqp::list();
    my int $i = 0;

    # Don't care if a finite Range is lazy
    my $policy = &list;
    if nqp::istype(lol[0],Range) {
        $policy = &EAGER unless $Inf || lol[0].infinite;
    }

    if $Inf {  # general case treats all lists as potentially lazy
        return gather {
            while $i >= 0 {
                if @l[$i].gimme(1) {
                    nqp::bindpos($v, $i, @l[$i].shift);
                    if $i >= $n { take nqp::clone($v) }
                    else {
                        $i = $i + 1;
                        my \elem = lol[$i];
                        @l[$i] = nqp::iscont(elem) ?? (elem,).list.item !! (elem,).flat.item;
                    }
                }
                else { $i = $i - 1 }
            }
        }
    }
    # optimize for 2D and 3D crosses
    elsif $n == 1 { # 2-dimensional
        $policy(gather {
            my int $e = nqp::atpos_i($end,1);
            my $l0 = @l[0];
            my $l1 = @l[1];
            while $l0.gimme(1) {
                nqp::bindpos($v, 0, @l[0].shift);
                loop (my int $j = 0; $j < $e; $j = $j + 1) {
                    nqp::bindpos($v, 1, $l1[$j]);
                    take nqp::clone($v);
                }
            }
        })
    }
    elsif $n == 2 { # 3-dimensional
        $policy(gather {
            my int $e1 = nqp::atpos_i($end,1);
            my int $e2 = nqp::atpos_i($end,2);
            my $l0 = @l[0];
            my $l1 = @l[1];
            my $l2 = @l[2];
            while $l0.gimme(1) {
                nqp::bindpos($v, 0, @l[0].shift);
                loop (my int $j = 0; $j < $e1; $j = $j + 1) {
                    nqp::bindpos($v, 1, $l1[$j]);
                    loop (my int $k = 0; $k < $e2; $k = $k + 1) {
                        nqp::bindpos($v, 2, $l2[$k]);
                        take nqp::clone($v);
                    }
                }
            }
        })
    }
    else { # more than 3 dimensions
        my Mu $jsave := nqp::list_i();
        $policy(gather {
            while $i == 0 {
                if @l[0].gimme(1) {
                    nqp::bindpos($v, $i, @l[0].shift);

                    if $i >= $n { take nqp::clone($v) }
                    else { $i = $i + 1; }

                    my int $j = 0;
                    while $i >= 1 {
                        if $j < nqp::atpos_i($end,$i) {
                            nqp::bindpos($v, $i, @l[$i][$j]);
                            $j = $j + 1;

                            if $i >= $n { take nqp::clone($v) }
                            else {
                                nqp::bindpos_i($jsave, $i, $j);
                                $i = $i + 1;
                                $j = 0;
                            }
                        }
                        else {
                            $i = $i - 1;
                            $j = nqp::atpos_i($jsave,$i);
                        }
                    }
                }
                else { $i = $i - 1 }
            }
        })
    }
}

my &cross = &infix:<X>;

sub infix:<Z>(|lol) {
    if lol.hash {
        my $op = lol.hash<with>;
        return METAOP_ZIP($op, find-reducer-for-op($op))(|lol.list) if $op;
    }
    my $arity = lol.elems;
    return if $arity == 0;
    my @l = eager for ^$arity -> $i {
            my \elem = lol[$i];         # can't use mapping here, mustn't flatten

            if nqp::iscont(elem) { (elem,).list.item }
            else                 { (elem,).flat.item }
        }

    gather {
        loop {
            my \p = @l.map: { last unless .gimme(1); .shift }
            last if p.elems < $arity;
            take-rw p.Parcel;
        }
    }
}

my &zip := &infix:<Z>;

sub roundrobin(**@lol) {
    my @l = @lol.map({ (.flat,).list.item });
    gather {
        my $p;
        while $p := @l.grep(*.Bool).map(*.shift).eager.Parcel {
            take $p;
        }
    }
}

# From 'src/core/Array.pm'

my class X::TypeCheck { ... };
my class X::Subscript::Negative { ... };

class Array { # declared in BOOTSTRAP
    # class Array is List {
    #     has Mu $!descriptor;

    method new(|) {
        my Mu $args := nqp::p6argvmarray();
        nqp::shift($args);

        nqp::p6list($args, self.WHAT, Bool::True);
    }

    multi method AT-POS(Array:D: int \pos) is rw {
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i(pos,0);
        my Mu \items := nqp::p6listitems(self);
        # hotpath check for element existence (RT #111848)
        if nqp::existspos(items,pos)
          || nqp::isconcrete(nqp::getattr(self,List,'$!nextiter'))
          && nqp::istrue(self.EXISTS-POS(pos)) {
            nqp::atpos(items,pos);
        }
        else {
            nqp::p6bindattrinvres(
                (my \v := nqp::p6scalarfromdesc($!descriptor)),
                Scalar,
                '$!whence',
                -> { nqp::bindpos(items,pos,v) }
            );
        }
    }
    multi method AT-POS(Array:D: Int:D \pos) is rw {
        my int $pos = nqp::unbox_i(pos.Int);
        fail X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>)
          if nqp::islt_i($pos,0);
        my Mu \items := nqp::p6listitems(self);
        # hotpath check for element existence (RT #111848)
        if nqp::existspos(items,$pos)
          || nqp::isconcrete(nqp::getattr(self,List,'$!nextiter'))
          && nqp::istrue(self.EXISTS-POS($pos)) {
            nqp::atpos(items,$pos);
        }
        else {
            nqp::p6bindattrinvres(
                (my \v := nqp::p6scalarfromdesc($!descriptor)),
                Scalar,
                '$!whence',
                -> { nqp::bindpos(items,$pos,v) }
            );
        }
    }

    multi method ASSIGN-POS(Array:D: int \pos, Mu \assignee) is rw {
        X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>).throw
          if nqp::islt_i(pos,0);
        my \items := nqp::p6listitems(self);
        nqp::existspos(items,pos)
          || nqp::isconcrete(nqp::getattr(self,List,'$!nextiter'))
          && self.EXISTS-POS(pos)
            ?? (nqp::atpos(items,pos) = assignee)
            !! (nqp::bindpos(items,pos,nqp::p6scalarfromdesc($!descriptor)) = assignee)
    }
    multi method ASSIGN-POS(Array:D: Int:D \pos, Mu \assignee) is rw {
        my int $pos = nqp::unbox_i(pos);
        X::OutOfRange.new(:what<Index>,:got(pos),:range<0..Inf>).throw
          if nqp::islt_i($pos,0);
        my \items := nqp::p6listitems(self);
        nqp::existspos(items,$pos)
          || nqp::isconcrete(nqp::getattr(self,List,'$!nextiter'))
          && self.EXISTS-POS($pos)
            ?? (nqp::atpos(items,$pos) = assignee)
            !! (nqp::bindpos(items,$pos,nqp::p6scalarfromdesc($!descriptor)) = assignee)
    }

    proto method BIND-POS(|) { * }
    multi method BIND-POS(Int() $pos, Mu \bindval) is rw {
        self.gimme($pos + 1);
        nqp::bindpos(nqp::getattr(self, List, '$!items'), nqp::unbox_i($pos), bindval);
    }
    multi method BIND-POS(int $pos, Mu \bindval) is rw {
        self.gimme($pos + 1);
        nqp::bindpos(nqp::getattr(self, List, '$!items'), $pos, bindval)
    }

    method DELETE-POS(\pos, :$SINK) {
        fail X::Subscript::Negative.new(index => pos, type => self.WHAT) if pos < 0;

        my $value := self.AT-POS(pos); # needed for reification
        my $items := nqp::getattr(self,List,'$!items');
        my $end   := self.end;

        if pos == $end {
            my $pos = pos;
            nqp::pop($items);
            nqp::pop($items)
              while --$pos >= 0 && nqp::isnull(nqp::atpos($items,$pos));
        }
        elsif pos < $end {
            nqp::bindpos($items, pos, nqp::null());
        }
        else {
            return self.default;
        }
        $value;
    }

    method flattens() { 1 }

    # introspection
    method name() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Str !! $d.name()
    }
    method of() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Mu !! $d.of;
    }
    method default() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Any !! $d.default;
    }
    method dynamic() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Bool !! so $d.dynamic;
    }
    multi method perl(Array:D \SELF:) {
        '['
        ~ (  # simplify arrays that look 2D (in first 3 elems anyway)
            nqp::istype(self[0],Parcel) || nqp::istype(self[1],Parcel) || nqp::istype(self[2],Parcel)
                ?? self.map({.list.map({.perl}).join(', ')}).join('; ')
                !! self.map({.perl}).join(', ')
        )
        ~ ']'
        ~ '<>' x !nqp::iscont(SELF);
    }

    method REIFY(Parcel \parcel, Mu \nextiter) {
        my Mu $rpa := nqp::getattr(parcel, Parcel, '$!storage');
        my Mu $iter := nqp::iterator($rpa);
        my int $i = 0;
        while $iter {
            nqp::bindpos($rpa, $i, nqp::p6scalarfromdesc($!descriptor) = nqp::shift($iter));
            $i = $i + 1;
        }
        nqp::findmethod(List, 'REIFY')(self, parcel, nextiter)
    }

    method STORE(|) {
        # get arguments, shift off invocant
        my $args := nqp::p6argvmarray();
        nqp::shift($args);
        # make an array from them (we can't just use ourself for this,
        # or @a = @a will go terribly wrong); make it eager
        my $list := nqp::p6list($args, Array, Mu);
        nqp::bindattr($list, List, '$!flattens', True);
        $list.eager;
        # clear our items and set our next iterator to be one over
        # the array we just created
        nqp::bindattr(self, List, '$!items', Mu);
        nqp::bindattr(self, List, '$!nextiter', nqp::p6listiter(nqp::list($list), self));
        self
    }

    my role TypedArray[::TValue] does Positional[TValue] {
        method new(|) {
            my Mu $args := nqp::p6argvmarray();
            nqp::shift($args);

            my $list := nqp::p6list($args, self.WHAT, Bool::True);

            my $of = self.of;
            if ( $of !=:= Mu ) {
                for @$list {
                    if $_ !~~ $of {
                        X::TypeCheck.new(
                          operation => '.new',
                          expected  => $of,
                          got       => $_,
                        ).throw;
                    }
                }
            }

            $list;
        }
        multi method AT-POS(Int() $pos) is rw {
            if self.EXISTS-POS($pos) {
                nqp::atpos(
                  nqp::getattr(self, List, '$!items'), nqp::unbox_i($pos)
                );
            }
            else {
                nqp::p6bindattrinvres(
                    (my \v := nqp::p6scalarfromdesc(nqp::getattr(self, Array, '$!descriptor'))),
                    Scalar,
                    '$!whence',
                    -> { nqp::bindpos(
                      nqp::getattr(self,List,'$!items'), nqp::unbox_i($pos), v) }
                );
            }
        }
        multi method AT-POS(int $pos) is rw {
            if self.EXISTS-POS($pos) {
                nqp::atpos(nqp::getattr(self, List, '$!items'), $pos);
            }
            else {
                nqp::p6bindattrinvres(
                    (my \v := nqp::p6scalarfromdesc(nqp::getattr(self, Array, '$!descriptor'))),
                    Scalar,
                    '$!whence',
                    -> { nqp::bindpos(nqp::getattr(self, List,'$!items'), $pos, v)}
                );
            }
        }
        multi method BIND-POS(Int() $pos, TValue \bindval) is rw {
            self.gimme($pos + 1);
            nqp::bindpos(nqp::getattr(self, List, '$!items'), nqp::unbox_i($pos), bindval)
        }
        multi method BIND-POS(int $pos, TValue \bindval) is rw {
            self.gimme($pos + 1);
            nqp::bindpos(nqp::getattr(self, List, '$!items'), $pos, bindval)
        }
        multi method perl(::?CLASS:D \SELF:) {
            my $args = self.map({ ($_ // TValue).perl(:arglist)}).join(', ');
            'Array[' ~ TValue.perl ~ '].new(' ~ $args ~ ')';
        }
        # XXX some methods to come here...
    }
    method ^parameterize(Mu:U \arr, Mu:U \t, |c) {
        if c.elems == 0 {
            my $what := arr.^mixin(TypedArray[t]);
            # needs to be done in COMPOSE phaser when that works
            $what.^set_name("{arr.^name}[{t.^name}]");
            $what;
        }
        else {
            die "Can only type-constrain Array with [ValueType]"
        }
    }
    multi method ACCEPTS(Array:D: $topic) {
        my $sseq = self;
        my $tseq = $topic.list;

        my int $spos = 0;
        my int $tpos = 0;
        while $spos < +$sseq {
            # if the next element is Whatever
            if nqp::istype($sseq[$spos],Whatever) {
                # skip over all of the Whatevers
                $spos = $spos + 1
                  while $spos <= +$sseq && nqp::istype($sseq[$spos],Whatever);
                # if nothing left, we're done
                return True if !($spos < +$sseq);
                # find a target matching our new target
                $tpos = $tpos + 1
                  while ($tpos < +$tseq) && $tseq[$tpos] !== $sseq[$spos];
                # return false if we ran out
                return False if !($tpos < +$tseq);
            }
            elsif $tpos >= +$tseq || $tseq[$tpos] !=== $sseq[$spos] {
                return False;
            }
            # skip matching elements
            $spos = $spos + 1;
            $tpos = $tpos + 1;
        }
        # If nothing left to match, we're successful.
        $tpos >= +$tseq;
    }

}


sub circumfix:<[ ]>(*@elems) is rw { my $ = @elems.eager }

# From 'src/core/native_array.pm'

class array is Iterable is repr('VMArray') {

    proto method STORE(|) { * }
    multi method STORE(array:D: *@values) { self.STORE(@values) }

    multi method push(array:D: *@values)    { self.push(@values) }
    multi method unshift(array:D: *@values) { self.unshift(@values) }

    my role intarray[::T] does Positional[T] is array_type(T) {

        multi method AT-POS(array:D: int $idx) is rw {
            nqp::atposref_i(self, $idx)
        }
        multi method AT-POS(array:D: Int:D $idx) is rw {
            nqp::atposref_i(self, $idx)
        }

        multi method ASSIGN-POS(array:D: int $idx, int $value) {
            nqp::bindpos_i(self, $idx, $value)
        }
        multi method ASSIGN-POS(array:D: Int:D $idx, int $value) {
            nqp::bindpos_i(self, $idx, $value)
        }
        multi method ASSIGN-POS(array:D: int $idx, Int:D $value) {
            nqp::bindpos_i(self, $idx, $value)
        }
        multi method ASSIGN-POS(array:D: Int:D $idx, Mu \value) {
            nqp::bindpos_i(self, $idx, value)
        }
        multi method ASSIGN-POS(array:D: Any:D $idx, Mu \value) {
            nqp::bindpos_i(self, $idx.Int, value)
        }

        multi method STORE(array:D: $value) {
            nqp::setelems(self, 1);
            nqp::bindpos_i(self, 0, nqp::unbox_i($value));
            self
        }
        multi method STORE(array:D: @values) {
            my int $i = 0;
            my int $n = @values.elems;
            nqp::setelems(self, $n);
            while $i < $n {
                nqp::bindpos_i(self, $i, nqp::unbox_i(@values.AT-POS($i)));
                $i = $i + 1;
            }
            self
        }
        multi method STORE(array:D: Range:D $range) {
            my int $val = $range.min;
            $val = $val + 1 if $range.excludes-min;
            my int $max = $range.max;
            $max = $max - 1 if $range.excludes-max;
            nqp::setelems(self, $max - $val + 1);

            my int $i;
            while $val <= $max {
                nqp::bindpos_i(self, $i, $val);
                $val = $val + 1;
                $i   = $i   + 1;
            }
            self
        }

        multi method push(array:D: int $value) {
            nqp::push_i(self, $value);
            self
        }
        multi method push(array:D: Int $value) {
            nqp::push_i(self, $value);
            self
        }
        multi method push(array:D: @values) {
            fail X::Cannot::Infinite.new(:action<.push>, :what(self.^name))
              if @values.infinite;
            nqp::push_i(self, $_) for @values;
            self
        }

        method pop(array:D:) returns int {
            nqp::elems(self) > 0
              ?? nqp::pop_i(self)
              !! die X::Cannot::Empty.new(:action<.pop>, :what(self.^name));
        }

        method shift() returns int {
            nqp::elems(self) > 0
              ?? nqp::shift_i(self)
              !! die X::Cannot::Empty.new(:action<.shift>, :what(self.^name));
        }

        multi method unshift(array:D: int $value) {
            nqp::unshift_i(self, $value);
            self
        }
        multi method unshift(array:D: Int $value) {
            nqp::unshift_i(self, $value);
            self
        }
        multi method unshift(array:D: @values) {
            fail X::Cannot::Infinite.new(:action<.unshift>, :what(self.^name))
              if @values.infinite;
            nqp::unshift_i(self, @values.pop) while @values;
            self
        }

        method splice($offset = 0, $size?, *@values) {
            my $o = $offset;
            my $s = $size;
            my $elems = self.elems;
            $o = $o($elems) if nqp::istype($o, Callable);
            X::OutOfRange.new(
                what => 'offset argument to array.splice',
                got  => $offset,
                range => (0..^$elems),
            ).fail if $o < 0;
            $s //= $elems - ($o min $elems);
            $s = $s($elems - $o) if nqp::istype($s, Callable);
            X::OutOfRange.new(
                what => 'size argument to array.splice',
                got  => $size,
                range => (0..^($elems - $o)),
            ).fail if $s < 0;

            my @ret := nqp::create(self);
            my int $i = $o;
            my int $n = $o + $s - 1;
            while $i <= $n {
                nqp::push_i(@ret, nqp::atpos_i(self, $i));
                $i = $i + 1;
            }

            my @splicees := nqp::create(self);
            nqp::push_i(@splicees, @values.shift) while @values;
            nqp::splice(self, @splicees, $o.Int, $s.Int);
            @ret;
        }

        my class NativeIntArrayIter is Iterator {
            has $!array;    # Native array we're iterating
            has $!reified;  # Parcel of native array refs we return after reifying
            has int $!idx;  # Starting index of this iterator

            method new($array) {
                my \iter = nqp::create(self);
                iter.BUILD(:$array);
                iter
            }

            submethod BUILD(:$array) {
                $!array := nqp::decont($array);
            }

            method reify($n) {   # :$sink is not needed here
                unless nqp::isconcrete($!reified) {
                    my $rpa := nqp::list();
                    my int $i = $!idx;
                    my int $stop = $i + nqp::unbox_i(
                        nqp::istype($n, Whatever) ?? 1000 !! $n);
                    $stop = nqp::elems($!array)
                        if $stop > nqp::elems($!array);
                    while $i < $stop {
                        nqp::push($rpa, nqp::atposref_i($!array, $i));
                        $i = $i + 1;
                    }
                    if $stop != nqp::elems($!array) {
                        my $next := nqp::create(self);
                        nqp::bindattr($next, NativeIntArrayIter, '$!array', $!array);
                        nqp::bindattr_i($next, NativeIntArrayIter, '$!idx', $i);
                        nqp::push($rpa, $next);
                    }
                    $!reified := nqp::p6parcel($rpa, nqp::null());
                    $!array := Any;
                }
                $!reified;
            }

            multi method infinite(NativeIntArrayIter:D:) { False }

            multi method DUMP(NativeIntArrayIter:D: :$indent-step = 4, :%ctx?) {
                return DUMP(self, :$indent-step) unless %ctx;
                my Mu $attrs := nqp::list();
                nqp::push($attrs, '$!array');
                nqp::push($attrs,  $!array);
                nqp::push($attrs, '$!reified');
                nqp::push($attrs,  $!reified);
                self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx);
            }
        }
        method iterator() {
            NativeIntArrayIter.new(self)
        }
    }

    my role numarray[::T] does Positional[T] is array_type(T) {
        multi method AT-POS(array:D: int $idx) is rw {
            nqp::atposref_n(self, $idx)
        }
        multi method AT-POS(array:D: Int $idx) is rw {
            nqp::atposref_n(self, $idx)
        }

        multi method ASSIGN-POS(array:D: int $idx, num $value) {
            nqp::bindpos_n(self, $idx, $value)
        }
        multi method ASSIGN-POS(array:D: Int:D $idx, num $value) {
            nqp::bindpos_n(self, $idx, $value)
        }
        multi method ASSIGN-POS(array:D: int $idx, Num:D $value) {
            nqp::bindpos_n(self, $idx, $value)
        }
        multi method ASSIGN-POS(array:D: Int:D $idx, Mu \value) {
            nqp::bindpos_n(self, $idx, value)
        }
        multi method ASSIGN-POS(array:D: Any:D $idx, Mu \value) {
            nqp::bindpos_n(self, $idx.Int, value)
        }

        multi method STORE(array:D: $value) {
            nqp::setelems(self, 1);
            nqp::bindpos_n(self, 0, nqp::unbox_n($value));
            self
        }
        multi method STORE(array:D: @values) {
            my int $i = 0;
            my int $n = @values.elems;
            nqp::setelems(self, $n);
            while $i < $n {
                nqp::bindpos_n(self, $i, nqp::unbox_n(@values.AT-POS($i)));
                $i = $i + 1;
            }
            self
        }
        multi method STORE(array:D: Range:D $range) {
            my num $val = $range.min;
            $val = $val + 1 if $range.excludes-min;
            my num $max = $range.max;
            $max = $max - 1 if $range.excludes-max;
            fail X::Cannot::Infinite.new(:action<initialize>,:what(self.^name))
              if $val == -Inf || $max == Inf;

            nqp::setelems(self, ($max - $val + 1).Int );
            my int $i;
            while $val <= $max {
                nqp::bindpos_n(self, $i, $val);
                $val = $val + 1;
                $i   = $i   + 1;
            }
            self
        }

        multi method push(array:D: num $value) {
            nqp::push_n(self, $value);
            self
        }
        multi method push(array:D: Num $value) {
            nqp::push_n(self, $value);
            self
        }
        multi method push(array:D: @values) {
            fail X::Cannot::Infinite.new(:action<.push>, :what(self.^name))
              if @values.infinite;
            nqp::push_n(self, $_) for @values;
            self
        }

        method pop(array:D:) returns num {
            nqp::elems(self) > 0
              ?? nqp::pop_n(self)
              !! die X::Cannot::Empty.new(:action<.pop>, :what(self.^name));
        }

        method shift() returns num {
            nqp::elems(self) > 0
              ?? nqp::shift_n(self)
              !! die X::Cannot::Empty.new(:action<.shift>, :what(self.^name));
        }

        multi method unshift(array:D: num $value) {
            nqp::unshift_n(self, $value);
            self
        }
        multi method unshift(array:D: Num $value) {
            nqp::unshift_n(self, $value);
            self
        }
        multi method unshift(array:D: @values) {
            fail X::Cannot::Infinite.new(:action<.unshift>, :what(self.^name))
              if @values.infinite;
            nqp::unshift_n(self, @values.pop) while @values;
            self
        }

        method splice($offset = 0, $size?, *@values) {
            my $o = $offset;
            my $s = $size;
            my $elems = self.elems;
            $o = $o($elems) if nqp::istype($o, Callable);
            X::OutOfRange.new(
                what => 'offset argument to array.splice',
                got  => $offset,
                range => (0..^$elems),
            ).fail if $o < 0;
            $s //= $elems - ($o min $elems);
            $s = $s($elems - $o) if nqp::istype($s, Callable);
            X::OutOfRange.new(
                what => 'size argument to array.splice',
                got  => $size,
                range => (0..^($elems - $o)),
            ).fail if $s < 0;

            my @ret := nqp::create(self);
            my int $i = $o;
            my int $n = $o + $s - 1;
            while $i <= $n {
                nqp::push_n(@ret, nqp::atpos_n(self, $i));
                $i = $i + 1;
            }

            my @splicees := nqp::create(self);
            nqp::push_n(@splicees, @values.shift) while @values;
            nqp::splice(self, @splicees, $o.Int, $s.Int);
            @ret;
        }

        my class NativeNumArrayIter is Iterator {
            has $!array;    # Native array we're iterating
            has $!reified;  # Parcel of native array refs we return after reifying
            has int $!idx;  # Starting index of this iterator

            method new($array) {
                my \iter = nqp::create(self);
                iter.BUILD(:$array);
                iter
            }

            submethod BUILD(:$array) {
                $!array := nqp::decont($array);
            }

            method reify($n, :$sink) {
                unless nqp::isconcrete($!reified) {
                    my $rpa := nqp::list();
                    my int $i = $!idx;
                    my int $stop = $i + nqp::unbox_i(
                        nqp::istype($n, Whatever) ?? 1000 !! $n);
                    $stop = nqp::elems($!array)
                        if $stop > nqp::elems($!array);
                    while $i < $stop {
                        nqp::push($rpa, nqp::atposref_n($!array, $i));
                        $i = $i + 1;
                    }
                    if $stop != nqp::elems($!array) {
                        my $next := nqp::create(self);
                        nqp::bindattr($next, NativeNumArrayIter, '$!array', $!array);
                        nqp::bindattr_i($next, NativeNumArrayIter, '$!idx', $i);
                        nqp::push($rpa, $next);
                    }
                    $!reified := nqp::p6parcel($rpa, nqp::null());
                    $!array := Any;
                }
                $!reified;
            }

            multi method infinite(NativeNumArrayIter:D:) { False }

            multi method DUMP(NativeNumArrayIter:D: :$indent-step = 4, :%ctx?) {
                return DUMP(self, :$indent-step) unless %ctx;
                my Mu $attrs := nqp::list();
                nqp::push($attrs, '$!array');
                nqp::push($attrs,  $!array);
                nqp::push($attrs, '$!reified');
                nqp::push($attrs,  $!reified);
                self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx);
            }
        }
        method iterator() {
            NativeNumArrayIter.new(self)
        }
    }

    method ^parameterize(Mu:U \arr, Mu:U \t) {
        my $t := nqp::decont(t);
        my int $kind = nqp::objprimspec($t);
        if $kind == 1 {
            my $what := arr.^mixin(intarray[$t]);
            $what.^set_name("{arr.^name}[{t.^name}]");
            $what;
        }
        elsif $kind == 2 {
            my $what := arr.^mixin(numarray[$t]);
            $what.^set_name("{arr.^name}[{t.^name}]");
            $what;
        }
        elsif $kind == 3 {
            nqp::die('NYI');
        }
        else {
            die "Can only parameterize array with a native type, not {t.^name}";
        }
    }

    proto method new(|) {*}
    multi method new() {
        self!validate-parameterized();
        nqp::create(self)
    }
    multi method new(@values) {
        self!validate-parameterized();
        nqp::create(self).STORE(@values)
    }
    multi method new(*@values) {
        self!validate-parameterized();
        nqp::create(self).STORE(@values)
    }

    method !validate-parameterized() {
        nqp::isnull(nqp::typeparameterized(self)) &&
            die "Must parameterize array[T] with a type before creating it";
    }

    method BIND-POS(|) is hidden-from-backtrace {
        die "Cannot bind to a natively typed array";
    }
    method DELETE-POS(|) is hidden-from-backtrace {
        die "Cannot delete from a natively typed array";
    }

    proto method ASSIGN-POS(|) { * } # Hide candidates from Any
    multi method ASSIGN-POS(Any:U \SELF: \pos, Mu \assignee) { # auto-viv
       SELF.AT-POS(pos) = assignee;
    }
    multi method ASSIGN-POS(Any:D: Any:U \pos, Mu \assignee) { # undefined idx
        die "Cannot use '{pos.^name}' as an index";
    }

    multi method EXISTS-POS(array:D: int $idx) {
        $idx >= 0 && $idx < nqp::elems(self)
    }
    multi method EXISTS-POS(array:D: Int $idx) {
        $idx >= 0 && $idx < nqp::elems(self)
    }

    multi method Bool(array:D:)    { nqp::p6bool(nqp::elems(self)) }
    multi method Numeric(array:D:) { nqp::elems(self) }
    multi method Str(array:D:)     { self.join(' ') }

    multi method elems(array:D:)    { nqp::elems(self) }
    multi method end(array:D:)      { nqp::elems(self) - 1 }
    multi method infinite(array:D:) { False }

    method eager() { self }
    method flat()  { self }
    method list()  { self }

    multi method gist(array:D:) {
        self.map(-> $elem {
            given ++$ {
                when 101 { '...' }
                when 102 { last }
                default  { $elem.gist }
            }
        } ).join: ' ';
    }

    multi method perl(array:D:) {
        'array[' ~ self.of.perl ~ '].new(' ~
            self.map(*.perl).join(', ') ~ ')'
    }

    method gimme($) {
        # Native arrays aren't lazy, so nothing to do.
        nqp::elems(self)
    }

    method FLATTENABLE_LIST() { self }
    method FLATTENABLE_HASH() { nqp::hash() }
}
# From 'src/core/Enum.pm'

my class Enum does Associative {
    has $.key;
    has $.value;

    method new(:$key, Mu :$value) { nqp::create(self).BUILD($key, $value) }
    method BUILD(\key, Mu \value) { $!key = key; $!value = value; self }

    multi method ACCEPTS(Enum:D: Associative:D $topic) {
        $topic{$.key} ~~ $.value
    }

    multi method ACCEPTS(Enum:D: Mu $topic) {
        my $method = $.key;
        $topic."$method"() === $.value;
    }

    method key(Enum:D:)   { $!key }
    method value(Enum:D:) { $!value }
    method antipair(Enum:D:) { self.new(key => $!value, value => $!key) }

    multi method keys(Enum:D:)      { ($!key,).list }
    multi method kv(Enum:D:)        { $!key, $!value }
    multi method values(Enum:D:)    { ($!value,).list }
    multi method pairs(Enum:D:)     { (self,).list }
    multi method antipairs(Enum:D:) { self.new(key => $!value, value => $!key) }
    multi method invert(Enum:D:)    { $!value => $!key }

    multi method Str(Enum:D:) { $.key ~ "\t" ~ $.value }

    multi method gist(Enum:D:) {
        if nqp::istype($.key, Enum) {
            '(' ~ $.key.gist ~ ') => ' ~ $.value.gist;
        } else {
            $.key.gist ~ ' => ' ~ $.value.gist;
        }
    }

    multi method perl(Enum:D: :$arglist) {
        if nqp::istype($.key, Enum) {
            '(' ~ $.key.perl ~ ') => ' ~ $.value.perl;
        } elsif nqp::istype($.key, Str) and !$arglist and $.key ~~ /^ [<alpha>\w*] +% <[\-']> $/ {
            if nqp::istype($.value,Bool) {
                ':' ~ '!' x !$.value ~ $.key;
            } else {
                ':' ~ $.key ~ '(' ~ $.value.perl ~ ')';
            }
        } else {
            $.key.perl ~ ' => ' ~ $.value.perl;
        }
    }

    method fmt($format = "%s\t%s") {
        sprintf($format, $.key, $.value);
    }

    multi method AT-KEY(Enum:D: $key)     { $key eq $!key ?? $!value !! Mu }
    multi method EXISTS-KEY(Enum:D: $key) { $key eq $!key }

    method FLATTENABLE_LIST() { nqp::list() }
    method FLATTENABLE_HASH() { nqp::hash($!key, $!value) }
}

multi sub infix:<eqv>(Enum:D $a, Enum:D $b) {
    $a.WHAT === $b.WHAT && $a.key eqv $b.key && $a.value eqv $b.value
}

multi sub infix:<cmp>(Enum:D \a, Enum:D \b) {
    (a.key cmp b.key) || (a.value cmp b.value)
}

# From 'src/core/Pair.pm'

my class Pair is Enum {
    method key() { nqp::getattr(self, Enum, '$!key') }
    method value() is rw { nqp::getattr(self, Enum, '$!value') }

    multi method ACCEPTS(Pair:D: %h) {
        $.value.ACCEPTS(%h{$.key});
    }
    multi method ACCEPTS(Pair:D: Mu $other) {
        $other."$.key"().Bool === $.value.Bool
    }
}

sub infix:=>($key, Mu $value) {
    Pair.new(:key($key), :value($value))
}

# From 'src/core/HashIter.pm'

my class HashIter is Iterator {
    has $!reified;             # Parcel we return after reifying
    has Mu $!hashiter;         # the VM level hash iterator
    has Mu $!keystore;         # key store, if it's a typed hash
    has int $!mode;            # pair = 0, kv = 1, k = 2, v = 3, anti = 4, invert = 5

    method new($hash, :$keystore, :$pairs, :$kv, :$k, :$v, :$anti, :$invert) {
        nqp::create(self).BUILD($hash, $keystore,
            $pairs  ?? 0 !!
            $kv     ?? 1 !!
            $k      ?? 2 !!
            $v      ?? 3 !!
            $anti   ?? 4 !!
            $invert ?? 5 !!
                       0);
    }
    method pairs($h,$keystore?)     { nqp::create(self).BUILD($h,$keystore,0) }
    method kv($h,$keystore?)        { nqp::create(self).BUILD($h,$keystore,1) }
    method keys($h,$keystore?)      { nqp::create(self).BUILD($h,$keystore,2) }
    method values($h,$keystore?)    { nqp::create(self).BUILD($h,$keystore,3) }
    method antipairs($h,$keystore?) { nqp::create(self).BUILD($h,$keystore,4) }
    method invert($h,$keystore?)    { nqp::create(self).BUILD($h,$keystore,5) }

    submethod BUILD($hash, $keystore, Int $mode) {
        $!hashiter :=
          nqp::iterator(nqp::getattr(nqp::decont($hash), EnumMap, '$!storage'));
        $!mode      = $mode;
        $!keystore := nqp::getattr(nqp::decont($keystore), EnumMap, '$!storage')
          if $keystore.DEFINITE;
        self;
    }

    method reify($n, :$sink) {  # hashes are finite, and hashiter non-reentrant, so do eager snapshot for now
        unless nqp::isconcrete($!reified) {
            my int $mode  =  $!mode;
            my Mu $rpa    := nqp::list();
            my $it        := $!hashiter;

            my Mu $pairish;
            if $mode == 0 {   # :pairs
                if nqp::defined($!keystore) {
                    while $it {
                        $pairish := nqp::shift($it);
                        nqp::push($rpa, Pair.new(
                            :key(nqp::atkey($!keystore, nqp::iterkey_s($pairish))),
                            :value(nqp::hllize(nqp::iterval($pairish)))));
                    }
                }
                else {
                    while $it {
                        $pairish := nqp::shift($it);
                        nqp::push($rpa, Pair.new(
                            :key(nqp::p6box_s(nqp::iterkey_s($pairish))),
                            :value(nqp::hllize(nqp::iterval($pairish)))));
                    }
                }
            }
            elsif $mode == 1 {  # :kv
                if nqp::defined($!keystore) {
                    while $it {
                        $pairish := nqp::shift($it);
                        nqp::push($rpa, nqp::atkey($!keystore, nqp::iterkey_s($pairish)).item);
                        nqp::push($rpa, nqp::hllize(nqp::iterval($pairish)).item);
                    }
                }
                else {
                    while $it {
                        $pairish := nqp::shift($it);
                        nqp::push($rpa, nqp::p6box_s(nqp::iterkey_s($pairish)));
                        nqp::push($rpa, nqp::hllize(nqp::iterval($pairish)).item);
                    }
                }
            }
            elsif $mode == 2 {  # :k
                if nqp::defined($!keystore) {
                    while $it {
                        $pairish := nqp::shift($it);
                        nqp::push($rpa, nqp::atkey($!keystore, nqp::iterkey_s($pairish)).item);
                    }
                }
                else {
                    while $it {
                        $pairish := nqp::shift($it);
                        nqp::push($rpa, nqp::p6box_s(nqp::iterkey_s($pairish)));
                    }
                }
            }
            elsif $mode == 3 {  # :v
                while $it {
                    $pairish := nqp::shift($it);
                    nqp::push($rpa, nqp::hllize(nqp::iterval($pairish)).item);
                }
            }
            elsif $mode == 4 {  # :anti
                if nqp::defined($!keystore) {
                    while $it {
                        $pairish := nqp::shift($it);
                        nqp::push($rpa, Pair.new(
                            :value(nqp::atkey($!keystore, nqp::iterkey_s($pairish))),
                            :key(nqp::hllize(nqp::iterval($pairish)))));
                    }
                }
                else {
                    while $it {
                        $pairish := nqp::shift($it);
                        nqp::push($rpa, Pair.new(
                            :value(nqp::p6box_s(nqp::iterkey_s($pairish))),
                            :key(nqp::hllize(nqp::iterval($pairish)))));
                    }
                }
            }
            elsif $mode == 5 {  # :invert
                if nqp::defined($!keystore) {
                    while $it {
                        $pairish := nqp::shift($it);
                        my $k := nqp::atkey($!keystore, nqp::iterkey_s($pairish));
                        nqp::push($rpa, Pair.new(
                            :value($k),
                            :key($_)))
                                for nqp::hllize(nqp::iterval($pairish)).list;
                    }
                }
                else {
                    while $it {
                        $pairish := nqp::shift($it);
                        my $k := nqp::p6box_s(nqp::iterkey_s($pairish));
                        nqp::push($rpa, Pair.new(
                            :value($k),
                            :key($_)))
                                for nqp::hllize(nqp::iterval($pairish)).list;
                    }
                }
            }
            else {
                die "Unknown hash iteration mode: $mode";
            }

            if $it {
                my $nextiter := nqp::create(self);
                nqp::bindattr($nextiter, HashIter, '$!hashiter', $it);
                nqp::bindattr($nextiter, HashIter, '$!keystore', $!keystore);
                nqp::bindattr_i($nextiter, HashIter, '$!mode', $mode);
                nqp::push($rpa, $nextiter);
            }

            $!reified := nqp::p6parcel($rpa, nqp::null());
            # release references to objects we no longer need/own
            $!hashiter := Any;
        }
        $!reified;
    }

    multi method infinite(HashIter:D:) { False }

    multi method DUMP(HashIter:D: :$indent-step = 4, :%ctx?) {
        return DUMP(self, :$indent-step) unless %ctx;

        my Mu $attrs := nqp::list();
        nqp::push($attrs, '$!reified'  );
        nqp::push($attrs,  $!reified   );
        nqp::push($attrs, '$!hashiter' );
        nqp::push($attrs,  $!hashiter  );
        nqp::push($attrs, '$!keystore' );
        nqp::push($attrs,  $!keystore  );
        nqp::push($attrs, '$!mode'     );
        nqp::push($attrs,  $!mode      );
        self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx);
    }
}

# From 'src/core/EnumMap.pm'

my class X::Hash::Store::OddNumber { ... }

my class EnumMap does Associative { # declared in BOOTSTRAP
    # my class EnumMap is Iterable is Cool {
    #   has Mu $!storage;

    method new(*@args) {
        my %h := nqp::create(self);
        %h.STORE(@args) if @args;
        %h;
    }

    multi method Bool(EnumMap:D:) {
        nqp::p6bool(nqp::defined($!storage) && nqp::elems($!storage));
    }
    method elems(EnumMap:D:) {
        nqp::p6box_i(nqp::defined($!storage) && nqp::elems($!storage));
    }

    multi method ACCEPTS(EnumMap:D: Any $topic) {
        self.EXISTS-KEY($topic.any);
    }

    multi method ACCEPTS(EnumMap:D: Cool:D $topic) {
        self.EXISTS-KEY($topic);
    }

    multi method ACCEPTS(EnumMap:D: Positional $topic) {
        self.EXISTS-KEY($topic.any);
    }

    multi method ACCEPTS(EnumMap:D: Regex $topic) {
        so self.keys.any.match($topic);
    }

    multi method EXISTS-KEY(EnumMap:D: Str:D \key) {
        nqp::p6bool(
            nqp::defined($!storage)
            && nqp::existskey($!storage, nqp::unbox_s(key))
        )
    }
    multi method EXISTS-KEY(EnumMap:D: \key) {
        nqp::p6bool(
            nqp::defined($!storage)
            && nqp::existskey($!storage, nqp::unbox_s(key.Str))
        )
    }

    multi method perl(EnumMap:D:) {
        self.^name
          ~ '.new('
          ~ self.pairs.pick(*).map({.perl}).join(', ')
          ~ ')';
    }

    method iterator(EnumMap:) { self.pairs.iterator }
    method list(EnumMap:) { self.pairs }

    multi method keys(EnumMap:D:) {
        (nqp::defined($!storage) ?? HashIter.keys(self)     !! ()).list;
    }
    multi method kv(EnumMap:D:) {
        (nqp::defined($!storage) ?? HashIter.kv(self)       !! ()).list;
    }
    multi method values(EnumMap:D:) {
        (nqp::defined($!storage) ?? HashIter.values(self)   !! ()).list;
    }
    multi method pairs(EnumMap:D:) {
        (nqp::defined($!storage) ?? HashIter.pairs(self)    !! ()).list;
    }
    multi method antipairs(EnumMap:D:) {
        (nqp::defined($!storage) ?? HashIter.antipairs(self) !! ()).list;
    }
    multi method invert(EnumMap:D:) {
        (nqp::defined($!storage) ?? HashIter.invert(self)   !! ()).list;
    }

    multi method AT-KEY(EnumMap:D: \key) is rw {
        my str $skey = nqp::unbox_s(key.Str);
        nqp::defined($!storage) && nqp::existskey($!storage, $skey)
          ?? nqp::atkey($!storage, $skey)
          !! Any
    }

    method STORE(\to_store) {
        my $items = (to_store,).flat.eager;
        $!storage := nqp::hash();

        if $items.elems == 1 {
            if nqp::istype($items[0],EnumMap) {
                my Mu $x := $items.shift;
                DEPRECATED(
                  self.VAR.name ~ ' = %(itemized hash)',
                  |<2014.07 2015.07>,
                  :what(self.VAR.name ~ ' = itemized hash')
                ) if nqp::iscont($x);
                for $x.list { self.STORE_AT_KEY(.key, .value) }
                return self;
            }
        }

        while $items {
            my Mu $x := $items.shift;
            if nqp::istype($x,Enum) { self.STORE_AT_KEY($x.key, $x.value) }
            elsif nqp::istype($x,EnumMap) and !nqp::iscont($x) {
                for $x.list { self.STORE_AT_KEY(.key, .value) }
            }
            elsif $items { self.STORE_AT_KEY($x, $items.shift) }
            else {
                X::Hash::Store::OddNumber.new.throw
            }
        }
        self
    }

    proto method STORE_AT_KEY(|) is rw { * }
    multi method STORE_AT_KEY(Str \key, Mu \value) is rw {
        nqp::defined($!storage) ||
            nqp::bindattr(self, EnumMap, '$!storage', nqp::hash());
        nqp::bindkey($!storage, nqp::unbox_s(key), value)
    }
    multi method STORE_AT_KEY(\key, Mu \value) is rw {
        nqp::defined($!storage) ||
            nqp::bindattr(self, EnumMap, '$!storage', nqp::hash());
        nqp::bindkey($!storage, nqp::unbox_s(key.Str), value)
    }

    method Capture(EnumMap:D:) {
        my $cap := nqp::create(Capture);
        nqp::bindattr($cap, Capture, '$!hash', $!storage);
        $cap
    }

    method FLATTENABLE_LIST() { nqp::list() }
    method FLATTENABLE_HASH() {
        nqp::defined($!storage) ||
            nqp::bindattr(self, EnumMap, '$!storage', nqp::hash());
        $!storage
    }

    method fmt(EnumMap: Cool $format = "%s\t\%s", $sep = "\n") {
        if nqp::p6box_i(nqp::sprintfdirectives( nqp::unbox_s($format.Stringy) )) == 1 {
            self.keys.fmt($format, $sep);
        }
        else {
            self.pairs.fmt($format, $sep);
        }
    }

    method hash() { self }
}

multi sub infix:<eqv>(EnumMap:D $a, EnumMap:D $b) {
    if +$a != +$b { return Bool::False }
    for $a.kv -> $k, $v {
        unless $b.EXISTS-KEY($k) && $b{$k} eqv $v {
            return Bool::False;
        }
    }
    Bool::True;
}


# From 'src/core/Hash.pm'

my class Hash { # declared in BOOTSTRAP
    # my class Hash is EnumMap {
    #     has Mu $!descriptor;

    multi method AT-KEY(Hash:D: \key) is rw {
        my Mu $storage := nqp::getattr(self, EnumMap, '$!storage');
        $storage := nqp::bindattr(self, EnumMap, '$!storage', nqp::hash())
            unless nqp::defined($storage);
        my str $skey = nqp::istype(key, Str) ?? key !! key.Str;
        if nqp::existskey($storage, $skey) {
            nqp::atkey($storage, $skey);
        }
        else {
            nqp::p6bindattrinvres(
                (my \v := nqp::p6scalarfromdesc($!descriptor)),
                Scalar,
                '$!whence',
                -> { nqp::bindkey($storage, $skey, v) }
            );
        }
    }

    multi method ASSIGN-KEY(Hash:D: \key, Mu \assignval) {
        my Mu $storage := nqp::getattr(self, EnumMap, '$!storage');
        $storage := nqp::bindattr(self, EnumMap, '$!storage', nqp::hash())
            unless nqp::defined($storage);
        my str $key = nqp::istype(key, Str) ?? key !! key.Str;
        nqp::existskey($storage, $key)
            ?? (nqp::atkey($storage, $key) = assignval)
            !! nqp::bindkey($storage, $key,
                nqp::p6scalarfromdesc($!descriptor) = assignval)
    }

    method BIND-KEY(Hash:D: \key, Mu \bindval) is rw {
        my Mu $storage := nqp::getattr(self, EnumMap, '$!storage');
        $storage := nqp::bindattr(self, EnumMap, '$!storage', nqp::hash())
            unless nqp::defined($storage);
        my str $key = nqp::istype(key, Str) ?? key !! key.Str;
        nqp::bindkey($storage, $key, bindval)
    }

    multi method perl(Hash:D \SELF:) {
        '{' ~ SELF.pairs.sort.map({.perl}).join(', ') ~ '}'
        ~ '<>' x !nqp::iscont(SELF)
    }

    multi method gist(Hash:D \SELF:) {
        SELF.pairs.sort.map( -> $elem {
            given ++$ {
                when 101 { '...' }
                when 102 { last }
                default  { $elem.gist }
            }
        } ).join: ', ';
    }

    multi method DUMP(Hash:D: :$indent-step = 4, :%ctx?) {
        return DUMP(self, :$indent-step) unless %ctx;

        my Mu $attrs := nqp::list();
        nqp::push($attrs, '$!descriptor');
        nqp::push($attrs,  $!descriptor );
        nqp::push($attrs, '$!storage'   );
        nqp::push($attrs,  nqp::getattr(nqp::decont(self), EnumMap, '$!storage'));
        self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx);
    }

    method STORE_AT_KEY(\key, Mu $x) is rw {
        my $v := nqp::p6scalarfromdesc($!descriptor);
        nqp::findmethod(EnumMap, 'STORE_AT_KEY')(self, key, $v = $x);
    }

    # introspection
    method name() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Str !! $d.name()
    }
    method keyof () { Any }
    method of() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Mu !! $d.of;
    }
    method default() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Any !! $d.default;
    }
    method dynamic() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Bool !! so $d.dynamic;
    }

    multi method DELETE-KEY(Hash:U:) { Nil }
    multi method DELETE-KEY(Str() \key) {
        my Mu $val = self.AT-KEY(key);
        nqp::deletekey(
            nqp::getattr(self, EnumMap, '$!storage'),
            nqp::unbox_s(key)
        );
        $val;
    }
    multi method DELETE-KEY(Str() \key, :$SINK!) {
        nqp::deletekey(
            nqp::getattr(self, EnumMap, '$!storage'),
            nqp::unbox_s(key)
        );
        Nil;
    }

    method push(*@values) {
        fail X::Cannot::Infinite.new(:action<.push>, :what(self.^name))
          if @values.infinite;
        my $previous;
        my $has_previous;
        for @values -> $e {
            if $has_previous {
                self!_push_construct($previous, $e);
                $has_previous = 0;
            } elsif $e.^isa(Enum) {
                self!_push_construct($e.key, $e.value);
            } else {
                $previous = $e;
                $has_previous = 1;
            }
        }
        if $has_previous {
            warn "Trailing item in Hash.push";
        }
        self
    }

    proto method classify-list(|) { * }
    multi method classify-list( &test, *@list ) {
        fail X::Cannot::Infinite.new(:action<.classify>) if @list.infinite;
        if @list {

            # multi-level classify
            if nqp::istype(test(@list[0]),List) {
                for @list -> $l {
                    my @keys  = test($l);
                    my $last := @keys.pop;
                    my $hash  = self;
                    $hash = $hash{$_} //= self.new for @keys;
                    nqp::push(
                      nqp::p6listitems(nqp::decont($hash{$last} //= [])), $l );
                }
            }

            # just a simple classify
            else {
                nqp::push(
                  nqp::p6listitems(nqp::decont(self{test $_} //= [])), $_ )
                  for @list;
            }
        }
        self;
    }
    multi method classify-list( %test, *@list ) {
        samewith( { %test{$^a} }, @list );
    }
    multi method classify-list( @test, *@list ) {
        samewith( { @test[$^a] }, @list );
    }

    proto method categorize-list(|) { * }
    multi method categorize-list( &test, *@list ) {
        fail X::Cannot::Infinite.new(:action<.categorize>) if @list.infinite;
        if @list {

            # multi-level categorize
            if nqp::istype(test(@list[0])[0],List) {
                for @list -> $l {
                    for test($l) -> $k {
                        my @keys = @($k);
                        my $last := @keys.pop;
                        my $hash  = self;
                        $hash = $hash{$_} //= self.new for @keys;
                        nqp::push(
                          nqp::p6listitems(
                            nqp::decont($hash{$last} //= [])), $l );
                    }
                }
            }

            # just a simple categorize
            else {
                for @list -> $l {
                    nqp::push(
                      nqp::p6listitems(nqp::decont(self{$_} //= [])), $l )
                      for test($l);
                }
            }
        }
        self;
    }
    multi method categorize-list( %test, *@list ) {
        samewith( { %test{$^a} }, @list );
    }
    multi method categorize-list( @test, *@list ) {
        samewith( { @test[$^a] }, @list );
    }

    # push a value onto a hash slot, constructing an array if necessary
    method !_push_construct(Mu $key, Mu $value) {
        if self.EXISTS-KEY($key) {
            if self.{$key}.^isa(Array) {
                self.{$key}.push($value);
            } else {
                self.{$key} = [ self.{$key}, $value ];
            }
        } else {
            self.{$key} = $value;
        }
    }

    my role TypedHash[::TValue] does Associative[TValue] {
        method AT-KEY(::?CLASS:D: Str() $key) is rw {
            if self.EXISTS-KEY($key) {
                nqp::findmethod(EnumMap, 'AT-KEY')(self, $key);
            }
            else {
                nqp::p6bindattrinvres(
                    (my \v := nqp::p6scalarfromdesc(nqp::getattr(self, Hash, '$!descriptor'))),
                    Scalar,
                    '$!whence',
                    -> { nqp::findmethod(EnumMap, 'STORE_AT_KEY')(self, $key, v) }
                );
            }
        }
        method STORE_AT_KEY(Str \key, TValue $x) is rw {
            my $v :=
              nqp::p6scalarfromdesc(nqp::getattr(self, Hash, '$!descriptor'));
            nqp::findmethod(EnumMap, 'STORE_AT_KEY')(self, key, $v = $x);
        }
        multi method ASSIGN-KEY(::?CLASS:D: \key, TValue \assignval) {
            my Mu $storage := nqp::getattr(self, EnumMap, '$!storage');
            $storage := nqp::bindattr(self, EnumMap, '$!storage', nqp::hash())
                unless nqp::defined($storage);
            my str $key = nqp::istype(key, Str) ?? key !! key.Str;
            if nqp::existskey($storage, $key) {
                nqp::atkey($storage, $key) = assignval;
            }
            else {
                nqp::bindkey($storage, $key,
                    nqp::p6scalarfromdesc(nqp::getattr(self, Hash, '$!descriptor')) = assignval)
            }
        }
        method BIND-KEY($key, TValue \bindval) is rw {
            nqp::defined(nqp::getattr(self, EnumMap, '$!storage')) ||
                nqp::bindattr(self, EnumMap, '$!storage', nqp::hash());
            nqp::bindkey(
                nqp::getattr(self, EnumMap, '$!storage'),
                nqp::unbox_s($key.Str),
                bindval)
        }
        multi method perl(::?CLASS:D \SELF:) {
            'Hash['
              ~ TValue.perl
              ~ '].new('
              ~ self.pairs.sort.map({.perl(:arglist)}).join(', ')
              ~ ')';
        }
    }
    my role TypedHash[::TValue, ::TKey] does Associative[TValue] {
        has $!keys;
        method keyof () { TKey }
        method AT-KEY(::?CLASS:D: TKey \key) is rw {
            my $key_which = key.WHICH;
            if self.EXISTS-KEY(key) {
                nqp::findmethod(EnumMap, 'AT-KEY')(self, $key_which);
            }
            else {
                nqp::p6bindattrinvres(
                    (my \v := nqp::p6scalarfromdesc(nqp::getattr(self, Hash, '$!descriptor'))),
                    Scalar,
                    '$!whence',
                    -> {
                        nqp::defined(nqp::getattr(self, $?CLASS, '$!keys')) ||
                            nqp::bindattr(self, $?CLASS, '$!keys', nqp::hash());
                        nqp::defined(nqp::getattr(self, EnumMap, '$!storage')) ||
                            nqp::bindattr(self, EnumMap, '$!storage', nqp::hash());
                        nqp::bindkey(
                            nqp::getattr(self, $?CLASS, '$!keys'),
                            nqp::unbox_s($key_which),
                            key);
                        nqp::bindkey(
                            nqp::getattr(self, EnumMap, '$!storage'),
                            nqp::unbox_s($key_which),
                            v);
                    });
            }
        }
        method STORE_AT_KEY(TKey \key, TValue $x) is rw {
            my $key_which = key.WHICH;
            nqp::defined(nqp::getattr(self, $?CLASS, '$!keys')) ||
                nqp::bindattr(self, $?CLASS, '$!keys', nqp::hash());
            nqp::defined(nqp::getattr(self, EnumMap, '$!storage')) ||
                nqp::bindattr(self, EnumMap, '$!storage', nqp::hash());
            nqp::bindkey(
                nqp::getattr(self, $?CLASS, '$!keys'),
                nqp::unbox_s($key_which),
                key);
            my $v :=
              nqp::p6scalarfromdesc(nqp::getattr(self, Hash, '$!descriptor'));
            nqp::bindkey(
                nqp::getattr(self, EnumMap, '$!storage'),
                nqp::unbox_s($key_which),
                $v = $x);
        }
        method ASSIGN-KEY(::?CLASS:D: TKey \key, TValue \assignval) {
            my Mu $storage := nqp::getattr(self, EnumMap, '$!storage');
            $storage := nqp::bindattr(self, EnumMap, '$!storage', nqp::hash())
                unless nqp::defined($storage);
            my str $key_which = nqp::unbox_s(key.WHICH);
            if nqp::existskey($storage, $key_which) {
                nqp::atkey($storage, $key_which) = assignval;
            }
            else {
                nqp::defined(nqp::getattr(self, $?CLASS, '$!keys')) ||
                    nqp::bindattr(self, $?CLASS, '$!keys', nqp::hash());
                nqp::bindkey(nqp::getattr(self, $?CLASS, '$!keys'), $key_which, key);
                nqp::bindkey($storage, $key_which,
                    nqp::p6scalarfromdesc(nqp::getattr(self, Hash, '$!descriptor')) = assignval)
            }
        }
        method BIND-KEY(TKey \key, TValue \bindval) is rw {
            my $key_which = key.WHICH;
            nqp::defined(nqp::getattr(self, $?CLASS, '$!keys')) ||
                nqp::bindattr(self, $?CLASS, '$!keys', nqp::hash());
            nqp::defined(nqp::getattr(self, EnumMap, '$!storage')) ||
                nqp::bindattr(self, EnumMap, '$!storage', nqp::hash());
            nqp::bindkey(
                nqp::getattr(self, $?CLASS, '$!keys'),
                nqp::unbox_s($key_which),
                key);
            nqp::bindkey(
                nqp::getattr(self, EnumMap, '$!storage'),
                nqp::unbox_s($key_which),
                bindval)
        }
        method EXISTS-KEY(TKey \key) {
            nqp::defined($!keys)
              ?? nqp::p6bool(nqp::existskey($!keys, nqp::unbox_s(key.WHICH)))
              !! False
        }
        method keys(EnumMap:) {
            return unless self.DEFINITE && nqp::defined($!keys);
            HashIter.keys(self,$!keys).list
        }
        method kv(EnumMap:) {
            return unless self.DEFINITE && nqp::defined($!keys);
            HashIter.kv(self,$!keys).list
        }
        method values(EnumMap:) {
            return unless self.DEFINITE && nqp::defined($!keys);
            HashIter.values(self,$!keys).list
        }
        method pairs(EnumMap:) {
            return unless self.DEFINITE && nqp::defined($!keys);
            HashIter.pairs(self,$!keys).list
        }
        method antipairs(EnumMap:) {
            return unless self.DEFINITE && nqp::defined($!keys);
            HashIter.antipairs(self,$!keys).list
        }
        method invert(EnumMap:) {
            return unless self.DEFINITE && nqp::defined($!keys);
            HashIter.invert(self,$!keys).list
        }
        multi method perl(::?CLASS:D \SELF:) {
            if TKey === Any and TValue === Mu and nqp::iscont(SELF) {
                ':{' ~ SELF.pairs.sort.map({.perl}).join(', ') ~ '}'
            }
            else {
                'Hash['
                  ~ TValue.perl
                  ~ ','
                  ~ TKey.perl
                  ~ '].new('
                  ~ self.pairs.sort.map({.perl(:arglist)}).join(', ')
                  ~ ')';
            }
        }
        multi method DELETE-KEY($key) {
            my Mu $val = self.AT-KEY($key);
            my $key-which = $key.WHICH;

            nqp::deletekey(
                nqp::getattr(self, $?CLASS, '$!keys'),
                nqp::unbox_s($key-which)
            );

            nqp::deletekey(
                nqp::getattr(self, EnumMap, '$!storage'),
                nqp::unbox_s($key-which)
            );
            $val;
        }

        # gotta force capture keys to strings or binder fails
        method Capture(EnumMap:D:) {
            my $cap := nqp::create(Capture);
            my $h := nqp::hash();
            for self.kv -> \k, \v {
                my str $skey = nqp::istype(k, Str) ?? k !! k.Str;
                nqp::bindkey($h, $skey, v);
            }
            nqp::bindattr($cap, Capture, '$!hash', $h);
            $cap
        }

    }
    method ^parameterize(Mu:U \hash, Mu:U \t, |c) {
        if c.elems == 0 {
            my $what := hash.^mixin(TypedHash[t]);
            # needs to be done in COMPOSE phaser when that works
            $what.^set_name("{hash.^name}[{t.^name}]");
            $what;
        }
        elsif c.elems == 1 {
            my $what := hash.^mixin(TypedHash[t, c[0].WHAT]);
            # needs to be done in COMPOSE phaser when that works
            $what.^set_name("{hash.^name}[{t.^name},{c[0].^name}]");
            $what;
        }
        else {
            die "Can only type-constrain Hash with [ValueType] or [ValueType,KeyType]";
        }
    }
}


sub circumfix:<{ }>(*@elems) { (my % = @elems).item }
sub hash(*@a, *%h) { my % = @a, %h }

BEGIN my &circumfix:<:{ }> = sub (*@elems) { my $ = Hash.^parameterize(Mu,Any).new(@elems) }

# From 'src/core/Stash.pm'

my class Stash { # declared in BOOTSTRAP
    # class Stash is Hash {

    multi method AT-KEY(Stash:D: Str() $key, :$global_fallback) is rw {
        my Mu $storage := nqp::defined(nqp::getattr(self, EnumMap, '$!storage')) ??
            nqp::getattr(self, EnumMap, '$!storage') !!
            nqp::bindattr(self, EnumMap, '$!storage', nqp::hash());
        if nqp::existskey($storage, nqp::unbox_s($key)) {
            nqp::atkey($storage, nqp::unbox_s($key))
        }
        elsif $global_fallback {
            nqp::existskey(GLOBAL.WHO, $key)
                ?? GLOBAL.WHO.AT-KEY($key)
                !! fail("Could not find symbol '$key'")
        }
        else {
            nqp::p6bindattrinvres(my $v, Scalar, '$!whence',
                 -> { nqp::bindkey($storage, nqp::unbox_s($key), $v) } )
        }
    }

    method package_at_key(Stash:D: str $key) {
        my Mu $storage := nqp::defined(nqp::getattr(self, EnumMap, '$!storage')) ??
            nqp::getattr(self, EnumMap, '$!storage') !!
            nqp::bindattr(self, EnumMap, '$!storage', nqp::hash());
        if nqp::existskey($storage, nqp::unbox_s($key)) {
            nqp::atkey($storage, $key)
        }
        else {
            my $pkg := Metamodel::PackageHOW.new_type(:name($key));
            $pkg.^compose;
            nqp::bindkey($storage, $key, $pkg)
        }
    }
}

# From 'src/core/Label.pm'

my class Label {
    has Str $!name;
    has Str $!file;
    has Int $!line;
    has Str $!prematch;
    has Str $!postmatch;
    method new(:$name, :$line, :$prematch, :$postmatch) {
        # XXX Register in &?BLOCK.labels when we have &?BLOCK.
        my $file := nqp::getlexdyn('$?FILES');
        $file    := nqp::isnull($file) ?? '<unkown>' !! nqp::p6box_s($file);
        my $obj  := nqp::create(self);
        nqp::bindattr($obj, Label, '$!name',      $name);
        nqp::bindattr($obj, Label, '$!file',      $file);
        nqp::bindattr($obj, Label, '$!line',      $line);
        nqp::bindattr($obj, Label, '$!prematch',  nqp::p6box_s($prematch));
        nqp::bindattr($obj, Label, '$!postmatch', nqp::p6box_s($postmatch));
        $obj
    }
    method name() {
        $!name
    }

    # XXX method leave(@args)

    multi method gist(Label:D:) {
        my $is-win := $*DISTRO.is-win;
        my $color = %*ENV<RAKUDO_ERROR_COLOR> // !$is-win;
        my ($red, $green, $yellow, $clear) = $color
            ?? ("\e[31m", "\e[32m", "\e[33m", "\e[0m")
            !! ("", "", "", "");
        my $eject = $is-win ?? "<HERE>" !! "\x[23CF]";

        "Label<$!name>(at $!file:$!line, '$green$!prematch$yellow$eject$red$!name$green$!postmatch$clear')"
    }

    method Int() { nqp::where(nqp::decont(self)) }

    # XXX method goto
    method next() {
        my Mu $ex := nqp::newexception();
        nqp::setpayload($ex, nqp::decont(self));
        nqp::setextype($ex, nqp::const::CONTROL_NEXT + nqp::const::CONTROL_LABELED);
        nqp::throw($ex);
    }
    method redo() {
        my Mu $ex := nqp::newexception();
        nqp::setpayload($ex, nqp::decont(self));
        nqp::setextype($ex, nqp::const::CONTROL_REDO + nqp::const::CONTROL_LABELED);
        nqp::throw($ex);
    }
    method last() {
        my Mu $ex := nqp::newexception();
        nqp::setpayload($ex, nqp::decont(self));
        nqp::setextype($ex, nqp::const::CONTROL_LAST + nqp::const::CONTROL_LABELED);
        nqp::throw($ex);
    }
}

# From 'src/core/PseudoStash.pm'

my class X::Bind { ... }
my class X::Caller::NotDynamic { ... }

my class PseudoStash is EnumMap {
    has Mu $!ctx;
    has int $!mode;

    # Lookup modes.
    my int constant PICK_CHAIN_BY_NAME = 0;
    my int constant STATIC_CHAIN       = 1;
    my int constant DYNAMIC_CHAIN      = 2;
    my int constant PRECISE_SCOPE      = 4;
    my int constant REQUIRE_DYNAMIC    = 8;

    method new() {
        my $obj := nqp::create(self);
        my $ctx := nqp::ctxcaller(nqp::ctx());
        nqp::bindattr($obj, PseudoStash, '$!ctx', $ctx);
        nqp::bindattr($obj, EnumMap, '$!storage', nqp::ctxlexpad($ctx));
        $obj
    }

    my %pseudoers =
        'MY' => sub ($cur) {
            my $stash := nqp::clone($cur);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('MY')),
                $stash);
        },
        'CORE' => sub ($cur) {
            my Mu $ctx := nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx');
            until nqp::existskey(nqp::ctxlexpad($ctx), '!CORE_MARKER') {
                $ctx := nqp::ctxouterskipthunks($ctx);
            }
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, EnumMap, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('CORE')),
                $stash);
        },
        'CALLER' => sub ($cur) {
            my Mu $ctx := nqp::ctxcallerskipthunks(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, EnumMap, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE +| REQUIRE_DYNAMIC);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('CALLER')),
                $stash);
        },
        'OUTER' => sub ($cur) {
            my Mu $ctx := nqp::ctxouterskipthunks(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, EnumMap, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('OUTER')),
                $stash);
        },
        'LEXICAL' => sub ($cur) {
            my $stash := nqp::clone($cur);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', STATIC_CHAIN);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('LEXICAL')),
                $stash);
        },
        'OUTERS' => sub ($cur) {
            my Mu $ctx := nqp::ctxouterskipthunks(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, EnumMap, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', STATIC_CHAIN);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('OUTER')),
                $stash);
        },
        'DYNAMIC' => sub ($cur) {
            my $stash := nqp::clone($cur);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', DYNAMIC_CHAIN);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('DYNAMIC')),
                $stash);
        },
        'CALLERS' => sub ($cur) {
            my Mu $ctx := nqp::ctxcallerskipthunks(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, EnumMap, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', DYNAMIC_CHAIN +| REQUIRE_DYNAMIC);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('CALLER')),
                $stash);
        },
        'UNIT' => sub ($cur) {
            my Mu $ctx := nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx');
            until nqp::existskey(nqp::ctxlexpad($ctx), '!UNIT_MARKER') {
                $ctx := nqp::ctxouterskipthunks($ctx);
            }
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, EnumMap, '$!storage',nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('UNIT')),
                $stash);
        },
        'SETTING' => sub ($cur) {
            # Same as UNIT, but go a little further out (two steps, for
            # internals reasons).
            my Mu $ctx := nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx');
            until nqp::existskey(nqp::ctxlexpad($ctx), '!UNIT_MARKER') {
                $ctx := nqp::ctxouterskipthunks($ctx);
            }
            $ctx := nqp::ctxouter(nqp::ctxouter($ctx));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, EnumMap, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('UNIT')),
                $stash);
        },
        'OUR' => sub ($cur) {
            nqp::getlexrel(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'),
                '$?PACKAGE')
        };

    multi method AT-KEY(PseudoStash:D: Str() $key) is rw {
        my Mu $nkey := nqp::unbox_s($key);
        if %pseudoers.EXISTS-KEY($key) {
            %pseudoers{$key}(self)
        }
        elsif nqp::bitand_i($!mode, PRECISE_SCOPE) {
            my Mu $store := nqp::getattr(self, EnumMap, '$!storage');
            my Mu $res := nqp::existskey($store, $nkey) ??
                            nqp::atkey($store, $nkey) !!
                            Any;
            if !($res =:= Any) && nqp::bitand_i($!mode, REQUIRE_DYNAMIC) {
                if try !$res.VAR.dynamic {
                    X::Caller::NotDynamic.new(
                        symbol => $key,
                    ).throw;
                }
            }
            $res;
        }
        elsif nqp::bitand_i($!mode, nqp::bitor_i(DYNAMIC_CHAIN, PICK_CHAIN_BY_NAME)) && $key.substr-eq("*",1) {
            my $found := nqp::getlexreldyn(
                nqp::getattr(self, PseudoStash, '$!ctx'),
                $nkey);
            nqp::isnull($found) ?? Any !! $found
        }
        else { # STATIC_CHAIN
            my $found := nqp::getlexrel(
                nqp::getattr(self, PseudoStash, '$!ctx'),
                $nkey);
            nqp::isnull($found) ?? Any !! $found
        }
    }

    method BIND-KEY(Str() $key, \value) is rw {
        if %pseudoers.EXISTS-KEY($key) {
            X::Bind.new(target => "pseudo-package $key").throw;
        }
        elsif nqp::bitand_i($!mode, PRECISE_SCOPE) {
            my Mu $store := nqp::getattr(self, EnumMap, '$!storage');
            nqp::bindkey($store, nqp::unbox_s($key), value)
        }
        elsif nqp::bitand_i($!mode, nqp::bitor_i(DYNAMIC_CHAIN, PICK_CHAIN_BY_NAME)) && $key.substr-eq("*",1) {
            die "Binding to dynamic variables not yet implemented";
        }
        else { # STATIC_CHAIN
            die "This case of binding is not yet implemented";
        }
    }
    # for some reason we get a ambiguous dispatch error by making this a multi
    method EXISTS-KEY(PseudoStash:D: Str() $key) {
        if %pseudoers.EXISTS-KEY($key) {
            True
        }
        elsif nqp::bitand_i($!mode, PRECISE_SCOPE) {
            nqp::p6bool(nqp::existskey(
                nqp::getattr(self, EnumMap, '$!storage'),
                nqp::unbox_s($key)))
        }
        elsif nqp::bitand_i($!mode, nqp::bitor_i(DYNAMIC_CHAIN, PICK_CHAIN_BY_NAME)) && $key.substr-eq("*",1) {
            nqp::isnull(
                nqp::getlexreldyn(
                    nqp::getattr(self, PseudoStash, '$!ctx'),
                    nqp::unbox_s($key)))
                ?? False !! True
        }
        else { # STATIC_CHAIN
            nqp::isnull(
                nqp::getlexrel(
                    nqp::getattr(self, PseudoStash, '$!ctx'),
                    nqp::unbox_s($key)))
                ?? False !! True
        }
    }
}

# From 'src/core/Parameter.pm'

my class Parameter { # declared in BOOTSTRAP
    # class Parameter is Any {
    #     has str $!variable_name
    #     has Mu $!named_names
    #     has Mu $!type_captures
    #     has int $!flags
    #     has Mu $!nominal_type
    #     has Mu $!post_constraints
    #     has Mu $!coerce_type
    #     has str $!coerce_method
    #     has Mu $!sub_signature
    #     has Mu $!default_value
    #     has Mu $!container_descriptor;
    #     has Mu $!attr_package;
    #     has Mu $!why;

    my constant $SIG_ELEM_BIND_CAPTURE       = 1;
    my constant $SIG_ELEM_BIND_PRIVATE_ATTR  = 2;
    my constant $SIG_ELEM_BIND_PUBLIC_ATTR   = 4;
    my constant $SIG_ELEM_SLURPY_POS         = 8;
    my constant $SIG_ELEM_SLURPY_NAMED       = 16;
    my constant $SIG_ELEM_SLURPY_BLOCK       = 32;
    my constant $SIG_ELEM_INVOCANT           = 64;
    my constant $SIG_ELEM_MULTI_INVOCANT     = 128;
    my constant $SIG_ELEM_IS_RW              = 256;
    my constant $SIG_ELEM_IS_COPY            = 512;
    my constant $SIG_ELEM_IS_PARCEL          = 1024;
    my constant $SIG_ELEM_IS_OPTIONAL        = 2048;
    my constant $SIG_ELEM_ARRAY_SIGIL        = 4096;
    my constant $SIG_ELEM_HASH_SIGIL         = 8192;
    my constant $SIG_ELEM_IS_CAPTURE         = 32768;
    my constant $SIG_ELEM_UNDEFINED_ONLY     = 65536;
    my constant $SIG_ELEM_DEFINED_ONLY       = 131072;

    method name() {
        nqp::isnull_s($!variable_name) ?? Nil !! $!variable_name
    }

    method constraint_list() {
        nqp::isnull($!post_constraints) ?? () !!
            nqp::hllize($!post_constraints)
    }

    method constraints() {
        all(nqp::isnull($!post_constraints) ?? () !!
            nqp::hllize($!post_constraints))
    }

    method type() {
        $!nominal_type
    }

    method named() {
        !nqp::p6bool(nqp::isnull($!named_names)) ||
            nqp::p6bool($!flags +& $SIG_ELEM_SLURPY_NAMED)
    }

    method named_names() {
        if !nqp::isnull($!named_names) {
            my Int $count = nqp::p6box_i(nqp::elems($!named_names));
            my Int $i = 0;
            my @res;
            while $i < $count {
                @res.push: nqp::p6box_s(nqp::atpos($!named_names, nqp::unbox_i($i)));
                $i++;
            }
            @res;
        } else {
            ().list
        }
    }

    method positional() {
        nqp::p6bool(
            ($!flags +& ($SIG_ELEM_SLURPY_POS +| $SIG_ELEM_SLURPY_NAMED +| $SIG_ELEM_IS_CAPTURE)) == 0 &&
            nqp::isnull($!named_names)
         )
    }

    method slurpy() {
        nqp::p6bool(
            $!flags +& ($SIG_ELEM_SLURPY_POS
                        +| $SIG_ELEM_SLURPY_NAMED
                        +| $SIG_ELEM_SLURPY_BLOCK)
        )
    }

    method optional() {
        ?($!flags +& $SIG_ELEM_IS_OPTIONAL)
    }

    method parcel() {
        ?($!flags +& $SIG_ELEM_IS_PARCEL)
    }

    method capture() {
        ?($!flags +& $SIG_ELEM_IS_CAPTURE)
    }

    method rw() {
        ?($!flags +& $SIG_ELEM_IS_RW)
    }

    method copy() {
        ?($!flags +& $SIG_ELEM_IS_COPY)
    }

    method readonly() {
        !($.rw || $.copy || $.parcel)
    }

    method invocant() {
        ?($!flags +& $SIG_ELEM_INVOCANT)
    }

    method default() {
        nqp::isnull($!default_value) ?? Any !!
            $!default_value ~~ Code ?? $!default_value !! { $!default_value }
    }

    method type_captures() {
        if !nqp::isnull($!type_captures) {
            my Int $count = nqp::p6box_i(nqp::elems($!type_captures));
            my Int $i = 0;
            my @res;
            while $i < $count {
                @res.push: nqp::p6box_s(nqp::atpos($!type_captures, nqp::unbox_i($i)));
                $i++;
            }
            @res;
        } else {
            ().list
        }
    }

    method !flags() { $!flags }

    multi method ACCEPTS(Parameter:D: Parameter:D $other) {
        return False unless $other.type ~~ $.type;
        return False unless
            $!flags +& $SIG_ELEM_DEFINED_ONLY <= $other!flags +& $SIG_ELEM_DEFINED_ONLY
            and $!flags +& $SIG_ELEM_UNDEFINED_ONLY <=
                $other!flags +& $SIG_ELEM_UNDEFINED_ONLY;
        if $.sub_signature {
            return False unless $other.sub_signature ~~ $.sub_signature;
        }
        if $.named {
            return False unless $other.named;
            return False unless Set($other.named_names) (<=) Set($.named_names);
        }
        return True;
    }

    multi method perl(Parameter:D:) {
        my $perl = '';
        my $rest = '';
        my $type = $!nominal_type.^name;
        my $truemu='';

        # XXX Need a CODE_SIGIL too?
        if $!flags +& $SIG_ELEM_ARRAY_SIGIL or
            $!flags +& $SIG_ELEM_HASH_SIGIL or
            $type ~~ /^^ Callable >> / {
            $type ~~ / .*? \[ <( .* )> \] $$/;
            $perl = ~$/;
            $truemu = 'Mu ' if $perl eq 'Mu'; # Positional !~~ Positional[Mu]
        }
        else {
            $perl = $type;
        }
        if $!flags +& $SIG_ELEM_DEFINED_ONLY {
            $perl ~= ':D';
        } elsif $!flags +& $SIG_ELEM_UNDEFINED_ONLY {
            $perl ~= ':U';
        }
        $perl ~= " ::$_" for @($.type_captures);
        my $name = $.name;
        if $name {
            if $!flags +& $SIG_ELEM_IS_CAPTURE {
                $name = '|' ~ $name;
            } elsif $!flags +& $SIG_ELEM_IS_PARCEL {
                $name = '\\' ~ $name unless $name ~~ /^^ <[@$]>/;
            }
        } else {
            if $!flags +& $SIG_ELEM_IS_CAPTURE {
                $name = '|';
            } elsif $!flags +& $SIG_ELEM_IS_PARCEL {
                $name = '\\';
            } elsif $!flags +& $SIG_ELEM_ARRAY_SIGIL {
                $name = '@';
            } elsif $!flags +& $SIG_ELEM_HASH_SIGIL {
                $name = '%';
            } elsif $type ~~ /^^ Callable >> / {
                $name = '&';
            } else {
                $name = '$';
            }
        }
        my $default = self.default();
        if self.slurpy {
            $name = '*' ~ $name;
        } elsif self.named {
            my @names := self.named_names;
            $name = ':' ~ $_ ~ '(' ~ $name ~ ')'for @names;
            $name ~= '!' unless self.optional;
        } elsif self.optional && !$default {
            $name ~= '?';
        }
        if $!flags +& $SIG_ELEM_IS_RW {
            $rest ~= ' is rw';
        } elsif $!flags +& $SIG_ELEM_IS_COPY {
            $rest ~= ' is copy';
        }
        if $!flags +& $SIG_ELEM_IS_PARCEL and $name ~~ /^^ <[@$]>/ {
            $rest ~= ' is parcel';
        }
        $rest ~= ' where { ... }' if !nqp::isnull($!post_constraints);
        $rest ~= ' = { ... }' if $default;
        unless nqp::isnull($!sub_signature) {
            my $sig = $!sub_signature.perl();
            $sig ~~ s/^^ ':'//;
            $rest ~= ' ' ~ $sig;
        }
        if $name or $rest {
            $perl ~= ($perl ?? ' ' !! '') ~ $name;
            $perl ~~ s/^^ \s* Mu \s+//;
        }
        $truemu ~ $perl ~ $rest;
    }

    method sub_signature(Parameter:D:) {
        nqp::isnull($!sub_signature) ?? Any !! $!sub_signature
    }

    method set_why($why) {
        $!why := $why;
    }
}

# From 'src/core/Signature.pm'

my class Signature { # declared in BOOTSTRAP
    # class Signature is Any {
    #   has Mu $!params;          # VM's array of parameters
    #   has Mu $!returns;         # return type
    #   has Mu $!arity;           # arity
    #   has Mu $!count;           # count
    #   has Mu $!code;

    multi method ACCEPTS(Signature:D: Capture $topic) {
        nqp::p6bool(nqp::p6isbindable(self, nqp::decont($topic)));
    }

    multi method ACCEPTS(Signature:D: @topic) {
        self.ACCEPTS(@topic.Capture)
    }

    multi method ACCEPTS(Signature:D: %topic) {
        self.ACCEPTS(%topic.Capture)
    }

    multi method ACCEPTS(Signature:D: Signature:D $topic) {
        my $sclass = self.params.classify({.named});
        my $tclass = $topic.params.classify({.named});
        my @spos := $sclass{False} // ();
        my @tpos := $tclass{False} // ();

        while @spos {
            my $s;
            my $t;
            last unless $t=@tpos.shift;
            $s=@spos.shift;
            if $s.slurpy or $s.capture {
                @spos=();
                @tpos=();
                last;
            }
            if $t.slurpy or $t.capture {
                return False unless any(@spos) ~~ {.slurpy or .capture};
                @spos=();
                @tpos=();
                last;
            }
            if not $s.optional {
                return False if $t.optional
            }
            return False unless $t ~~ $s;
        }
        return False if @tpos;
        if @spos {
            return False unless @spos[0].optional or @spos[0].slurpy or @spos[0].capture;
        }

        for ($sclass{True} // ()).grep({!.optional and !.slurpy}) -> $this {
            my $other;
            return False unless $other=($tclass{True} // ()).grep(
                {!.optional and $_ ~~ $this });
            return False unless +$other == 1;
        }

        my $here=$sclass{True}.SetHash;
        my $hasslurpy=($sclass{True} // ()).grep({.slurpy}).Bool;
        for @($tclass{True} // ()) -> $other {
            my $this;

            if $other.slurpy {
                return False if any($here.keys) ~~ { .type !=:= Mu };
                return $hasslurpy;
            }
            if $this=$here.keys.grep( -> $t { $other ~~ $t }) {
                $here{$this[0]} :delete;
            }
            else {
                return False unless $hasslurpy;
            }
        }
        return True;
    }

    method arity() {
        $!arity
    }

    method count() {
        $!count
    }

    method params() {
        nqp::p6list(nqp::clone($!params), List, Mu);
    }

    # XXX TODO: Parameter separators.
    multi method perl(Signature:D:) {
        # Opening.
        my $perl = ':(';

        # Parameters.
        my $params = self.params();
        my $sep = '';
        my int $i = 0;
        while $i < $params.elems {
            my $param := $params[$i];
            $perl = $perl ~ $sep ~ $param.perl;
            # this works because methods always have at least one
            # other parameter, *%_
            $sep = ($i == 0 && $param.invocant) ?? ': ' !! ', ';
            $i = $i + 1;
        }
        if !nqp::isnull($!returns) && $!returns !=:= Mu {
            $perl ~= ' --> ' ~ $!returns.perl
        }
        # Closer.
        $perl ~ ')'
    }

    multi method gist(Signature:D:) {
        # Opening.
        my $perl = '(';

        # Parameters.
        my $params = self.params();
        my $sep = '';
        my int $i = 0;
        while $i < $params.elems {
            my $param := $params[$i];
            $perl = $perl ~ $sep ~ $param.perl.subst(/' $'$/,'');
            # this works because methods always have at least one
            # other parameter, *%_
            $sep = ($i == 0 && $param.invocant) ?? ': ' !! ', ';
            $i = $i + 1;
        }
        if !nqp::isnull($!returns) && $!returns !=:= Mu {
            $perl ~= ' --> ' ~ $!returns.perl
        }
        # Closer.
        $perl ~ ')'
    }

    method returns() { $!returns }
}

# From 'src/core/Rational.pm'

my role Rational[::NuT, ::DeT] does Real {
    has NuT $.numerator;
    has DeT $.denominator;

    multi method WHICH(Rational:D:) {
        nqp::box_s(
            nqp::concat(
                nqp::concat(nqp::unbox_s(self.^name), '|'),
                nqp::concat(
                    nqp::tostr_I($!numerator),
                    nqp::concat('/', nqp::tostr_I($!denominator))
                )
            ),
            ObjAt
        );
    }

    method new(NuT \nu = 0, DeT \de = 1) {
        my $new     := nqp::create(self);
        my $gcd     := nu gcd de;
        my $numerator   = nu div $gcd;
        my $denominator = de div $gcd;
        if $denominator < 0 {
            $numerator   = -$numerator;
            $denominator = -$denominator;
        }
        nqp::bindattr($new, self.WHAT, '$!numerator',     nqp::decont($numerator));
        nqp::bindattr($new, self.WHAT, '$!denominator',   nqp::decont($denominator));
        $new;
    }

    method nude() { $!numerator, $!denominator }
    method Num() {
        $!denominator == 0
          ?? ($!numerator < 0 ?? -Inf !! Inf)
          !! nqp::p6box_n(nqp::div_In(
                nqp::decont($!numerator),
                nqp::decont($!denominator)
             ));
    }

    method floor(Rational:D:) {
        # correct formula
        $!denominator == 1
            ?? $!numerator
            !! $!numerator div $!denominator
    }

    method ceiling(Rational:D:) {
        # correct formula
        $!denominator == 1
            ?? $!numerator
            !! ($!numerator div $!denominator + 1)
    }

    method Int() { self.truncate }

    method Bridge() { self.Num }

    multi method Str(::?CLASS:D:) {
        my $s = $!numerator < 0 ?? '-' !! '';
        my $r = self.abs;
        my $i = $r.floor;
        $r -= $i;
        $s ~= $i;
        if $r {
            $s ~= '.';
            my $want = $!denominator < 100_000
                       ?? 6
                       !! $!denominator.Str.chars + 1;
            my $f = '';
            while $r and $f.chars < $want {
                $r *= 10;
                $i = $r.floor;
                $f ~= $i;
                $r -= $i;
            }
            $f++ if  2 * $r >= 1;
            $s ~= $f;
        }
        $s;
    }

    method base($base, $digits?) {
        my $prec = $digits // ($!denominator < $base**6 ?? 6 !! $!denominator.log($base).ceiling + 1);
        my $s = $!numerator < 0 ?? '-' !! '';
        my $r = self.abs;
        my $i = $r.floor;
        my @conversion := <0 1 2 3 4 5 6 7 8 9
                           A B C D E F G H I J
                           K L M N O P Q R S T
                           U V W X Y Z>;
        $r -= $i;
        $s ~= $i.base($base);
        if $digits // $r {
            my @f;
            while @f < $prec and ($digits // $r) {
                $r *= $base;
                $i = $r.floor;
                push @f, $i;
                $r -= $i;
            }
            if 2 * $r >= 1 {
                for @f-1 ... 0 -> $x {
                    last if ++@f[$x] < $base;
                    @f[$x] = 0;
                    $s ~= ($i+1).base($base) if $x == 0; # never happens?
                }
            }
            if @f {
                $s ~= '.';
                $s ~= @conversion[@f].join;
            }
        }
        $s;
    }

    method base-repeating($base = 10) {
	return ~self, '' if self.narrow ~~ Int;
	my (@quotients, @remainders, %remainders);
	push @quotients, [div] my ($nu, $de) = self.nude;
	loop {
	    push @remainders, $nu %= $de;
	    last if %remainders{$nu}++ or $nu == 0;
	    $nu *= $base;
	    push @quotients, $nu div $de;
	}
	@quotients.=map(*.base($base));
	my @cycle = $nu ?? splice(@quotients, @remainders.first-index($nu) + 1) !! ();
	splice @quotients, 1, 0, '.';
	return @quotients.join, @cycle.join;
    }

    method succ {
        self.new($!numerator + $!denominator, $!denominator);
    }

    method pred {
        self.new($!numerator - $!denominator, $!denominator);
    }

    method norm() { self }

    method narrow(::?CLASS:D:) {
        $!denominator == 1
            ?? $!numerator
            !! self;
    }
}

# From 'src/core/Rat.pm'

my class Rat is Cool does Rational[Int, Int] {
    method Rat   (Rat:D: Real $?) { self }
    method FatRat(Rat:D: Real $?) { FatRat.new($.numerator, $.denominator); }
    method Range(Rat:U:) { Range.new(-Inf,Inf) }
    multi method perl(Rat:D:) {
        my $d = $.denominator;
        return $.numerator ~ '.0' if $d == 1;
        unless $d == 0 {
            $d div= 5 while $d %% 5;
            $d div= 2 while $d %% 2;
        }
        ($d == 1) ?? self.Str !! '<' ~ $.numerator ~ '/' ~ $.denominator ~ '>';
    }
}

my class FatRat is Cool does Rational[Int, Int] {
    method FatRat(FatRat:D: Real $?) { self }
    method Rat   (FatRat:D: Real $?) {
        $.denominator < $UINT64_UPPER
            ?? Rat.new($.numerator, $.denominator)
            !! fail "Cannot convert from FatRat to Rat because denominator is too big";
    }
    multi method perl(FatRat:D:) {
        "FatRat.new($.numerator, $.denominator)";
    }
}

sub DIVIDE_NUMBERS(Int:D \nu, Int:D \de, $t1, $t2) {
    my Int $gcd         := nu gcd de;
    my Int $numerator   := nu div $gcd;
    my Int $denominator := de div $gcd;
    my $r;
    if $denominator < 0 {
        $numerator   := -$numerator;
        $denominator := -$denominator;
    }
    if nqp::istype($t1, FatRat) || nqp::istype($t2, FatRat) {
        $r := nqp::create(FatRat);
        nqp::bindattr($r, FatRat, '$!numerator',   nqp::decont($numerator));
        nqp::bindattr($r, FatRat, '$!denominator', nqp::decont($denominator));
    } elsif $denominator < $UINT64_UPPER {
        $r := nqp::create(Rat);
        nqp::bindattr($r, Rat, '$!numerator',   nqp::decont($numerator));
        nqp::bindattr($r, Rat, '$!denominator', nqp::decont($denominator));
    } else {
        $r := nqp::p6box_n(nqp::div_In(
                nqp::decont($numerator),
                nqp::decont($denominator)
            )
        );
    }
    $r;
}

multi sub prefix:<->(Rat:D \a) {
    Rat.new(-a.numerator, a.denominator);
}
multi sub prefix:<->(FatRat:D \a) {
    FatRat.new(-a.numerator, a.denominator);
}

multi sub infix:<+>(Rational \a, Rational \b) {
    my Int $gcd := a.denominator gcd b.denominator;
    DIVIDE_NUMBERS(
        (a.numerator * (b.denominator div $gcd) + b.numerator * (a.denominator div $gcd)),
        ((a.denominator div $gcd) * b.denominator),
        a,
        b,
    );
}
multi sub infix:<+>(Rational \a, Int \b) {
    DIVIDE_NUMBERS(
        (a.numerator + b * a.denominator),
        a.denominator,
        a,
        b,
    );
}
multi sub infix:<+>(Int \a, Rational \b) {
    DIVIDE_NUMBERS(
        (a * b.denominator + b.numerator),
        b.denominator,
        a,
        b,
    );
}

multi sub infix:<->(Rational \a, Rational \b) {
    my Int $gcd = a.denominator gcd b.denominator;
    DIVIDE_NUMBERS
        a.numerator * (b.denominator div $gcd) - b.numerator * (a.denominator div $gcd),
        (a.denominator div $gcd) * b.denominator,
        a,
        b;
}

multi sub infix:<->(Rational \a, Int \b) {
    DIVIDE_NUMBERS
        a.numerator - b * a.denominator,
        a.denominator,
        a,
        b;
}

multi sub infix:<->(Int \a, Rational \b) {
    DIVIDE_NUMBERS
        a * b.denominator - b.numerator,
        b.denominator,
        a,
        b;
}

multi sub infix:<*>(Rational \a, Rational \b) {
    DIVIDE_NUMBERS
        a.numerator * b.numerator,
        a.denominator * b.denominator,
        a,
        b;
}

multi sub infix:<*>(Rational \a, Int \b) {
    DIVIDE_NUMBERS
        a.numerator * b,
        a.denominator,
        a,
        b;
}

multi sub infix:<*>(Int \a, Rational \b) {
    DIVIDE_NUMBERS
        a * b.numerator,
        b.denominator,
        a,
        b;
}

multi sub infix:</>(Rational \a, Rational \b) {
    DIVIDE_NUMBERS
        a.numerator * b.denominator,
        a.denominator * b.numerator,
        a,
        b;
}

multi sub infix:</>(Rational \a, Int \b) {
    DIVIDE_NUMBERS
        a.numerator,
        a.denominator * b,
        a,
        b;
}

multi sub infix:</>(Int \a, Rational \b) {
    DIVIDE_NUMBERS
        b.denominator * a,
        b.numerator,
        a,
        b;
}

multi sub infix:</>(Int \a, Int \b) {
    DIVIDE_NUMBERS a, b, a, b
}

multi sub infix:<%>(Rational \a, Int \b) {
    a - floor(a / b) * b
}

multi sub infix:<%>(Int \a, Rational \b) {
    a - floor(a / b) * b
}

multi sub infix:<%>(Rational \a, Rational \b) {
    a - floor(a / b) * b
}

multi sub infix:<**>(Rational \a, Int \b) {
    DIVIDE_NUMBERS
        a.numerator ** b,
        a.denominator ** b,
        a,
        b;
}

multi sub infix:<==>(Rational:D \a, Rational:D \b) {
    a.numerator == b.numerator && a.denominator == b.denominator
}
multi sub infix:<==>(Rational:D \a, Int:D \b) {
    a.numerator == b && a.denominator == 1
}
multi sub infix:<==>(Int:D \a, Rational:D \b) {
    a == b.numerator && b.denominator == 1;
}

multi sub infix:<(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator < b.numerator * a.denominator
}
multi sub infix:<(Rational:D \a, Int:D \b) {
    a.numerator  < b * a.denominator
}
multi sub infix:<(Int:D \a, Rational:D \b) {
    a * b.denominator < b.numerator
}

multi sub infix:<=(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator <= b.numerator * a.denominator
}
multi sub infix:<=(Rational:D \a, Int:D \b) {
    a.numerator  <= b * a.denominator
}
multi sub infix:<=(Int:D \a, Rational:D \b) {
    a * b.denominator <= b.numerator
}

multi sub infix:>(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator > b.numerator * a.denominator
}
multi sub infix:>(Rational:D \a, Int:D \b) {
    a.numerator  > b * a.denominator
}
multi sub infix:>(Int:D \a, Rational:D \b) {
    a * b.denominator > b.numerator
}

multi sub infix:>=(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator >= b.numerator * a.denominator
}
multi sub infix:>=(Rational:D \a, Int:D \b) {
    a.numerator  >= b * a.denominator
}
multi sub infix:>=(Int:D \a, Rational:D \b) {
    a * b.denominator >= b.numerator
}

multi sub infix:<=>(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator <=> b.numerator * a.denominator
}
multi sub infix:<=>(Rational:D \a, Int:D \b) {
    a.numerator  <=> b * a.denominator
}
multi sub infix:<=>(Int:D \a, Rational:D \b) {
    a * b.denominator <=> b.numerator
}

# From 'src/core/Complex.pm'

my class Complex is Cool does Numeric {
    has num $.re;
    has num $.im;

    proto method new(|) { * }
    multi method new(Real \re, Real \im) {
        nqp::create(self).BUILD(re, im);
    }
    submethod BUILD(Num() \re, Num() \im) {
        $!re = re;
        $!im = im;
        self;
    }

    method reals(Complex:D:) {
        (self.re, self.im);
    }

    method isNaN(Complex:D:) {
        self.re.isNaN || self.im.isNaN;
    }

    my class X::Numeric::Real { ... };
    method coerce-to-real(Complex:D: $exception-target) {
        unless $!im == 0e0 { fail X::Numeric::Real.new(target => $exception-target, reason => "imaginary part not zero", source => self);}
        $!re;
    }
    multi method Real(Complex:D:) { self.coerce-to-real(Real); }

    # should probably be eventually supplied by role Numeric
    method Num(Complex:D:) { self.coerce-to-real(Num).Num; }
    method Int(Complex:D:) { self.coerce-to-real(Int).Int; }
    method Rat(Complex:D:) { self.coerce-to-real(Rat).Rat; }

    multi method Bool(Complex:D:) {
        $!re != 0e0 || $!im != 0e0;
    }

    method Complex() { self }
    multi method Str(Complex:D:) {
        my Str $i = nqp::isnanorinf($!im) ?? '\\i' !! 'i';
        $!im < 0e0
            ?? nqp::p6box_s($!re) ~ '-' ~ nqp::p6box_s(nqp::abs_n($!im)) ~ $i
            !! nqp::p6box_s($!re) ~ '+' ~ nqp::p6box_s($!im) ~ $i;
    }

    multi method perl(Complex:D:) {
        "Complex.new($.re, $.im)";
    }
    method conj(Complex:D:) {
        Complex.new($.re, -$.im);
    }

    method abs(Complex $x:) {
        nqp::p6box_n(nqp::sqrt_n(
            nqp::add_n(
                nqp::mul_n($!re, $!re),
                nqp::mul_n($!im, $!im),
            )
        ))
    }

    method polar() {
        $.abs, $!im.atan2($!re);
    }
    multi method log(Complex:D:) {
        my Num ($mag, $angle) = self.polar;
        Complex.new($mag.log, $angle);
    }

    method sqrt(Complex:D:) {
        my Num ($mag, $angle) = self.polar;
        $mag.sqrt.unpolar($angle/2);
    }

    multi method exp(Complex:D:) {
        my Num $mag = $!re.exp;
        Complex.new($mag * $!im.cos, $mag * $!im.sin);
    }

    method roots(Complex:D: Int() $n) {
        return NaN if $n < 1;
        return self if $n == 1;
        for $!re, $!im {
            return NaN if $_ eq 'Inf' || $_ eq '-Inf' || $_ eq 'NaN';
        }

        my ($mag, $angle) = self.polar;
        $mag **= 1e0 / $n;
        (^$n).map: { $mag.unpolar( ($angle + $_ * 2e0 * pi) / $n) };
    }

    method sin(Complex:D:) {
        $!re.sin * $!im.cosh + ($!re.cos * $!im.sinh)i;
    }

    method asin(Complex:D:) {
        (Complex.new(0e0, -1e0) * log((self)i + sqrt(1e0 - self * self)));
    }

    method cos(Complex:D:) {
        $!re.cos * $!im.cosh - ($!re.sin * $!im.sinh)i;
    }

    method acos(Complex:D:) {
        (pi / 2e0) - self.asin;
    }

    method tan(Complex:D:) {
        self.sin / self.cos;
    }

    method atan(Complex:D:) {
        ((log(1e0 - (self)i) - log(1e0 + (self)i))i / 2e0);
    }

    method sec(Complex:D:) {
        1e0 / self.cos;
    }

    method asec(Complex:D:) {
        (1e0 / self).acos;
    }

    method cosec(Complex:D:) {
        1e0 / self.sin;
    }

    method acosec(Complex:D:) {
        (1e0 / self).asin;
    }

    method cotan(Complex:D:) {
        self.cos / self.sin;
    }

    method acotan(Complex:D:) {
        (1e0 / self).atan;
    }

    method sinh(Complex:D:) {
        -((Complex.new(0e0, 1e0) * self).sin)i;
    }

    method asinh(Complex:D:) {
        (self + sqrt(1e0 + self * self)).log;
    }

    method cosh(Complex:D:) {
        (Complex.new(0e0, 1e0) * self).cos;
    }

    method acosh(Complex:D:) {
        (self + sqrt(self * self - 1e0)).log;
    }

    method tanh(Complex:D:) {
        -((Complex.new(0e0, 1e0) * self).tan)i;
    }

    method atanh(Complex:D:) {
        (((1e0 + self) / (1e0 - self)).log / 2e0);
    }

    method sech(Complex:D:) {
        1e0 / self.cosh;
    }

    method asech(Complex:D:) {
        (1e0 / self).acosh;
    }

    method cosech(Complex:D:) {
        1e0 / self.sinh;
    }

    method acosech(Complex:D:) {
        (1e0 / self).asinh;
    }

    method cotanh(Complex:D:) {
        1e0 / self.tanh;
    }

    method acotanh(Complex:D:) {
        (1e0 / self).atanh;
    }

    method floor(Complex:D:) {
        Complex.new( self.re.floor, self.im.floor );
    }

    method ceiling(Complex:D:) {
        Complex.new( self.re.ceiling, self.im.ceiling );
    }

    proto method round(|) {*}
    multi method round(Complex:D:) {
        Complex.new( self.re.round, self.im.round );
    }
    multi method round(Complex:D: Real(Real) $scale) {
        Complex.new( self.re.round($scale), self.im.round($scale) );
    }

    method truncate(Complex:D:) {
        Complex.new( self.re.truncate, self.im.truncate );
    }

    method narrow(Complex:D:) {
        $!im == 0e0
            ?? $!re.narrow
            !! self;
    }
}

multi sub prefix:<->(Complex:D \a) returns Complex:D {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::neg_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re')
        )
    );
    nqp::bindattr_n( $new, Complex, '$!im',
        nqp::neg_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!im')
        )
    );
    $new;
}

multi sub abs(Complex:D \a) returns Num:D {
    my num $re = nqp::getattr_n(nqp::decont(a), Complex, '$!re');
    my num $im = nqp::getattr_n(nqp::decont(a), Complex, '$!im');
    nqp::p6box_n(nqp::sqrt_n(nqp::add_n(nqp::mul_n($re, $re), nqp::mul_n($im, $im))));
}

multi sub infix:<+>(Complex:D \a, Complex:D \b) returns Complex:D {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::add_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n( $new, Complex, '$!im',
        nqp::add_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!im'),
            nqp::getattr_n(nqp::decont(b), Complex, '$!im'),
        )
    );
    $new;
}

multi sub infix:<+>(Complex:D \a, Num(Real) \b) returns Complex:D {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::add_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            nqp::unbox_n(b)
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::getattr_n(nqp::decont(a), Complex, '$!im'),
    );
    $new
}

multi sub infix:<+>(Num(Real) \a, Complex:D \b) returns Complex:D {
    my $new := nqp::create(Complex);
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::add_n(
            nqp::unbox_n(a),
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::getattr_n(nqp::decont(b), Complex, '$!im'),
    );
    $new;
}

multi sub infix:<->(Complex:D \a, Complex:D \b) returns Complex:D {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::sub_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::sub_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!im'),
            nqp::getattr_n(nqp::decont(b), Complex, '$!im'),
        )
    );
    $new
}

multi sub infix:<->(Complex:D \a, Num(Real) \b) returns Complex:D {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::sub_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            b,
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::getattr_n(nqp::decont(a), Complex, '$!im')
    );
    $new
}

multi sub infix:<->(Num(Real) \a, Complex:D \b) returns Complex:D {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::sub_n(
            a,
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::neg_n(
            nqp::getattr_n(nqp::decont(b), Complex, '$!im')
        )
    );
    $new
}

multi sub infix:<*>(Complex:D \a, Complex:D \b) returns Complex:D {
    my num $a_re = nqp::getattr_n(nqp::decont(a), Complex, '$!re');
    my num $a_im = nqp::getattr_n(nqp::decont(a), Complex, '$!im');
    my num $b_re = nqp::getattr_n(nqp::decont(b), Complex, '$!re');
    my num $b_im = nqp::getattr_n(nqp::decont(b), Complex, '$!im');
    my $new := nqp::create(Complex);
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::sub_n(nqp::mul_n($a_re, $b_re), nqp::mul_n($a_im, $b_im)),
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::add_n(nqp::mul_n($a_re, $b_im), nqp::mul_n($a_im, $b_re)),
    );
    $new;
}

multi sub infix:<*>(Complex:D \a, Num(Real) \b) returns Complex:D {
    my $new := nqp::create(Complex);
    my num $b_num = b;
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::mul_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            $b_num,
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::mul_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!im'),
            $b_num,
        )
    );
    $new
}

multi sub infix:<*>(Num(Real) \a, Complex:D \b) returns Complex:D {
    my $new := nqp::create(Complex);
    my num $a_num = a;
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::mul_n(
            $a_num,
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::mul_n(
            $a_num,
            nqp::getattr_n(nqp::decont(b), Complex, '$!im'),
        )
    );
    $new
}

multi sub infix:</>(Complex:D \a, Complex:D \b) returns Complex:D {
    my num $a_re = nqp::getattr_n(nqp::decont(a), Complex, '$!re');
    my num $a_im = nqp::getattr_n(nqp::decont(a), Complex, '$!im');
    my num $b_re = nqp::getattr_n(nqp::decont(b), Complex, '$!re');
    my num $b_im = nqp::getattr_n(nqp::decont(b), Complex, '$!im');
    my num $d    = nqp::add_n(nqp::mul_n($b_re, $b_re), nqp::mul_n($b_im, $b_im));
    my $new := nqp::create(Complex);
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::div_n(
            nqp::add_n(nqp::mul_n($a_re, $b_re), nqp::mul_n($a_im, $b_im)),
            $d,
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::div_n(
            nqp::sub_n(nqp::mul_n($a_im, $b_re), nqp::mul_n($a_re, $b_im)),
            $d,
        )
    );
    $new;
}

multi sub infix:</>(Complex:D \a, Real \b) returns Complex:D {
    Complex.new(a.re / b, a.im / b);
}

multi sub infix:</>(Real \a, Complex:D \b) returns Complex:D {
    Complex.new(a, 0e0) / b;
}

multi sub infix:<**>(Complex:D \a, Complex:D \b) returns Complex:D {
    (a.re == 0e0 && a.im == 0e0) ?? Complex.new(0e0, 0e0) !! (b * a.log).exp
}
multi sub infix:<**>(Num(Real) \a, Complex:D \b) returns Complex:D {
    a == 0e0 ?? Complex.new(0e0, 0e0) !! (b * a.log).exp
}
multi sub infix:<**>(Complex:D \a, Num(Real) \b) returns Complex:D {
    (b * a.log).exp
}

multi sub infix:<==>(Complex:D \a, Complex:D \b) returns Bool:D { a.re == b.re && a.im == b.im }
multi sub infix:<==>(Complex:D \a, Num(Real) \b) returns Bool:D { a.re == b    && a.im == 0e0  }
multi sub infix:<==>(Num(Real) \a, Complex:D \b) returns Bool:D { a    == b.re && 0e0  == b.im }

proto sub postfix:<i>(|) returns Complex:D is pure { * }
multi sub postfix:<i>(Real      \a) returns Complex:D { Complex.new(0e0, a);     }
multi sub postfix:<i>(Complex:D \a) returns Complex:D { Complex.new(-a.im, a.re) }
multi sub postfix:<i>(Numeric   \a) returns Complex:D { a * Complex.new(0e0, 1e0) }
multi sub postfix:<i>(Cool      \a) returns Complex:D { a.Numeric * Complex.new(0e0, 1e0) }

constant i = Complex.new(0e0, 1e0);

# From 'src/core/Backtrace.pm'

my class Exception { ... }

my class Backtrace { ... }

my class Backtrace::Frame {
    has Str $.file;
    has Int $.line;
    has Mu  $.code;
    has Str $.subname;

    method subtype(Backtrace::Frame:D:) {
        my $s = $!code.^name.lc.split('+', 2)[0];
        $s eq 'mu' ?? '' !! $s;
    }

    method package(Backtrace::Frame:D:) {
        $.code.package;
    }

    multi method Str(Backtrace::Frame:D:) {
        my $s = self.subtype;
        $s ~= ' ' if $s.chars;
        "  in {$s}$.subname at {$.file}:$.line\n"
    }

    method is-hidden(Backtrace::Frame:D:)  { $!code.?is-hidden-from-backtrace }
    method is-routine(Backtrace::Frame:D:) { nqp::istype($!code,Routine) }
    method is-setting(Backtrace::Frame:D:) { $!file.ends-with("CORE.setting") }
}

my class Backtrace is List {
    proto method new(|) {*}

    multi method new(Exception $e, Int $offset = 0) {
        self.new(nqp::backtrace(nqp::getattr(nqp::decont($e), Exception, '$!ex')), $offset);
    }

    multi method new() {
        try { die() };
        self.new($!, 2);
    }

    # note that backtraces are nqp::list()s, marshalled to us as Parcel
    multi method new(Parcel $bt, Int $offset = 0) {
        my $new = self.bless();
        for $offset .. $bt.elems - 1 {
            next unless defined $bt[$_]<sub>;
            my Mu $sub := nqp::getattr(nqp::decont($bt[$_]<sub>), ForeignCode, '$!do');
            next if nqp::isnull($sub);
            my $code;
            try {
                $code := nqp::getcodeobj($sub);
                $code := Any unless nqp::istype($code, Mu);
            };
            my $line     = $bt[$_]<annotations><line>;
            my $file     = $bt[$_]<annotations><file>;
            next unless $line && $file;
            # now *that's* an evil hack
            next if $file eq 'src/gen/BOOTSTRAP.nqp' ||
                    $file eq 'src/gen/m-BOOTSTRAP.nqp' ||
                    $file eq 'src\\gen\\BOOTSTRAP.nqp' ||
                    $file eq 'src\\gen\\m-BOOTSTRAP.nqp' ||
                    $file eq 'gen/jvm/stage2/QRegex.nqp' ||
                    $file eq 'gen/moar/stage2/QRegex.nqp';
            last if $file eq 'src/stage2/gen/NQPHLL.nqp' ||
                    $file eq 'src\\stage2\\gen\\NQPHLL.nqp' ||
                    $file eq 'gen/jvm/stage2/NQPHLL.nqp' ||
                    $file eq 'gen\\jvm\\stage2\\NQPHLL.nqp' ||
                    $file eq 'gen/moar/stage2/NQPHLL.nqp' ||
                    $file eq 'gen\\moar\\stage2\\NQPHLL.nqp';
            my $subname  = nqp::p6box_s(nqp::getcodename($sub));
            $subname = '<anon>' if $subname.starts-with("_block");
            last if $subname eq 'handle-begin-time-exceptions';
            $new.push: Backtrace::Frame.new(
                :line($line.Int),
                :$file,
                :$subname,
                :$code,
            );
        }
        $new;
    }

    method next-interesting-index(Backtrace:D:
      Int $idx is copy = 0, :$named, :$noproto) {
        ++$idx;
        # NOTE: the < $.end looks like an off-by-one error
        # but it turns out that a simple   perl6 -e 'die "foo"'
        # has two bt frames from the mainline; so it's OK to never
        # consider the last one
        loop (; $idx < self.end; ++$idx) {
            my $cand = self.AT-POS($idx);
            next if $cand.is-hidden;          # hidden is never interesting
            next if $named && !$cand.subname; # only want named ones
            next if $noproto                  # no proto's please
              && $cand.code.?is_dispatcher;   #  if a dispatcher
            return $idx;
        }
        Int;
    }

    method outer-caller-idx(Backtrace:D: Int $startidx) {
        my %print;
        my $start   = self.AT-POS($startidx).code;
        return $startidx.list unless $start;
        my $current = $start.outer;
        my %outers;
        while $current.DEFINITE {
            %outers{$current.static_id} = $start;
            $current = $current.outer;
        }
        my @outers;
        loop (my Int $i = $startidx; $i < $.end; ++$i) {
            if self.AT-POS($i).code.DEFINITE && %outers{self.AT-POS($i).code.static_id}.DEFINITE {
                @outers.push: $i;
                return @outers if self.AT-POS($i).is-routine;
            }
        }

        return @outers;
    }

    method nice(Backtrace:D: :$oneline) {
        try {
            my @frames;
            my Int $i = self.next-interesting-index(-1);
            while $i.defined {
                $i = self.next-interesting-index($i)
                    while $oneline && $i.defined
                          && self.AT-POS($i).is-setting;

                last unless $i.defined;
                my $prev = self.AT-POS($i);
                if $prev.is-routine {
                    @frames.push: $prev;
                } else {
                    my @outer_callers := self.outer-caller-idx($i);
                    my ($target_idx) = @outer_callers.keys.grep({self.AT-POS($i).code.^isa(Routine)});
                    $target_idx    ||= @outer_callers[0] || $i;
                    my $current = self.AT-POS($target_idx);
                    @frames.push: $current.clone(line => $prev.line);
                    $i = $target_idx;
                }
                last if $oneline;
                $i = self.next-interesting-index($i);
            }
            return @frames.join;
            CATCH {
                default {
                    return "<Internal error while creating backtrace: $_.message() $_.backtrace.full().\n"
                        ~ "Please report this as a bug (mail to rakudobug@perl.org)\n",
                        ~ "and re-run with the --ll-exception command line option\n"
                        ~ "to get more information about your error>";
                }
            }
        }
    }


    method concise(Backtrace:D:) {
        self.grep({ !.is-hidden && .is-routine && !.is-setting }).join
    }

    multi method Str(Backtrace:D:) {
        self.nice;
    }

    method full(Backtrace:D:) {
        self.join
    }

    method summary(Backtrace:D:) {
        self.grep({ !.is-hidden && (.is-routine || !.is-setting )}).join
    }
}

# From 'src/core/Exception.pm'

my class Failure { ... }
my role X::Comp { ... }
my class X::ControlFlow { ... }

my class Exception {
    has $!ex;

    method backtrace() { Backtrace.new(self) }

    multi method Str(Exception:D:) {
        self.?message.Str // 'Something went wrong'
    }

    multi method gist(Exception:D:) {
        my $str = try self.?message;
        return "Error while creating error string: $!" if $!;
        $str ~= "\n";
        try $str ~= self.backtrace;
        return "$str\nError while creating backtrace: $!.message()\n$!.backtrace.full();" if $!;
        return $str;
    }

    method throw() is hidden-from-backtrace {
        nqp::bindattr(self, Exception, '$!ex', nqp::newexception())
            unless nqp::isconcrete($!ex);
        nqp::setpayload($!ex, nqp::decont(self));
        my $msg := self.?message;
        nqp::setmessage($!ex, nqp::unbox_s($msg.Str))
            if $msg.defined;
        nqp::throw($!ex)
    }
    method rethrow() is hidden-from-backtrace {
        nqp::setpayload($!ex, nqp::decont(self));
        nqp::rethrow($!ex)
    }

    method resumable() {
        nqp::p6bool(nqp::istrue(nqp::atkey($!ex, 'resume')));
    }

    method resume() {
        nqp::resume($!ex);
        True
    }

    method die(Exception:D:) { self.throw }
    method fail(Exception:D:) {
        try self.throw;
        my $fail := Failure.new($!);
        my Mu $return := nqp::getlexcaller('RETURN');
        $return($fail) unless nqp::isnull($return);
        $fail
    }

    method is-compile-time { False }
}

my class X::AdHoc is Exception {
    has $.payload;
    method message() { $.payload.Str     }
    method Numeric() { $.payload.Numeric }
}

my class X::Dynamic::NotFound is Exception {
    has $.name;
    method message() {
        "Dynamic variable $.name not found";
    }
}
my class X::Method::NotFound is Exception {
    has $.invocant;
    has $.method;
    has $.typename;
    has Bool $.private = False;
    method message() {
        my $message = $.private
          ?? "No such private method '$.method' for invocant of type '$.typename'"
          !! "No such method '$.method' for invocant of type '$.typename'";
        if $.method eq 'length' {
            $message ~= "\nDid you mean 'elems', 'chars', 'graphs' or 'codes'?";
        }
        elsif $.method eq 'bytes' {
            $message ~= "\nDid you mean '.encode(\$encoding).bytes'?";
        }
        $message;
    }
}

my class X::Method::InvalidQualifier is Exception {
    has $.method;
    has $.invocant;
    has $.qualifier-type;
    method message() {
          "Cannot dispatch to method $.method on {$.qualifier-type.^name} "
        ~ "because it is not inherited or done by {$.invocant.^name}";
    }
}

my class X::Role::Parametric::NoSuchCandidate is Exception {
    has Mu $.role;
    method message {
        "No appropriate parametric role variant available for '"
        ~ $.role.^name
        ~ "'";
    }
}

sub EXCEPTION(|) {
    my Mu $vm_ex   := nqp::shift(nqp::p6argvmarray());
    my Mu $payload := nqp::getpayload($vm_ex);
    if nqp::p6bool(nqp::istype($payload, Exception)) {
        nqp::bindattr($payload, Exception, '$!ex', $vm_ex);
        $payload;
    } else {
        my int $type = nqp::getextype($vm_ex);
        my $ex;
        if
            nqp::p6box_s(nqp::getmessage($vm_ex)) ~~ /"Method '" (.*?) "' not found for invocant of class '" (.+)\'$/ {

            $ex := X::Method::NotFound.new(
                method   => ~$0,
                typename => ~$1,
            );
        }
        else {

            $ex := nqp::create(X::AdHoc);
            nqp::bindattr($ex, X::AdHoc, '$!payload', nqp::p6box_s(nqp::getmessage($vm_ex)));
        }
        nqp::bindattr($ex, Exception, '$!ex', $vm_ex);
        $ex;
    }
}

my class X::Comp::AdHoc { ... }
sub COMP_EXCEPTION(|) {
    my Mu $vm_ex   := nqp::shift(nqp::p6argvmarray());
    my Mu $payload := nqp::getpayload($vm_ex);
    if nqp::p6bool(nqp::istype($payload, Exception)) {
        nqp::bindattr($payload, Exception, '$!ex', $vm_ex);
        $payload;
    } else {
        my $ex := nqp::create(X::Comp::AdHoc);
        nqp::bindattr($ex, Exception, '$!ex', $vm_ex);
        nqp::bindattr($ex, X::AdHoc, '$!payload', nqp::p6box_s(nqp::getmessage($vm_ex)));
        $ex;
    }
}


do {
    sub is_runtime($bt) {
        for $bt.keys {
            try {
                my Mu $sub := nqp::getattr(nqp::decont($bt[$_]<sub>), ForeignCode, '$!do');
                my Mu $codeobj := nqp::ifnull(nqp::getcodeobj($sub), Mu);
                my $is_nqp = $codeobj && $codeobj.^name eq 'NQPRoutine';
                return True if nqp::iseq_s(nqp::getcodename($sub), 'eval') && $is_nqp;
                return False if nqp::iseq_s(nqp::getcodename($sub), 'compile') && $is_nqp;
            }
        }
        return False;
    }


    sub print_exception(|) is hidden-from-backtrace {
        my Mu $ex := nqp::atpos(nqp::p6argvmarray(), 0);
        try {
            my $e := EXCEPTION($ex);
            my Mu $err := nqp::getstderr();

            if $e.is-compile-time || is_runtime(nqp::backtrace($ex)) {
                nqp::printfh($err, $e.gist);
                nqp::printfh($err, "\n");
            }
            else {
                nqp::printfh($err, "===SORRY!===\n");
                nqp::printfh($err, $e.Str);
                nqp::printfh($err, "\n");
            }
            THE_END();
        }
        if $! {
            nqp::rethrow(nqp::getattr(nqp::decont($!), Exception, '$!ex'));
            $ex
        }
    }

    sub print_control(|) is hidden-from-backtrace {
        my Mu $ex := nqp::atpos(nqp::p6argvmarray(), 0);
        my int $type = nqp::getextype($ex);
        if ($type == nqp::const::CONTROL_WARN) {
            my Mu $err := nqp::getstderr();
            my $msg = nqp::p6box_s(nqp::getmessage($ex));
            nqp::printfh($err, $msg.chars ?? "$msg" !! "Warning");
            nqp::printfh($err, Backtrace.new(nqp::backtrace($ex), 0).nice(:oneline));
            nqp::printfh($err, "\n");
            nqp::resume($ex)
        }
        if ($type == nqp::const::CONTROL_LAST) {
            X::ControlFlow.new(illegal => 'last', enclosing => 'loop construct').throw;
        }
        if ($type == nqp::const::CONTROL_NEXT) {
            X::ControlFlow.new(illegal => 'next', enclosing => 'loop construct').throw;
        }
        if ($type == nqp::const::CONTROL_REDO) {
            X::ControlFlow.new(illegal => 'redo', enclosing => 'loop construct').throw;
        }
        if ($type == nqp::const::CONTROL_PROCEED) {
            X::ControlFlow.new(illegal => 'proceed', enclosing => 'when clause').throw;
        }
        if ($type == nqp::const::CONTROL_SUCCEED) {
            # XXX: should work like leave() ?
            X::ControlFlow.new(illegal => 'succeed', enclosing => 'when clause').throw;
        }
        if ($type == nqp::const::CONTROL_TAKE) {
            X::ControlFlow.new(illegal => 'take', enclosing => 'gather').throw;
        }
    }

    my Mu $comp := nqp::getcomp('perl6');
    $comp.^add_method('handle-exception',
        method (|) {
            my Mu $ex := nqp::atpos(nqp::p6argvmarray(), 1);
            print_exception($ex);
            nqp::exit(1);
            0;
        }
    );
    $comp.^add_method('handle-control',
        method (|) {
            my Mu $ex := nqp::atpos(nqp::p6argvmarray(), 1);
            print_control($ex);
            nqp::rethrow($ex);
        }
    );

}

my role X::OS {
    has $.os-error;
}

my role X::IO does X::OS { };

my class X::IO::Rename does X::IO is Exception {
    has $.from;
    has $.to;
    method message() {
        "Failed to rename '$.from' to '$.to': $.os-error"
    }
}

my class X::IO::Copy does X::IO is Exception {
    has $.from;
    has $.to;
    method message() {
        "Failed to copy '$.from' to '$.to': $.os-error"
    }
}

my class X::IO::DoesNotExist does X::IO is Exception {
    has $.path;
    has $.trying;
    method message() {
        "Failed to find '$.path' while trying to do '.$.trying'"
    }
}

my class X::IO::NotAFile does X::IO is Exception {
    has $.path;
    has $.trying;
    method message() {
        "'$.path' is not a regular file while trying to do '.$.trying'"
    }
}

my class X::IO::Directory does X::IO is Exception {
    has $.path;
    has $.trying;
    has $.use;
    method message () {
        my $x = "'$.path' is a directory, cannot do '.$.trying' on a directory";
        if $.use { $x ~= ", try '{$.use}()' instead" }
        $x;
    }
}

my class X::IO::Symlink does X::IO is Exception {
    has $.target;
    has $.name;
    method message() {
        "Failed to create symlink called '$.name' on target '$.target': $.os-error"
    }
}

my class X::IO::Link does X::IO is Exception {
    has $.target;
    has $.name;
    method message() {
        "Failed to create link called '$.name' on target '$.target': $.os-error"
    }
}

my class X::IO::Mkdir does X::IO is Exception {
    has $.path;
    has $.mode;
    method message() {
        "Failed to create directory '$.path' with mode '0o{$.mode.fmt("%03o")}': $.os-error"
    }
}

my class X::IO::Chdir does X::IO is Exception {
    has $.path;
    method message() {
        "Failed to change the working directory to '$.path': $.os-error"
    }
}

my class X::IO::Dir does X::IO is Exception {
    has $.path;
    method message() {
        "Failed to get the directory contents of '$.path': $.os-error"
    }
}

my class X::IO::Cwd does X::IO is Exception {
    method message() {
        "Failed to get the working directory: $.os-error"
    }
}

my class X::IO::Rmdir does X::IO is Exception {
    has $.path;
    method message() {
        "Failed to remove the directory '$.path': $.os-error"
    }
}

my class X::IO::Unlink does X::IO is Exception {
    has $.path;
    method message() {
        "Failed to remove the file '$.path': $.os-error"
    }
}

my class X::IO::Chmod does X::IO is Exception {
    has $.path;
    has $.mode;
    method message() {
        "Failed to set the mode of '$.path' to '0o{$.mode.fmt("%03o")}': $.os-error"
    }
}

my role X::Comp is Exception {
    has $.filename;
    has $.line;
    has $.column;
    has @.modules;
    has $.is-compile-time = False;
    has $.pre;
    has $.post;
    has @.highexpect;
    multi method gist(::?CLASS:D: :$sorry = True, :$expect = True) {
        if $.is-compile-time {
            my $is-win := $*DISTRO.is-win;
            my $color = %*ENV<RAKUDO_ERROR_COLOR> // !$is-win;
            my ($red, $green, $yellow, $clear) = $color
                ?? ("\e[31m", "\e[32m", "\e[33m", "\e[0m")
                !! ("", "", "", "");
            my $eject = $is-win ?? "<HERE>" !! "\x[23CF]";
            my $r = $sorry ?? self.sorry_heading() !! "";
            $r ~= "$.message\nat $.filename():$.line";
            $r ~= "\n------> $green$.pre$yellow$eject$red$.post$clear" if defined $.pre;
            if $expect && @.highexpect {
                $r ~= "\n    expecting any of:";
                for @.highexpect {
                    $r ~= "\n        $_";
                }
            }
            for @.modules.reverse[1..*] {
                my $line = nqp::p6box_i($_<line>);
                $r ~= $_<module>.defined
                        ?? "\n  from module $_<module> ($_<filename>:$line)"
                        !! "\n  from $_<filename>:$line";
            }
            $r;
        }
        else {
            self.Exception::gist;
        }
    }
    method sorry_heading() {
        my $color = %*ENV<RAKUDO_ERROR_COLOR> // !$*DISTRO.is-win;
        my ($red, $clear) = $color ?? ("\e[31m", "\e[0m") !! ("", "");
        "$red==={$clear}SORRY!$red===$clear Error while compiling $.filename\n"
    }
    method SET_FILE_LINE($file, $line) {
        $!filename = $file;
        $!line     = $line;
        $!is-compile-time = True;
    }
}

my class X::Comp::Group is Exception {
    has $.panic;
    has @.sorrows;
    has @.worries;

    method is-compile-time() { True }

    multi method gist(::?CLASS:D:) {
        my $r = "";
        if $.panic || @.sorrows {
            my $color = %*ENV<RAKUDO_ERROR_COLOR> // !$*DISTRO.is-win;
            my ($red, $clear) = $color ?? ("\e[31m", "\e[0m") !! ("", "");
            $r ~= "$red==={$clear}SORRY!$red===$clear\n";
            for @.sorrows {
                $r ~= .gist(:!sorry, :!expect) ~ "\n";
            }
            if $.panic {
                $r ~= $.panic.gist(:!sorry) ~ "\n";
            }
        }
        if @.worries {
            $r ~= $.panic || @.sorrows
                ?? "Other potential difficulties:\n"
                !! "Potential difficulties:\n";
            for @.worries {
                $r ~= .gist(:!sorry, :!expect).indent(4) ~ "\n";
            }
        }
        $r
    }

    method message() {
        my @m;
        for @.sorrows {
            @m.push(.message);
        }
        if $.panic {
            @m.push($.panic.message);
        }
        for @.worries {
            @m.push(.message);
        }
        @m.join("\n")
    }
}

my role X::MOP is Exception { }

my class X::Comp::BeginTime does X::Comp {
    has $.use-case;
    has $.exception;

    method message() {
        $!exception ~~ X::MOP
            ?? $!exception.message
            !! "An exception occurred while $!use-case"
    }

    multi method gist(::?CLASS:D: :$sorry = True) {
        my $r = $sorry ?? self.sorry_heading() !! "";
        $r ~= "$.message\nat $.filename():$.line";
        for @.modules.reverse[1..*] {
            my $line = nqp::p6box_i($_<line>);
            $r ~= $_<module>.defined
                    ?? "\n  from module $_<module> ($_<filename>:$line)"
                    !! "\n  from $_<filename>:$line";
        }
        unless $!exception ~~ X::MOP {
            $r ~= "\nException details:\n" ~ $!exception.gist.indent(2);
        }
        $r;
    }
}

my class X::Comp::AdHoc is X::AdHoc does X::Comp {
    method is-compile-time() { True }
}

my role X::Syntax does X::Comp { }
my role X::Pod                 { }

my class X::NYI is Exception {
    has $.feature;
    method message() { "$.feature not yet implemented. Sorry. " }
}
my class X::Comp::NYI is X::NYI does X::Comp { };

my class X::Trait::Unknown is Exception {
    has $.type;       # is, will, of etc.
    has $.subtype;    # wrong subtype being tried
    has $.declaring;  # variable, sub, parameter, etc.
    method message () {
        "Can't use unknown trait '$.type $.subtype' in a$.declaring declaration."
    }
}
my class X::Comp::Trait::Unknown is X::Trait::Unknown does X::Comp { };

my class X::Trait::NotOnNative is Exception {
    has $.type;       # is, will, of etc.
    has $.subtype;    # wrong subtype being tried
    has $.native;     # type of native (optional)
    method message () {
        "Can't use trait '$.type $.subtype' on a native"
          ~ ( $.native ?? " $.native." !! "." );
    }
}
my class X::Comp::Trait::NotOnNative is X::Trait::NotOnNative does X::Comp { };

my class X::Trait::Scope is Exception {
    has $.type;       # is, will, of etc.
    has $.subtype;    # export
    has $.declaring;  # type name of the object
    has $.scope;      # not supported (but used) scope
    has $.supported;  # hint about what is allowed instead
    method message () {
        "Can't apply trait '$.type $.subtype' on a $.scope scoped $.declaring."
        ~ ( $.supported ?? " Only {$.supported.join(' and ')} scoped {$.declaring}s are supported." !! '' );
    }
}
my class X::Comp::Trait::Scope is X::Trait::Scope does X::Comp { };

my class X::OutOfRange is Exception {
    has $.what = 'Argument';
    has $.got = '<unknown>';
    has $.range = '<unknown>';
    has $.comment;
    method message() {
        $.comment.defined
           ?? "$.what out of range. Is: $.got, should be in $.range.gist(); $.comment"
           !! "$.what out of range. Is: $.got, should be in $.range.gist()"
    }
}

my class X::Buf::AsStr is Exception {
    has $.method;
    method message() {
        "Cannot use a Buf as a string, but you called the $.method method on it";
    }
}
my class X::Buf::Pack is Exception {
    has $.directive;
    method message() {
        "Unrecognized directive '$.directive'";
    }
}

my class X::Buf::Pack::NonASCII is Exception {
    has $.char;
    method message() {
        "non-ASCII character '$.char' while processing an 'A' template in pack";
    }
}

my class X::Signature::Placeholder does X::Comp {
    has $.placeholder;
    method message() {
        "Placeholder variable '$.placeholder' cannot override existing signature";
    }
}

my class X::Placeholder::Block does X::Comp {
    has $.placeholder;
    method message() {
        "Placeholder variable $.placeholder may not be used here because the surrounding block takes no signature";
    }
}

my class X::Placeholder::NonPlaceholder does X::Comp {
    has $.variable_name;
    has $.placeholder;
    has $.decl;
    method message() {
        my $decl = $!decl ?? ' ' ~ $!decl !! '';
        "$!variable_name has already been used as a non-placeholder in the surrounding$decl block,\n" ~
        "  so you will confuse the reader if you suddenly declare $!placeholder here"
    }
}

my class X::Placeholder::Mainline is X::Placeholder::Block {
    method message() {
        "Cannot use placeholder parameter $.placeholder in the mainline"
    }
}

my class X::Placeholder::Attribute is X::Placeholder::Block {
    method message() {
        "Cannot use placeholder parameter $.placeholder in an attribute initializer"
    }
}

my class X::Undeclared does X::Comp {
    has $.what = 'Variable';
    has $.symbol;
    has @.suggestions;
    method message() {
        my $message := "$.what '$.symbol' is not declared";
        if +@.suggestions == 1 {
            $message := "$message. Did you mean '@.suggestions[0]'?";
        } elsif +@.suggestions > 1 {
            $message := "$message. Did you mean any of these?\n    { @.suggestions.join("\n    ") }\n";
        }
        $message;
    }
}

my class X::Attribute::Undeclared is X::Undeclared {
    has $.package-kind;
    has $.package-name;

    method message() {
        "Attribute $.symbol not declared in $.package-kind $.package-name";
    }
}

my class X::Attribute::Regex is X::Undeclared {
    method message() {
        "Attribute $.symbol not available inside of a regex, since regexes are methods on Cursor.\n" ~
            "Consider storing the attribute in a lexical, and using that in the regex.";
    }
}

my class X::Undeclared::Symbols does X::Comp {
    has %.post_types;
    has %.unk_types;
    has %.unk_routines;
    has %.routine_suggestion;
    has %.type_suggestion;
    multi method gist(X::Undeclared::Symbols:D: :$sorry = True) {
        ($sorry ?? self.sorry_heading() !! "") ~ self.message
    }
    method message(X::Undeclared::Symbols:D:) {
        sub l(@l) {
            my @lu = @l.map({ nqp::hllize($_) }).unique.sort;
            'used at line' ~ (@lu == 1 ?? ' ' !! 's ') ~ @lu.join(', ')
        }
        sub s(@s) {
            "Did you mean '{ @s.join("', '") }'?";
        }
        my $r = "";
        if %.post_types {
            $r ~= "Illegally post-declared type" ~ (%.post_types.elems == 1 ?? "" !! "s") ~ ":\n";
            for %.post_types.sort(*.key) {
                $r ~= "    $_.key() &l($_.value)\n";
            }
        }
        if %.unk_types {
            $r ~= "Undeclared name" ~ (%.unk_types.elems == 1 ?? "" !! "s") ~ ":\n";
            for %.unk_types.sort(*.key) {
                $r ~= "    $_.key() &l($_.value)";
                if +%.type_suggestion{$_.key()} {
                    $r ~= ". " ~ s(%.type_suggestion{$_.key()});
                }
                $r ~= "\n";
            }
        }
        if %.unk_routines {
            my $obs = {
                y => "tr",
                qr => "rx",
                local => "temp (or dynamic var)",
                new => "method call syntax",
                foreach => "for",
            }
            $r ~= "Undeclared routine" ~ (%.unk_routines.elems == 1 ?? "" !! "s") ~ ":\n";
            for %.unk_routines.sort(*.key) {
                $r ~= "    $_.key() &l($_.value)";
                $r ~= " (in Perl 6 please use " ~ $obs{$_.key()} ~ " instead)" if $obs{$_.key()};
                if +%.routine_suggestion{$_.key()} {
                    $r ~= ". " ~ s(%.routine_suggestion{$_.key()});
                }
                $r ~= "\n";
            }
        }
        $r
    }
}

my class X::Redeclaration does X::Comp {
    has $.symbol;
    has $.postfix = '';
    has $.what    = 'symbol';
    method message() {
        "Redeclaration of $.what $.symbol$.postfix";
    }
}

my class X::Redeclaration::Outer does X::Comp {
    has $.symbol;
    method message() {
        "Lexical symbol '$.symbol' is already bound to an outer symbol;\n" ~
        "the implicit outer binding must be rewritten as OUTER::<$.symbol>\n" ~
        "before you can unambiguously declare a new '$.symbol' in this scope";
    }
}

my class X::Import::Redeclaration does X::Comp {
    has @.symbols;
    has $.source-package-name;
    method message() {
        @.symbols == 1
            ?? "Cannot import symbol @.symbols[0] from $.source-package-name, because it already exists in this lexical scope"
            !! ("Cannot import the following symbols from $.source-package-name, because they already exist in this lexical scope: ", @.symbols.join(', '));
    }
}

my class X::Import::OnlystarProto does X::Comp {
    has @.symbols;
    has $.source-package-name;
    method message() {
        @.symbols == 1
            ?? "Cannot import symbol @.symbols[0] from $.source-package-name, only onlystar-protos can be merged"
            !! ("Cannot import the following symbols from $.source-package-name, only onlystar-protos can be merged: ", @.symbols.join(', '));
    }
}

my class X::PoisonedAlias does X::Comp {
    has $.alias;
    has $.package-type = 'package';
    has $.package-name;
    method message() {
        "Cannot use poisoned alias $!alias, because it was declared by several {$!package-type}s." ~
        ($!package-name ?? "\nPlease access it via explicit package name like: {$!package-name}::{$!alias}" !! '')
    }
}

my class X::Phaser::Multiple does X::Comp {
    has $.block;
    method message() { "Only one $.block block is allowed" }
}

my class X::Obsolete does X::Comp {
    has $.old;
    has $.replacement; # can't call it $.new, collides with constructor
    has $.when = 'in Perl 6';
    method message() { "Unsupported use of $.old; $.when please use $.replacement" }
}

my class X::Parameter::Default does X::Comp {
    has $.how;
    has $.parameter;
    method message() {
        $.parameter
            ?? "Cannot put default on $.how parameter $.parameter"
            !! "Cannot put default on anonymous $.how parameter";
    }
}

my class X::Parameter::AfterDefault does X::Syntax {
    has $.type;
    has $.modifier;
    has $.default;
    method message() {
        "The $.type \"$.modifier\" came after the default value\n"
        ~ "(did you mean \"...$.modifier $.default\"?)"
    }
}

my class X::Parameter::Placeholder does X::Comp {
    has $.parameter;
    has $.right;
    method message() {
        "In signature parameter, placeholder variables like $.parameter are illegal\n"
        ~ "you probably meant a named parameter: '$.right'";
    }
}

my class X::Parameter::Twigil does X::Comp {
    has $.parameter;
    has $.twigil;
    method message() {
        "In signature parameter $.parameter, it is illegal to use the $.twigil twigil";
    }
}

my class X::Parameter::MultipleTypeConstraints does X::Comp {
    has $.parameter;
    method message() {
        ($.parameter ?? "Parameter $.parameter" !! 'A parameter')
        ~ " may only have one prefix type constraint";
    }
}

my class X::Parameter::WrongOrder does X::Comp {
    has $.misplaced;
    has $.parameter;
    has $.after;
    method message() {
        "Cannot put $.misplaced parameter $.parameter after $.after parameters";
    }
}

my class X::Parameter::InvalidType does X::Comp {
    has $.typename;
    has @.suggestions;
    method message() {
        my $msg := "Invalid typename '$.typename' in parameter declaration.";
        if +@.suggestions > 0 {
            $msg := $msg ~ " Did you mean '" ~ @.suggestions.join("', '") ~ "'?";
        }
        return $msg;
    }
}

my class X::Signature::NameClash does X::Comp {
    has $.name;
    method message() {
        "Name $.name used for more than one named parameter";
    }
}

my class X::Method::Private::Permission does X::Comp {
    has $.method;
    has $.source-package;
    has $.calling-package;
    method message() {
        "Cannot call private method '$.method' on package $.source-package because it does not trust $.calling-package";
    }
}

my class X::Method::Private::Unqualified does X::Comp {
    has $.method;
    method message() {
        "Private method call to $.method must be fully qualified with the package containing the method";
    }
}

my class X::Bind is Exception {
    has $.target;
    method message() {
        $.target.defined
            ?? "Cannot bind to $.target"
            !! 'Cannot use bind operator with this left-hand side'
    }
}
my class X::Bind::NativeType does X::Comp {
    has $.name;
    method message() {
        "Cannot bind to natively typed variable '$.name'; use assignment instead"
    }
}
my class X::Bind::Slice is Exception  {
    has $.type;
    method message() {
        "Cannot bind to {$.type.^name} slice";
    }
}
my class X::Bind::ZenSlice is X::Bind::Slice {
    method message() {
        "Cannot bind to {$.type.^name} zen slice";
    }
}

my class X::Subscript::Negative is Exception {
    has $.index;
    has $.type;
    method message() {
        "Calculated index ({$.index}) is negative, but {$.type.^name} allows only 0-based indexing";
    }
}

my class X::Value::Dynamic does X::Comp {
    has $.what;
    method message() { "$.what value must be known at compile time" }
}

my class X::Syntax::Name::Null does X::Syntax {
    method message() { 'Name component may not be null'; }
}

my class X::Syntax::UnlessElse does X::Syntax {
    method message() { '"unless" does not take "else", please rewrite using "if"' }
}

my class X::Syntax::KeywordAsFunction does X::Syntax {
    has $.word;
    has $.needparens;
    method message {
        "Word '$.word' interpreted as '{$.word}()' function call; please use whitespace "
            ~ ($.needparens ?? 'around the parens' !! 'instead of parens')
    }
}

my class X::Syntax::Malformed::Elsif does X::Syntax {
    has $.what = 'else if';
    method message() { qq{In Perl 6, please use "elsif' instead of "$.what"} }
}

my class X::Syntax::Reserved does X::Syntax {
    has $.reserved;
    has $.instead = '';
    method message() { "The $.reserved is reserved$.instead" }
}

my class X::Syntax::P5 does X::Syntax {
    method message() { 'This appears to be Perl 5 code' }
}

my class X::Syntax::NegatedPair does X::Syntax {
    has $.key;
    method message() { "Argument not allowed on negated pair with key '$.key'" }
}

my class X::Syntax::Variable::Numeric does X::Syntax {
    has $.what = 'variable';
    method message() { "Cannot declare a numeric $.what" }
}

my class X::Syntax::Variable::Match does X::Syntax {
    method message() { 'Cannot declare a match variable' }
}

my class X::Syntax::Variable::Twigil does X::Syntax {
    has $.twigil;
    has $.scope;
    method message() { "Cannot use $.twigil twigil on $.scope variable" }
}

my class X::Syntax::Variable::IndirectDeclaration does X::Syntax {
    method message() { 'Cannot declare a variable by indirect name (use a hash instead?)' }
}

my class X::Syntax::Augment::WithoutMonkeyTyping does X::Syntax {
    method message() { "augment not allowed without 'use MONKEY-TYPING'" };
}

my class X::Syntax::Augment::Illegal does X::Syntax {
    has $.package;
    method message() { "Cannot augment $.package because it is closed" };
}

my class X::Syntax::Argument::MOPMacro does X::Syntax {
    has $.macro;
    method message() { "Cannot give arguments to $.macro" };
}

my class X::Role::Initialization is Exception {
    has $.role;
    method message() { "Can only supply an initialization value for a role if it has a single public attribute, but this is not the case for '{$.role.^name}'" }
}

my class X::Syntax::Comment::Embedded does X::Syntax {
    method message() { "Opening bracket required for #` comment" }
}

my class X::Syntax::Pod::BeginWithoutIdentifier does X::Syntax does X::Pod {
    method message() {
        '=begin must be followed by an identifier; (did you mean "=begin pod"?)'
    }
}

my class X::Syntax::Pod::BeginWithoutEnd does X::Syntax does X::Pod {
    has $.type;
    has $.spaces;
    method message() { "'=begin' not terminated by matching '$.spaces=end $.type'" }
}

my class X::Syntax::Confused does X::Syntax {
    has $.reason = 'unknown';
    method message() { $.reason eq 'unknown' ?? 'Confused' !! $.reason }
}

my class X::Syntax::Malformed does X::Syntax {
    has $.what;
    method message() { "Malformed $.what" }
}
my class X::Syntax::Missing does X::Syntax {
    has $.what;
    method message() { "Missing $.what" }
}
my class X::Syntax::BlockGobbled does X::Syntax {
    has $.what;
    method message() { "{ $.what ?? 'Function ' ~ $.what !! 'Expression' } needs parens to avoid gobbling block" };
}

my class X::Syntax::ConditionalOperator::PrecedenceTooLoose does X::Syntax {
    has $.operator;
    method message() { "Precedence of $.operator is too loose to use inside ?? !!; please parenthesize" }
}

my class X::Syntax::ConditionalOperator::SecondPartGobbled does X::Syntax {
    method message() { "Your !! was gobbled by the expression in the middle; please parenthesize" }
}

my class X::Syntax::ConditionalOperator::SecondPartInvalid does X::Syntax {
    has $.second-part;
    method message() { "Please use !! rather than $.second-part" }
}

my class X::Syntax::Perl5Var does X::Syntax {
    has $.name;
    my %m =
      '$*'  => '^^ and $$',
      '$"'  => '.join() method',
      '$$'  => '$*PID',
      '$('  => '$*GID',
      '$)'  => '$*EGID',
      '$<'  => '$*UID',
      '$>'  => '$*EUID',
      '$;'  => 'real multidimensional hashes',
      '$&'  => '$<>',
      '$`'  => '$/.prematch',
      '$\'' => '$/.postmatch',
      '$,'  => '$*OUT.output_field_separator()',
      '$.'  => "the filehandle's .line method",
      '$/'  => "the filehandle's .nl attribute",
      '$\\' => "the filehandle's .nl attribute",
      '$|'  => ':autoflush on open',
      '$?'  => '$! for handling child errors also',
      '$@'  => '$!',
      '$#'  => '.fmt',
      '$['  => 'user-defined array indices',
      '$]'  => '$*PERL.version or $*PERL.compiler.version',

      '$^C' => 'COMPILING namespace',
      '$^D' => '$*DEBUGGING',
      '$^E' => '$!.extended_os_error',
      '$^F' => '$*SYSTEM_FD_MAX',
      '$^H' => '$?FOO variables',
      '$^I' => '$*INPLACE',
      '$^M' => 'a global form such as $*M',
      '$^N' => '$/[*-1]',
      '$^O' => '$?DISTRO.name or $*DISTRO.name',
      '$^R' => 'an explicit result variable',
      '$^S' => 'context function',
      '$^T' => '$*BASETIME',
      '$^V' => '$*PERL.version or $*PERL.compiler.version',
      '$^W' => '$*WARNING',
      '$^X' => '$*EXECUTABLE_NAME',

      '$:'  => 'Form module',
      '$-'  => 'Form module',
      '$+'  => 'Form module',
      '$='  => 'Form module',
      '$%'  => 'Form module',
      '$^'  => 'Form module',
      '$~'  => 'Form module',
      '$^A' => 'Form module',
      '$^L' => 'Form module',

      '@-'  => '.from method',
      '@+'  => '.to method',

      '%-'  => '.from method',
      '%+'  => '.to method',
      '%^H' => '$?FOO variables',
    ;
    method message() {
        my $v = $.name ~~ m/ <[ $ @ % & ]> [ \^ <[ A..Z ]> | \W ] /;
        $v
          ?? %m{~$v}
            ?? "Unsupported use of $v variable; in Perl 6 please use {%m{~$v}}"
            !! "Unsupported use of $v variable"
          !! 'Weird unrecognized variable name: ' ~ $.name;
    }
}

my class X::Syntax::Self::WithoutObject does X::Syntax {
    method message() { "'self' used where no object is available" }
}
my class X::Syntax::VirtualCall does X::Syntax {
    has $.call;
    method message() { "Virtual call $.call may not be used on partially constructed objects" }
}
my class X::Syntax::NoSelf does X::Syntax {
    has $.variable;
    method message() { "Variable $.variable used where no 'self' is available" }
}

my class X::Syntax::Number::RadixOutOfRange does X::Syntax {
    has $.radix;
    method message() { "Radix $.radix out of range (allowed: 2..36)" }
}

my class X::Syntax::Number::IllegalDecimal does X::Syntax {
    method message() { "Decimal point must be followed by digit" }
}

my class X::Syntax::NonAssociative does X::Syntax {
    has $.left;
    has $.right;
    method message() {
        "Operators '$.left' and '$.right' are non-associative and require parentheses";
    }
}

my class X::Syntax::Can'tMeta does X::Syntax {
    has $.meta;
    has $.operator;
    has $.reason;
    has $.dba;
    method message() {
        "Cannot $.meta $.operator because $.dba operators are $.reason";
    }
}

my class X::Syntax::Regex::Adverb does X::Syntax {
    has $.adverb;
    has $.construct;
    method message() { "Adverb $.adverb not allowed on $.construct" }
}

my class X::Syntax::Regex::UnrecognizedMetachar does X::Syntax {
    has $.metachar;
    method message() { "Unrecognized regex metacharacter $.metachar (must be quoted to match literally)" }
}

my class X::Syntax::Regex::NullRegex does X::Syntax {
    method message() { 'Null regex not allowed' }
}

my class X::Syntax::Regex::MalformedRange does X::Syntax {
    method message() { 'Malformed Range' }
}

my class X::Syntax::Regex::Unspace does X::Syntax {
    has $.char;
    method message { "No unspace allowed in regex; if you meant to match the literal character, " ~
        "please enclose in single quotes ('" ~ $.char ~ "') or use a backslashed form like \\x" ~
        sprintf('%02x', $.char.ord)
    }
}

my class X::Syntax::Regex::Unterminated does X::Syntax {
    method message { 'Regex not terminated.' }
}

my class X::Syntax::Regex::SpacesInBareRange does X::Syntax {
    method message { 'Spaces not allowed in bare range.' }
}

my class X::Syntax::Regex::SolitaryQuantifier does X::Syntax {
    method message { 'Quantifier quantifies nothing' }
}

my class X::Syntax::Term::MissingInitializer does X::Syntax {
    method message { 'Term definition requires an initializer' }
}

my class X::Syntax::AddCategorical::TooFewParts does X::Syntax {
    has $.category;
    has $.needs;
    method message() { "Not enough symbols provided for categorical of type $.category; needs $.needs" }
}

my class X::Syntax::AddCategorical::TooManyParts does X::Syntax {
    has $.category;
    has $.needs;
    method message() { "Too many symbols provided for categorical of type $.category; needs only $.needs" }
}

my class X::Syntax::Signature::InvocantMarker does X::Syntax {
    method message() {
        "Can only use : as invocant marker in a signature after the first parameter"
    }
}

my class X::Syntax::Extension::Category does X::Syntax {
    has $.category;
    method message() {
        "Cannot add tokens of category '$.category'";
    }
}

my class X::Syntax::Extension::Null does X::Syntax {
    method message() {
        "Null operator is not allowed";
    }
}

my class X::Syntax::InfixInTermPosition does X::Syntax {
    has $.infix;
    method message() {
        "Preceding context expects a term, but found infix $.infix instead";
    }
}

my class X::Syntax::DuplicatedPrefix does X::Syntax {
    has $.prefixes;
    method message() {
        my $prefix = $.prefixes.substr(0, 1);
        "Expected a term, but found either infix $.prefixes or redundant prefix $prefix\n"
        ~ "  (to suppress this message, please use a space like $prefix $prefix)";
    }
}

my class X::Syntax::ArgFlattener does X::Syntax {
    method message() { "Arg-flattening | is only valid in an argument list" }
}

my class X::Attribute::Package does X::Comp {
    has $.package-kind;
    has $.name;
    method message() { "A $.package-kind cannot have attributes, but you tried to declare '$.name'" }
}
my class X::Attribute::NoPackage does X::Comp {
    has $.name;
    method message() { "You cannot declare attribute '$.name' here; maybe you'd like a class or a role?" }
}
my class X::Declaration::Scope does X::Comp {
    has $.scope;
    has $.declaration;
    method message() { "Cannot use '$.scope' with $.declaration declaration" }
}

my class X::Declaration::Scope::Multi is X::Declaration::Scope {
    method message() {
        "Cannot use '$.scope' with individual multi candidates. Please declare an {$.scope}-scoped proto instead";
    }
}

my class X::Anon::Multi does X::Comp {
    has $.multiness;
    has $.routine-type = 'routine';
    method message() { "An anonymous $.routine-type may not take a $.multiness declarator" }
}
my class X::Anon::Augment does X::Comp {
    has $.package-kind;
    method message() { "Cannot augment anonymous $.package-kind" }
}
my class X::Augment::NoSuchType does X::Comp {
    has $.package-kind;
    has $.package;
    method message() { "You tried to augment $.package-kind $.package, but it does not exist" }
}

my class X::Routine::Unwrap is Exception {
    method message() { "Cannot unwrap routine: invalid wrap handle" }
}

my class X::Constructor::Positional is Exception {
    has $.type;
    method message() { "Default constructor for '" ~ $.type.^name ~ "' only takes named arguments" }
}

my class X::Hash::Store::OddNumber is Exception {
    method message() { "Odd number of elements found where hash initializer expected" }
}

my class X::Pairup::OddNumber is Exception {
    method message() { "Odd number of elements found for .pairup()" }
}

my class X::Match::Bool is Exception {
    has $.type;
    method message() { "Cannot use Bool as Matcher with '" ~ $.type ~ "'.  Did you mean to use \$_ inside a block?" }
}

my class X::Package::Stubbed does X::Comp {
    has @.packages;
    # TODO: suppress display of line number
    method message() {
        "The following packages were stubbed but not defined:\n    "
        ~ @.packages.join("\n    ");
    }
}

my class X::Phaser::PrePost is Exception {
    has $.phaser = 'PRE';
    has $.condition;
    method message {
        my $what = $.phaser eq 'PRE' ?? 'Precondition' !! 'Postcondition';
        $.condition.defined
            ?? "$what '$.condition.trim()' failed"
            !! "$what failed";
    }
}

my class X::Str::Numeric is Exception {
    has $.source;
    has $.pos;
    has $.reason;
    method source-indicator {
        constant marker = chr(0x23CF);
        join '', "in '",
                substr($.source,0, $.pos),
                marker,
                substr($.source,$.pos),
                "' (indicated by ",
                marker,
                ")",
                ;
    }
    method message() {
        "Cannot convert string to number: $.reason $.source-indicator";
    }
}

my class X::Str::Match::x is Exception {
    has $.got;
    method message() {
        "in Str.match, got invalid value of type {$.got.^name} for :x, must be Int or Range"
    }
}

my class X::Str::Trans::IllegalKey is Exception {
    has $.key;
    method message {
        "in Str.trans, got illegal substitution key of type {$.key.^name} (should be a Regex or Str)"
    }
}
my class X::Str::Trans::InvalidArg is Exception {
    has $.got;
    method message() {
        "Only Pair objects are allowed as arguments to Str.trans, got {$.got.^name}";
    }
}

my class X::Range::InvalidArg is Exception {
    has $.got;
    method message() {
        "{$.got.^name} objects are not valid endpoints for Ranges";
    }
}

my class X::Sequence::Deduction is Exception {
    has $.from;
    method message() {
        $!from ?? "Unable to deduce arithmetic or geometric sequence from $!from (or did you really mean '..'?)"
               !! 'Unable to deduce sequence for some unfathomable reason'
    }
}

my class X::Cannot::Infinite is Exception {
    has $.action;
    has $.what;
    method message() {
        $.what
          ?? "Cannot $.action an infinite list onto a $.what"
          !! "Cannot $.action an infinite list";
    }
}
my class X::Cannot::Empty is Exception {
    has $.action;
    has $.what;
    method message() {
        "Cannot $.action from an empty $.what";
    }
}

my class X::Backslash::UnrecognizedSequence does X::Syntax {
    has $.sequence;
    method message() { "Unrecognized backslash sequence: '\\$.sequence'" }
}

my class X::Backslash::NonVariableDollar does X::Syntax {
    method message() { "Non-variable \$ must be backslashed" }
}

my class X::ControlFlow is Exception {
    has $.illegal;   # something like 'next'
    has $.enclosing; # ....  outside a loop

    method message() { "$.illegal without $.enclosing" }
}
my class X::ControlFlow::Return is X::ControlFlow {
    method illegal()   { 'return'  }
    method enclosing() { 'Routine' }
    method message()   { 'Attempt to return outside of any Routine' }
}

my class X::Composition::NotComposable does X::Comp {
    has $.target-name;
    has $.composer;
    method message() {
        $.composer.^name ~ " is not composable, so $.target-name cannot compose it";
    }
}

my class X::TypeCheck is Exception {
    has $.operation;
    has $.got;
    has $.expected;
    method gotn()      { (try $!got.^name)      // "?" }
    method expectedn() { (try $!expected.^name) // "?" }
    method message() {
        "Type check failed in $.operation; expected '$.expectedn' but got '$.gotn'";

    }
}

my class X::TypeCheck::Binding is X::TypeCheck {
    has $.symbol;
    method operation { 'binding' }
    method message() {
        if $.symbol {
            "Type check failed in $.operation $.symbol; expected '$.expectedn' but got '$.gotn'";
        } else {
            "Type check failed in $.operation; expected '$.expectedn' but got '$.gotn'";
        }
    }
}
my class X::TypeCheck::Return is X::TypeCheck {
    method operation { 'returning' }
    method message() {
        "Type check failed for return value; expected '$.expectedn' but got '$.gotn'";
    }
}
my class X::TypeCheck::Assignment is X::TypeCheck {
    has $.symbol;
    method operation { 'assignment' }
    method message {
        $.symbol.defined
            ?? "Type check failed in assignment to '$.symbol'; expected '$.expectedn' but got '$.gotn'"
            !! "Type check failed in assignment; expected '$.expectedn' but got '$.gotn'";
    }
}
my class X::TypeCheck::Argument is X::TypeCheck {
    has $.protoguilt;
    has @.arguments;
    has $.objname;
    has $.signature;
    method message {
            my $multi = $!signature ~~ /\n/ // '';
            "Calling {$!objname}({ join(', ', @!arguments) }) will never work with " ~ (
                $!protoguilt ?? 'proto signature ' !!
                $multi       ?? 'any of these multi signatures:' !!
                                'declared signature '
            ) ~ $!signature;
    }
}

my class X::TypeCheck::Splice is X::TypeCheck does X::Comp {
    has $.action;
    method message {
        "Type check failed in {$.action}; expected '$.expectedn' but got '$.gotn'";
    }

}

my class X::Assignment::RO is Exception {
    has $.typename = "value";
    method message {
        "Cannot modify an immutable {$.typename}";
    }
}

my class X::Assignment::RO::Comp does X::Comp {
    has $.variable;
    method message {
        "Cannot assign to readonly variable {$.variable}"
    }
}

my class X::Immutable is Exception {
    has $.typename;
    has $.method;
    method message {
        "Cannot call '$.method' on an immutable '$.typename'";
    }
}

my class X::NoDispatcher is Exception {
    has $.redispatcher;
    method message() {
        "$.redispatcher is not in the dynamic scope of a dispatcher";
    }
}

my class X::Localizer::NoContainer is Exception {
    has $.localizer;
    method message() {
        "Can only use '$.localizer' on a container";
    }
}

my class X::Mixin::NotComposable is Exception {
    has $.target;
    has $.rolish;
    method message() {
        "Cannot mix in non-composable type {$.rolish.^name} into object of type {$.target.^name}";
    }
}

my class X::Inheritance::Unsupported does X::Comp {
    # note that this exception is thrown before the child type object
    # has been composed, so it's useless to carry it around. Use the
    # name instead.
    has $.child-typename;
    has $.parent;
    method message {
        $.parent.^name ~ ' does not support inheritance, so '
        ~ $.child-typename ~ ' cannot inherit from it';
    }
}

my class X::Inheritance::UnknownParent is Exception {
    has $.child;
    has $.parent;
    has @.suggestions is rw;

    method message {
        my $message := "'" ~ $.child ~ "' cannot inherit from '" ~ $.parent ~ "' because it is unknown.";
        if +@.suggestions > 1 {
            $message := $message ~ "\nDid you mean one of these?\n    '" ~ @.suggestions.join("'\n    '") ~ "'\n";
        } elsif +@.suggestions == 1 {
            $message := $message ~ "\nDid you mean '" ~ @.suggestions[0] ~ "'?\n";
        }
        return $message;
    }
}

my class X::Inheritance::SelfInherit is Exception {
    has $.name;

    method message {
        "'$.name' cannot inherit from itself."
    }
}

my class X::Export::NameClash does X::Comp {
    has $.symbol;
    method message() {
        "A symbol '$.symbol' has already been exported";
    }
}

my class X::HyperOp::NonDWIM is Exception {
    has &.operator;
    has $.left-elems;
    has $.right-elems;
    method message() {
        "Lists on either side of non-dwimmy hyperop of &.operator.name() are not of the same length\n"
        ~ "left: $.left-elems elements, right: $.right-elems elements";
    }
}

my class X::HyperOp::Infinite is Exception {
    has &.operator;
    has $.side;
    method message() {
        $.side eq "both"
            ?? "Lists on both sides of hyperop of &.operator.name() are known to be infinite"
            !! "List on $.side side of hyperop of &.operator.name() is known to be infinite"
    }
}

my class X::Set::Coerce is Exception {
    has $.thing;
    method message {
        "Cannot coerce object of type {$.thing.^name} to Set. To create a one-element set, pass it to the 'set' function";
    }
}


my role X::Temporal is Exception { }
my class X::Temporal::InvalidFormat does X::Temporal {
    has $.invalid-str;
    has $.target = 'Date';
    has $.format;
    method message() {
        "Invalid $.target string '$.invalid-str'; use $.format instead";
    }
}
my class X::DateTime::TimezoneClash does X::Temporal {
    method message() {
        'DateTime.new(Str): :timezone argument not allowed with a timestamp offset';
    }
}
my class X::DateTime::InvalidDeltaUnit does X::Temporal {
    has $.unit;
    method message() {
        "Cannnot use unit $.unit with Date.delta";
    }
}

my class X::Eval::NoSuchLang is Exception {
    has $.lang;
    method message() {
        "No compiler available for language '$.lang'";
    }
}

my class X::Import::MissingSymbols is Exception {
    has $.from;
    has @.missing;
    method message() {
        "Trying to import from '$.from', but the following symbols are missing: "
            ~ @.missing.join(', ');
    }
}

my class X::Numeric::Real is Exception {
    has $.target;
    has $.reason;
    has $.source;

    method message() {
        "Can not convert $.source to {$.target.^name}: $.reason";
    }
}

my class X::Numeric::DivideByZero is Exception {
    has $.using;
    method message() {
        "Divide by zero" ~ ( $.using ?? " using $.using" !! '' );
    }
}

my class X::Numeric::Confused is Exception {
    has $.what;
    method message() {
        "You have confused the number $.what with the textual representation \"$.what\";\n"
            ~ "if you wanted to render the number in the given base, use \$number.base(\$radix)";
    }
}

my class X::PseudoPackage::InDeclaration does X::Comp {
    has $.pseudo-package;
    has $.action;
    method message() {
        "Cannot use pseudo package $.pseudo-package in $.action";
    }
}

my class X::NoSuchSymbol is Exception {
    has $.symbol;
    method message { "No such symbol '$.symbol'" }
}

my class X::Item is Exception {
    has $.aggregate;
    has $.index;
    method message { "Cannot index {$.aggregate.^name} with $.index" }
}

my class X::Multi::Ambiguous is Exception {
    has $.dispatcher;
    has @.ambiguous;
    has $.capture;
    method message {
        join "\n",
            "Ambiguous call to '$.dispatcher.name()'; these signatures all match:",
            @.ambiguous.map(*.signature.perl)
    }
}

my class X::Multi::NoMatch is Exception {
    has $.dispatcher;
    has $.capture;
    method message {
        my @cand = $.dispatcher.dispatchees.map(*.signature.gist);
        my $where = so first / where /, @cand;
        my @bits;
        if $.capture {
            for $.capture.list {
                @bits.push($where ?? .perl !! .WHAT.perl );
            }
            for $.capture.hash {
                if .value ~~ Bool {
                    @bits.push(':' ~ ('!' x !.value) ~ .key);
                }
                else {
                    @bits.push(":{.key}({$where ?? .value.perl !! .value.WHAT.perl })");
                }
            }
        }
        else {
            @bits.push('...');
        }
        if @cand[0] ~~ /': '/ {
            my $invocant = @bits.shift;
            my $first = @bits ?? @bits.shift !! '';
            @bits.unshift($invocant ~ ': ' ~ $first);
        }
        my $cap = '(' ~ @bits.join(", ") ~ ')';
        join "\n    ",
            "Cannot call $.dispatcher.name()$cap; none of these signatures match:",
            @cand;
    }
}

my class X::Caller::NotDynamic is Exception {
    has $.symbol;
    method message() {
        "Cannot access '$.symbol' through CALLER, because it is not declared as dynamic";
    }
}

my class X::Inheritance::NotComposed does X::MOP {
    # normally, we try very hard to capture the types
    # and not just their names. But in this case, both types
    # involved aren't composed yet, so they basically aren't
    # usable at all.
    has $.child-name;
    has $.parent-name;
    method message() {
        "'$.child-name' cannot inherit from '$.parent-name' because '$.parent-name' isn't compose yet"
            ~ ' (maybe it is stubbed)';
    }
}

{
    my %c_ex;
    %c_ex{'X::TypeCheck::Binding'} := sub (Mu $got, Mu $expected, $symbol?) is hidden-from-backtrace {
            X::TypeCheck::Binding.new(:$got, :$expected, :$symbol).throw;
        };
    %c_ex<X::TypeCheck::Assignment> := sub (Mu $symbol, Mu $got, $expected) is hidden-from-backtrace {
            X::TypeCheck::Assignment.new(:$symbol, :$got, :$expected).throw;
        };
    %c_ex{'X::TypeCheck::Return'} := sub (Mu $got, Mu $expected) is hidden-from-backtrace {
            X::TypeCheck::Return.new(:$got, :$expected).throw;
        };
    %c_ex<X::Assignment::RO> := sub ($typename = "value") is hidden-from-backtrace {
            X::Assignment::RO.new(:$typename).throw;
        };
    %c_ex{'X::ControlFlow::Return'} := sub () is hidden-from-backtrace {
            X::ControlFlow::Return.new().throw;
        };
    %c_ex{'X::NoDispatcher'} := sub ($redispatcher) is hidden-from-backtrace {
            X::NoDispatcher.new(:$redispatcher).throw;
        };
    %c_ex{'X::Multi::Ambiguous'} := sub ($dispatcher, @ambiguous, $capture) is hidden-from-backtrace {
            X::Multi::Ambiguous.new(:$dispatcher, :@ambiguous, :$capture).throw
        };
    %c_ex{'X::Multi::NoMatch'} := sub ($dispatcher, $capture) is hidden-from-backtrace {
            X::Multi::NoMatch.new(:$dispatcher, :$capture).throw
        };
    %c_ex{'X::Role::Initialization'} := sub ($role) is hidden-from-backtrace {
            X::Role::Initialization.new(:$role).throw
        }
    %c_ex{'X::Role::Parametric::NoSuchCandidate'} := sub (Mu $role) is hidden-from-backtrace {
        X::Role::Parametric::NoSuchCandidate.new(:$role).throw;
        }
    %c_ex{'X::Inheritance::NotComposed'} = sub ($child-name, $parent-name) is hidden-from-backtrace {
        X::Inheritance::NotComposed.new(:$child-name, :$parent-name).throw;
    }
    nqp::bindcurhllsym('P6EX', nqp::getattr(%c_ex, EnumMap, '$!storage'));

    0;
}

my class X::HyperWhatever::Multiple is Exception {
    method message() {
        "Multiple HyperWhatevers and Whatevers may not be used together"
    }
}

my class X::EXPORTHOW::InvalidDirective does X::Comp {
    has $.directive;
    method message() {
        "Unknown EXPORTHOW directive '$.directive' encountered during import"
    }
}

my class X::EXPORTHOW::NothingToSupersede does X::Comp {
    has $.declarator;
    method message() {
        "There is no package declarator '$.declarator' to supersede"
    }
}

my class X::EXPORTHOW::Conflict does X::Comp {
    has $.declarator;
    has $.directive;
    method message() {
        "'EXPORTHOW::{$.directive}::{$.declarator}' conflicts with an existing meta-object imported into this lexical scope"
    }
}

my class X::SemicolonForm::Invalid does X::Syntax {
    has $.what;
    has $.where;
    method message() {
        "Semicolon form of $.what definitions not allowed $.where;\n"
        ~ "Please use the block form."
    }
}

my class X::SemicolonForm::TooLate does X::Syntax {
    has $.what;
    method message() {
        "Too late for semicolon form of $.what definitions;\n"
        ~ "Please use the block form."
    }
}

my class X::PairMap::DoesNotExist is Exception {
    has $.key;
    has $.method;
    method message() {
        "Cannot do PairMap.$.method on non-existing key: '$.key'"
    }
}

my class X::PairMap::NotAllowed is Exception {
    has $.method;
    method message() {
        "Not allowed to do PairMap.$.method"
    }
}

# From 'src/core/Failure.pm'

my class Failure {
    has $.exception;
    has $!handled;

    method new($exception) { self.bless(:$exception) }

    # TODO: should be Failure:D: multi just like method Bool,
    # but obscure problems prevent us from making Mu.defined
    # a multi. See http://irclog.perlgeek.de/perl6/2011-06-28#i_4016747
    method defined() {
        $!handled =1 if nqp::isconcrete(self);
        Bool::False;
    }
    multi method Bool(Failure:D:) { $!handled = 1; Bool::False; }

    method Int(Failure:D:)        { $!handled ?? 0   !! $!exception.throw; }
    method Num(Failure:D:)        { $!handled ?? 0e0 !! $!exception.throw; }
    method Numeric(Failure:D:)    { $!handled ?? 0e0 !! $!exception.throw; }
    multi method Str(Failure:D:)  { $!handled ?? ''  !! $!exception.throw; }
    multi method gist(Failure:D:) { $!handled ?? $.perl !! $!exception.throw; }

    Failure.^add_fallback(
        -> $, $ { True },
        method ($name) {
            $!exception.throw;
        }
    );
    method sink() is hidden-from-backtrace {
        $!exception.throw unless $!handled
    }
}

proto sub fail(|) is hidden-from-backtrace {*};
multi sub fail(Exception $e) is hidden-from-backtrace {
    die $e if $*FATAL;
    my $fail := Failure.new($e);
    my Mu $return := nqp::getlexcaller('RETURN');
    $return($fail) unless nqp::isnull($return);
    $fail
}
multi sub fail($payload) is hidden-from-backtrace {
    die $payload if $*FATAL;
    my $fail := Failure.new(X::AdHoc.new(:$payload));
    my Mu $return := nqp::getlexcaller('RETURN');
    $return($fail) unless nqp::isnull($return);
    $fail
}
multi sub fail(*@msg) is hidden-from-backtrace {
    my $payload = @msg == 1 ?? @msg[0] !! @msg.join;
    die $payload if $*FATAL;
    my $fail := Failure.new(X::AdHoc.new(:$payload));
    my Mu $return := nqp::getlexcaller('RETURN');
    $return($fail) unless nqp::isnull($return);
    $fail
}

multi sub die(Failure:D $failure) is hidden-from-backtrace {
    $failure.exception.throw
}
multi sub die(Failure:U) is hidden-from-backtrace {
    X::AdHoc('Failure').throw
}

# From 'src/core/Match.pm'

my class Match is Capture is Cool {
    has $.orig;
    has int $.from;
    has int $.to;
    has $.CURSOR;
    has $.made;

    # new/BUILD here only for performance reasons
    method new(:$orig,:$from,:$to,:$CURSOR,:$made) {
        nqp::create(self).BUILD(:$orig,:$from,:$to,:$CURSOR,:$made);
    }
    method BUILD(:$!orig,:$from,:$to,:$!CURSOR,:$!made) {
        $!from   = $from // 0;  # cannot assign to int in sig
        $!to     = $to   // 0;  # cannot assign to int in sig
        self;
    }

    method ast(Match:D:) { $!made }

    multi method Str(Match:D:) {
        $!to > $!from ?? substr($!orig,$!from,$!to-$!from) !! ''
    }
    multi method Numeric(Match:D:) {
        self.Str.Numeric
    }
    multi method Bool(Match:D:) {
        $!to >= $!from
    }
    multi method ACCEPTS(Match:D: Any $) { self }

    method prematch(Match:D:) {
        substr($!orig,0,$!from);
    }
    method postmatch(Match:D:) {
        substr($!orig,$!to)
    }

    method caps(Match:D:) {
        my @caps;
        for self.pairs -> $p {
            if nqp::istype($p.value,Array) {
                @caps.push: $p.key => $_ for $p.value.list
            } else {
                @caps.push: $p;
            }
        }
        @caps.sort: -> $p { $p.value.from }
    }

    method chunks(Match:D:) {
        my $prev = $!from;
        gather {
            for self.caps {
                if .value.from > $prev {
                    take '~' => substr($!orig,$prev, .value.from - $prev)
                }
                take $_;
                $prev = .value.to;
            }
            take '~' => substr($!orig,$prev, $!to - $prev) if $prev < $!to;
        }
    }

    multi method perl(Match:D:) {
        my %attrs;
        for <orig from to ast list hash> {
            %attrs{$_} = self."$_"().perl;
        }

        'Match.new('
            ~ %attrs.fmt('%s => %s', ', ')
            ~ ')'
    }
    multi method gist (Match:D: $d = 0) {
        return "#<failed match>" unless self;
        my $s = ' ' x ($d + 1);
        my $r = ("=> " if $d) ~ "\x[FF62]{self}\x[FF63]\n";
        for @.caps {
            $r ~= $s ~ (.key // '?') ~ ' ' ~ .value.gist($d + 1)
        }
        $d == 0 ?? $r.chomp !! $r;
    }

    method make(Match:D: Mu \made) {
        $!made = made;
        nqp::bindattr(
            nqp::decont(self.CURSOR),
            Cursor,
            '$!made',
            made
        );
    }
}

sub make(Mu \made) {
    my $slash := nqp::getlexcaller('$/');
    nqp::bindattr( nqp::decont($slash),        Match,  '$!made', made );
    nqp::bindattr( nqp::decont($slash.CURSOR), Cursor, '$!made', made );
}


# From 'src/core/Cursor.pm'

my class Cursor does NQPCursorRole {
    has $!made; # Need it to survive re-creations of the match object.
    my Mu $EMPTY_LIST := nqp::list();
    my Mu $NO_CAPS    := nqp::hash();

    multi method Bool(Cursor:D:) {
        nqp::getattr_i(self, Cursor, '$!pos') >= nqp::getattr_i(self, Cursor, '$!from')
    }

    method MATCH() {
        my $match := nqp::getattr(self, Cursor, '$!match');
        return $match if nqp::istype($match, Match) && nqp::isconcrete($match);
        $match := nqp::create(Match);
        nqp::bindattr($match, Match, '$!orig', nqp::findmethod(self, 'orig')(self));
        my int $from = nqp::getattr_i(self, Cursor, '$!from');
        my int $to   = nqp::getattr_i(self, Cursor, '$!pos');
        nqp::bindattr_i($match, Match, '$!from', $from);
        nqp::bindattr_i($match, Match, '$!to', $to);
        nqp::bindattr($match, Match, '$!made', nqp::getattr(self, Cursor, '$!made'));
        nqp::bindattr($match, Match, '$!CURSOR', self);
        my Mu $list;
        my Mu $hash := nqp::hash();
        if $to >= $from {
            # For captures with lists, initialize the lists.
            my $caplist := $NO_CAPS;
            my $rxsub   := nqp::getattr(self, Cursor, '$!regexsub');
            if !nqp::isnull($rxsub) && nqp::defined($rxsub) {
                $caplist := nqp::can($rxsub, 'CAPS') ?? nqp::findmethod($rxsub, 'CAPS')($rxsub) !! nqp::null();
                if !nqp::isnull($caplist) && nqp::istrue($caplist) {
                    my $iter := nqp::iterator($caplist);
                    while $iter {
                        my $curcap := nqp::shift($iter);
                        my Mu $curval := nqp::iterval($curcap);
                        if (nqp::isint($curval) && nqp::isge_i($curval, 2))
                        || (nqp::isnum($curval) && nqp::p6box_n($curval) >= 2) {
                            my str $name = nqp::iterkey_s($curcap);
                            nqp::iscclass(nqp::const::CCLASS_NUMERIC, $name, 0)
                                ?? nqp::bindpos(
                                        nqp::if(nqp::isconcrete($list), $list, ($list := nqp::list())),
                                        nqp::fromstr_I($name, Int), [])
                                !! nqp::bindkey($hash, $name, []);
                        }
                    }
                }
            }

            # Walk the Cursor stack and populate the Cursor.
            my Mu $cs := nqp::getattr(self, Cursor, '$!cstack');
            if !nqp::isnull($cs) && nqp::istrue($cs) {
                my int $cselems = nqp::elems($cs);
                my int $csi     = 0;
                while $csi < $cselems {
                    my Mu $subcur   := nqp::atpos($cs, $csi);
                    my Mu $name     := nqp::getattr($subcur, $?CLASS, '$!name');
                    if !nqp::isnull($name) && nqp::defined($name) && $name ne '' {
                        my Mu $submatch := $subcur.MATCH;
                        if nqp::eqat($name, '$', 0) && ($name eq '$!from' || $name eq '$!to') {
                            nqp::bindattr_i($match, Match, $name, $submatch.from);
                        }
                        elsif nqp::index($name, '=') < 0 {
                            my Mu $capval     := nqp::atkey($caplist, $name);
                            my int $needs_list = nqp::isconcrete($capval) &&
                                ((nqp::isint($capval) && nqp::isge_i($capval, 2)) ||
                                (nqp::isnum($capval) && nqp::p6box_n($capval) >= 2));
                            if nqp::iscclass(nqp::const::CCLASS_NUMERIC, $name, 0) {
                                $list := nqp::list() unless nqp::isconcrete($list);
                                $needs_list
                                    ?? nqp::atpos($list, nqp::fromstr_I(nqp::unbox_s($name), Int)).push($submatch)
                                    !! nqp::bindpos($list, nqp::fromstr_I(nqp::unbox_s($name), Int), $submatch);
                            }
                            else {
                                $needs_list
                                    ?? nqp::atkey($hash, $name).push($submatch)
                                    !! nqp::bindkey($hash, $name, $submatch);
                            }
                        }
                        else {
                            my Mu $names := nqp::split('=', $name);
                            my $iter     := nqp::iterator($names);
                            while $iter {
                                my str $name   = nqp::unbox_s(nqp::shift($iter));
                                my Mu $capval := nqp::atkey($caplist, $name);
                                my int $needs_list = nqp::isconcrete($capval) &&
                                    ((nqp::isint($capval) && nqp::isge_i($capval, 2)) ||
                                    (nqp::isnum($capval) && nqp::p6box_n($capval) >= 2));
                                if nqp::iscclass(nqp::const::CCLASS_NUMERIC, $name, 0) {
                                    $list := nqp::list() unless nqp::isconcrete($list);
                                    $needs_list
                                        ?? nqp::atpos($list, nqp::fromstr_I($name, Int)).push($submatch)
                                        !! nqp::bindpos($list, nqp::fromstr_I($name, Int), $submatch);
                                }
                                else {
                                    $needs_list
                                        ?? nqp::atkey($hash, $name).push($submatch)
                                        !! nqp::bindkey($hash, $name, $submatch);
                                }
                            }
                        }
                    }
                    $csi = nqp::add_i($csi, 1);
                }
            }
        }
        nqp::bindattr($match, Capture, '$!list', nqp::isconcrete($list) ?? $list !! $EMPTY_LIST);
        nqp::bindattr($match, Capture, '$!hash', $hash);
        nqp::bindattr(self, Cursor, '$!match', $match);

        # Once we've produced the captures, and if we know we're finished and
        # will never be backtracked into, we can release cstack and regexsub.
        unless nqp::defined(nqp::getattr(self, Cursor, '$!bstack')) {
            nqp::bindattr(self, Cursor, '$!cstack', nqp::null());
            nqp::bindattr(self, Cursor, '$!regexsub', nqp::null());
        }

        $match;
    }

    method MATCH_SAVE() {
        nqp::getattr_i(self, Cursor, '$!pos') < 0 ?? Nil !! self.MATCH()
    }

    # INTERPOLATE will iterate over the string $tgt beginning at position 0.
    # If it can't match against pattern var (or any element of var if it is an array)
    # it will increment $pos and try again. Therefor it is important to only match
    # against the current position.
    # $i is case insensitive flag
    # $s is for sequential matching instead of junctive
    # $a is true if we are in an assertion
    method INTERPOLATE(\var, $i = 0, $s = 0, $a = 0) {
        if nqp::isconcrete(var) {
            # Call it if it is a routine. This will capture if requested.
            return (var)(self) if nqp::istype(var,Callable);
            my $maxlen := -1;
            my $cur := self.'!cursor_start_cur'();
            my $pos := nqp::getattr_i($cur, $?CLASS, '$!from');
            my $tgt := $cur.target;
            my $eos := nqp::chars($tgt);
            my $fate   := 0;
            my $count  := 0;
            my $start  := 1;
            my Mu $alts := nqp::list();
            my Mu $order := nqp::list();

            if nqp::istype(var, Positional) and !nqp::iscont(var) {
                if $s {
                    # The order matters for sequential matching, therefor no NFA involved.
                    nqp::push($order,$_) for var.list;
                }
                else {
                    my Mu $nfa := QRegex::NFA.new;
                    # prepare to run the NFA if var is array-ish.
                    for var.list -> $topic {
                        nqp::push($alts, $topic);
                        if $a {
                            # We are in a regex assertion, the strings we get will be treated as
                            # regex rules.
                            return $cur.'!cursor_start_cur'()
                              if nqp::istype($topic,Associative);
                            my $rx := MAKE_REGEX($topic, :$i);
                            my Mu $nfas := nqp::findmethod($rx, 'NFA')($rx);
                            $nfa.mergesubstates($start, 0, $fate, $nfas, Mu);
                        }
                        elsif nqp::istype($topic,Regex) {
                            # A Regex already.
                            my Mu $nfas := nqp::findmethod($topic, 'NFA')($topic);
                            $nfa.mergesubstates($start, 0, $fate, $nfas, Mu);
                        }
                        else {
                            # The pattern is a string.
                            my Mu $lit  := QAST::Regex.new( :rxtype<literal>, $topic,
                                                            :subtype( $i ?? 'ignorecase' !! '') );
                            my Mu $nfa2 := QRegex::NFA.new;
                            my Mu $node := nqp::findmethod($nfa2, 'addnode')($nfa2, $lit);
                            my Mu $save := nqp::findmethod($node, 'save')($node, :non_empty(1));
                            $nfa.mergesubstates($start, 0, $fate, $save, Mu);
                        }
                        $fate := $fate + 1;
                    }

                    # Now run the NFA
                    my Mu $fates := nqp::findmethod($nfa, 'run')($nfa, $tgt, $pos);
                    $fate        := 0;
                    $count       := nqp::elems($fates);
                    while nqp::islt_i($fate, $count) {
                        my $thing := nqp::atpos_i($fates, $fate);
                        nqp::push($order, nqp::atpos($alts, $thing));
                        $fate := nqp::add_i($fate, 1);
                    }
                }
            }
            else {
                # Use the var as it is if it's not array-ish.
                nqp::push($order, var);
            }

            my int $omax = nqp::elems($order);
            loop (my int $o = 0; $o < $omax; $o = $o + 1) {
                my Mu $topic := nqp::atpos($order,$o);
                my $match;
                my $len;

                if $a {
                    # We are in a regex assertion, the strings we get will be treated as
                    # regex rules.
                    return $cur.'!cursor_start_cur'()
                      if nqp::istype($topic,Associative);
                    my $rx := MAKE_REGEX($topic, :$i);
                    $match := (nqp::substr($tgt, $pos, $eos - $pos) ~~ $rx).Str;
                    $len   := nqp::chars( $match );
                }
                elsif nqp::istype($topic,Regex) {
                    # A Regex already.
                    $match := nqp::substr($tgt, $pos, $eos - $pos) ~~ $topic;

                    # In order to return the correct result we need to match from the
                    # current position only.
                    next if $match.from;
                    $match := ~$match;
                    $len   := nqp::chars( $match );
                }
                else {
                    # The pattern is a string.
                    my str $topic_str = $topic.Str;
                    $len   := nqp::chars( $topic_str );
                    $match := $len < 1
                            ||  ($i ?? nqp::lc(nqp::substr($tgt, $pos, $len)) eq nqp::lc($topic_str)
                                    !! nqp::eqat($tgt, $topic_str, $pos));
                }

                if $match && $len > $maxlen && $pos + $len <= $eos {
                    $maxlen := $len;
                    last if $s; # stop here for sequential alternation
                }
            }

            $cur.'!cursor_pass'($pos + $maxlen, '') if $maxlen >= 0;
            $cur
        }
        else {
            self."!cursor_start_cur"()
        }
    }

    method DYNQUANT_LIMITS($mm) {
        if nqp::istype($mm,Range) {
            die 'Range minimum in quantifier (**) cannot be +Inf' if $mm.min ==  Inf;
            die 'Range maximum in quantifier (**) cannot be -Inf' if $mm.max == -Inf;
            nqp::list_i($mm.min < 0 ?? 0 !! $mm.min.Int, $mm.max == Inf ?? -1 !! $mm.max.Int)
        }
        else {
            fail 'Fixed quantifier cannot be infinite' if $mm == -Inf || $mm == Inf;
            nqp::list_i($mm.Int, $mm.Int)
        }
    }

    method OTHERGRAMMAR($grammar, $name, |) {
        my $lang_cursor := $grammar.'!cursor_init'(self.target(), :p(self.pos()));
        $lang_cursor."$name"();
    }

    method INDRULE($rule, |c) {
        $rule(self, |c)
    }

    method RECURSE() {
        nqp::getlexdyn('$?REGEX')(self)
    }
}

sub MAKE_REGEX($arg, :$i) {
    my role CachedCompiledRegex {
        has $.regex;
    }
    if nqp::istype($arg,Regex) {
        $arg
    }
    elsif nqp::istype($arg, CachedCompiledRegex) {
        $arg.regex
    }
    else {
        my Mu $chars := nqp::split('', $arg);
        my $k := 0;
        my $iter := nqp::iterator($chars);
        while $iter {
            my $ord := nqp::ord( nqp::shift($iter) );
            nqp::bindpos($chars, $k, "\\c[$ord]") if $ord <= 32;
            $k := $k + 1;
        }
        my $arg2 := nqp::join('', $chars);
        my $rx := $i ?? EVAL("anon regex \{ :i ^$arg2\}") !! EVAL("anon regex \{ ^$arg2\}");
        $arg does CachedCompiledRegex($rx);
        $rx
    }
}

# From 'src/core/Grammar.pm'

my class Grammar is Cursor {
    method parse($target, :$rule = 'TOP',  Parcel :$args = (), Mu :$actions = Mu, *%opt) {
        my $*ACTIONS = $actions;
        my $result =
            self."!cursor_init"($target, |%opt)."$rule"(|$args).MATCH;
        $result = Nil unless $result.to == $target.chars;
        nqp::getlexcaller('$/') = $result;
    }
    method subparse($target, :$rule = 'TOP', Parcel :$args = (),  Mu :$actions = Mu, *%opt) {
        my $*ACTIONS = $actions;
        nqp::getlexcaller('$/') =
            self."!cursor_init"($target, |%opt)."$rule"(|$args).MATCH;
    }
    method parsefile(Str(Cool) $filename, :$enc, *%opts) {
        my $match := self.parse($filename.IO.slurp(:$enc), |%opts);
        nqp::getlexcaller('$/') = $match;
    }
}

# From 'src/core/Regex.pm'

my class Regex { # declared in BOOTSTRAP
    # class Regex is Method {
    #     has Mu $!caps;
    #     has Mu $!nfa;
    #     has Mu $!alt_nfas

    multi method ACCEPTS(Regex:D \SELF: Mu \topic) {
        my $dollar_slash := nqp::getlexrelcaller(
            nqp::ctxcallerskipthunks(nqp::ctx()),
            '$/');
        $dollar_slash = SELF.(Cursor."!cursor_init"(topic, :c(0))).MATCH_SAVE;
    }

    multi method ACCEPTS(Regex:D \SELF: @a) {
        my $dollar_slash := nqp::getlexrelcaller(
            nqp::ctxcallerskipthunks(nqp::ctx()),
            '$/');
        for @a {
            $dollar_slash = SELF.(Cursor.'!cursor_init'($_, :c(0))).MATCH_SAVE;
            return $dollar_slash if $dollar_slash;
        }
        Nil;
    }
    multi method ACCEPTS(Regex:D \SELF: %h) {
        my $dollar_slash := nqp::getlexrelcaller(
            nqp::ctxcallerskipthunks(nqp::ctx()),
            '$/');
        for %h.keys {
            $dollar_slash = SELF.(Cursor.'!cursor_init'($_, :c(0))).MATCH_SAVE;
            return $dollar_slash if $dollar_slash;
        }
        Nil;
    }

    multi method Bool(Regex:D:) {
        my $dollar_slash := nqp::getlexrelcaller(
            nqp::ctxcallerskipthunks(nqp::ctx()),
            '$/');
        my $dollar_underscore := nqp::getlexrelcaller(
            nqp::ctxcallerskipthunks(nqp::ctx()),
            '$_');
        $dollar_slash = $dollar_underscore.match(self);
        $dollar_slash.Bool()
    }
}

# From 'src/core/PIO.pm'


# From 'src/core/IO.pm'

my class Instant  { ... }
my class IO::Dir  { ... }
my class IO::File  { ... }

my role IO {
    method umask { state $ = :8( qx/umask/.chomp ) }
}

#===============================================================================

sub MAKE-ABSOLUTE-PATH($path,$abspath) {
    if $path.ord == 47 {              # 4x faster substr($path,0,1) eq "/"
        return $path;
    }
    elsif $path.substr-eq(":",1) {  # assume C: something
        if $path.substr-eq("/",2) { #  assume C:/ like prefix
            return $path;
        }
        elsif !$abspath.starts-with(substr($path,0,2)) {
            die "Can not set relative dir from different roots";
        }
        else {
            return $abspath ~ substr($path,2);
        }
    }
    else {                            # assume relative path
        return $abspath ~ $path;
    }
}

sub MAKE-BASENAME(Str $abspath) {
    my str $abspath_s = nqp::unbox_s($abspath);
    my int $offset    = nqp::rindex($abspath_s,'/');
    nqp::p6bool($offset == -1)
      ?? $abspath
      !! nqp::box_s(nqp::substr($abspath_s,$offset + 1),Str);
}

sub MAKE-EXT(Str $basename) {
    my str $basename_s = nqp::unbox_s($basename);
    my int $offset     = nqp::rindex($basename_s,'.');
    nqp::p6bool($offset == -1)
      ?? ''
      !! nqp::box_s(nqp::substr($basename_s,$offset + 1),Str);
}

my %CLEAN-PARTS-NUL = 'Str|..' => 1, 'Str|.' => 1, 'Str|' => 1;
sub MAKE-CLEAN-PARTS(Str $abspath) {
    my @parts = $abspath.split('/');

    # handle //unc/ on win
    @parts.unshift( @parts.splice(0,3).join('/') )
      if @parts.AT-POS(1) eq ''    # //
      and @parts.AT-POS(0) eq '';  # and no C: like stuff

    # front part cleanup
    @parts.splice(1,1)
      while %CLEAN-PARTS-NUL.EXISTS-KEY(@parts.AT-POS(1).WHICH);

    # recursive ".." and "." handling
    sub updirs($index is copy) {

        # the end
        if $index == 1 {
            @parts.splice(1,1);
            return 1;
        }

        # something to check
        elsif @parts.AT-POS($index - 1) -> $part {
            if $part.ord == 46 { # fast substr($part,0,1) eq '.'
                if $part eq '..' {
                    return updirs($index - 1);
                }
                elsif $part eq '.' {
                    @parts.splice($index,1);
                    return updirs($index - 1);
                }
            }
            @parts.splice(--$index,2);
            return $index;
        }

        # nul, just ignore
        else {
            @parts.splice($index,1);
            return updirs($index);
        }
    }

    # back part cleanup
    my Int $checks = @parts.end;
    while $checks > 1 {
        if @parts.AT-POS($checks) -> $part {
            $part eq '..'
              ?? ($checks = updirs($checks))
              !! $part eq '.'
                ?? @parts.splice($checks--, 1)
                !! $checks--;
        }
        else {
            @parts.splice($checks--, 1);
        }
    }

    # need / at the end
    @parts.push("");
}

sub REMOVE-ROOT(Str $r, Str $p) {
    my str $root  = nqp::unbox_s($r);
    my str $path  = nqp::unbox_s($p);
    my int $chars = nqp::chars($root);

    return $p if $chars >= nqp::chars($path);  # makes no sense

    my int $i;
    while $i < $chars && nqp::ordat($root,$i) == nqp::ordat($path,$i) {
        $i = $i + 1;
    }

    $i == $chars ?? nqp::box_s(nqp::substr($path,$i),Str) !! $p;
}

sub CHANGE-DIRECTORY($path,$base,&test) {

    my $abspath = MAKE-CLEAN-PARTS(MAKE-ABSOLUTE-PATH($path,$base)).join('/');
    FILETEST-E($abspath) && FILETEST-D($abspath) && test($abspath)
      ?? IO::Path.new-from-absolute-path($abspath.chop)
      !! fail X::IO::Chdir.new(
           :$path,
           :os-error( "does not exist, is not a dir or no access" ),
         );
}

sub COPY-FILE(Str $from, Str $to, :$createonly) {
    if $createonly and FILETEST-E($to) {
        fail X::IO::Copy.new(
          :$from,
          :$to,
          :os-error(':createonly specified and destination exists'),
        );
    }

    nqp::copy(nqp::unbox_s($from), nqp::unbox_s($to));
    CATCH { default {
        fail X::IO::Copy.new( :$from, :$to, :os-error(.Str) );
    } }
    True;
}

sub RENAME-PATH(Str $from, Str $to, :$createonly) {
    if $createonly and FILETEST-E($to) {
        fail X::IO::Rename.new(
          :$from,
          :$to,
          :os-error(':createonly specified and destination exists'),
        );
    }

    nqp::rename(nqp::unbox_s($from), nqp::unbox_s($to));
    CATCH { default {
        fail X::IO::Rename.new( :$from, :$to, :os-error(.Str) );
    } }
    True;
}

sub CHMOD-PATH(Str $path, Int $mode) {
    nqp::chmod(nqp::unbox_s($path), nqp::unbox_i($mode));
    CATCH { default {
        fail X::IO::Chmod.new( :$path, :$mode, :os-error(.Str) );
    } }
    True;
}

sub UNLINK-PATH(Str $path) {
    nqp::unlink(nqp::unbox_s($path));
    CATCH { default {
        fail X::IO::Unlink.new( :$path, :os-error(.Str) );
    } }
    True;
}

sub SYMLINK-PATH(Str $target, Str $name) {
    nqp::symlink(nqp::unbox_s($name), nqp::unbox_s($target));
    CATCH { default {
        fail X::IO::Symlink.new( :$target, :$name, :os-error(.Str) );
    } }
    True;
}

sub LINK-FILE(Str $target, Str $name) {
    nqp::link(nqp::unbox_s($name), nqp::unbox_s($target));
    CATCH { default {
        fail X::IO::Link.new( :$target, :$name, :os-error(.Str) );
    } }
    True;
}

sub MAKE-DIR(Str $path, Int $mode) {
    nqp::mkdir(nqp::unbox_s($path), nqp::unbox_i($mode));
    CATCH { default {
        fail X::IO::Mkdir.new(:$path, :$mode, os-error => .Str);
    } }
    True;
}

sub REMOVE-DIR(Str $path) {
    nqp::rmdir(nqp::unbox_s($path));
    CATCH { default {
        fail X::IO::Rmdir.new(:$path, os-error => .Str);
    } }
    True;
}

sub FILETEST-E(Str $abspath) {
    nqp::p6bool( nqp::stat(nqp::unbox_s($abspath),nqp::const::STAT_EXISTS) );
}
sub FILETEST-D(Str $abspath) {
    nqp::p6bool( nqp::stat(nqp::unbox_s($abspath),nqp::const::STAT_ISDIR) );
}
sub FILETEST-F(Str $abspath) {
    nqp::p6bool( nqp::stat(nqp::unbox_s($abspath),nqp::const::STAT_ISREG) );
}
sub FILETEST-S(Str $abspath) {
    nqp::p6box_i(nqp::stat(nqp::unbox_s($abspath),nqp::const::STAT_FILESIZE) );
}
sub FILETEST-L(Str $abspath) {
    nqp::p6bool(nqp::fileislink(nqp::unbox_s($abspath)));
}
sub FILETEST-R(Str $abspath) {
    nqp::p6bool(nqp::filereadable(nqp::unbox_s($abspath)));
}
sub FILETEST-W(Str $abspath) {
    nqp::p6bool(nqp::filewritable(nqp::unbox_s($abspath)));
}
sub FILETEST-RW(Str $abspath) {
    my str $p = nqp::unbox_s($abspath);
    nqp::p6bool(nqp::filereadable($p) && nqp::filewritable($p));
}
sub FILETEST-X(Str $abspath) {
    nqp::p6bool(nqp::fileexecutable(nqp::unbox_s($abspath)));
}
sub FILETEST-RWX(Str $abspath) {
    my str $p = nqp::unbox_s($abspath);
    nqp::p6bool(
      nqp::filereadable($p) && nqp::filewritable($p) && nqp::fileexecutable($p)
    );
}
sub FILETEST-Z(Str $abspath) {
    nqp::p6bool(nqp::stat(nqp::unbox_s($abspath),nqp::const::STAT_FILESIZE)==0);
}
sub FILETEST-MODIFIED(Str $abspath) {
    Instant.new( nqp::p6box_i(
      nqp::stat(nqp::unbox_s($abspath), nqp::const::STAT_MODIFYTIME)
    ));
}
sub FILETEST-ACCESSED(Str $abspath) {
    Instant.new( nqp::p6box_i(
      nqp::stat(nqp::unbox_s($abspath), nqp::const::STAT_ACCESSTIME)
    ));
}
sub FILETEST-CHANGED(Str $abspath) {
    Instant.new( nqp::p6box_i(
      nqp::stat(nqp::unbox_s($abspath), nqp::const::STAT_CHANGETIME)
    ));
}

my %FILETEST-HASH =
  e => -> $p { True },
  d => -> $p { nqp::p6bool(nqp::stat(nqp::unbox_s($p),nqp::const::STAT_ISDIR)) },
  f => -> $p { nqp::p6bool(nqp::stat(nqp::unbox_s($p),nqp::const::STAT_ISREG)) },
  s => -> $p { %FILETEST-HASH.AT-KEY("f")($p)
    && nqp::box_i(nqp::stat(nqp::unbox_s($p),nqp::const::STAT_FILESIZE),Int) },
  l => -> $p { nqp::p6bool(nqp::fileislink(nqp::unbox_s($p))) },
  r => -> $p { nqp::p6bool(nqp::filereadable(nqp::unbox_s($p))) },
  w => -> $p { nqp::p6bool(nqp::filewritable(nqp::unbox_s($p))) },
  x => -> $p { nqp::p6bool(nqp::fileexecutable(nqp::unbox_s($p))) },
  z => -> $p { %FILETEST-HASH.AT-KEY("f")($p)
    && nqp::p6bool(nqp::stat(nqp::unbox_s($p),nqp::const::STAT_FILESIZE) == 0) },

  "!e" => -> $p { False },
  "!d" => -> $p { !%FILETEST-HASH.AT-KEY("d")($p) },
  "!f" => -> $p { !%FILETEST-HASH.AT-KEY("f")($p) },
  "!l" => -> $p { !%FILETEST-HASH.AT-KEY("l")($p) },
  "!r" => -> $p { !%FILETEST-HASH.AT-KEY("r")($p) },
  "!w" => -> $p { !%FILETEST-HASH.AT-KEY("w")($p) },
  "!x" => -> $p { !%FILETEST-HASH.AT-KEY("x")($p) },
  "!z" => -> $p { !%FILETEST-HASH.AT-KEY("z")($p) },
;

sub FILETEST-ALL(Str $path, *@tests) {

    # most common cases
    if @tests.join -> $tests {
        return FILETEST-R($path)   if $tests eq "r";
        return FILETEST-RW($path)  if $tests eq "rw";
        return FILETEST-RWX($path) if $tests eq "rwx";
    }

    # nothing to check
    else {
        return False;
    }

    my $result = True;
    for @tests -> $t {
        die "Unknown test $t" unless %FILETEST-HASH.EXISTS-KEY($t);
        last unless $result = $result && %FILETEST-HASH.AT-KEY($t)($path);
    }

    $result;
}

sub DIR-GATHER(Str $abspath,Mu $test) {
    gather {
        for MAKE-DIR-LIST($abspath,$test) -> $elem {
            take FILETEST-D($elem)
              ?? IO::Dir.new(:abspath($elem ~ '/'))
              !! IO::File.new(:abspath($elem));
        }
    }
}

sub DIR-GATHER-STR(Str $abspath,Mu $test) {
    gather {
        for MAKE-DIR-LIST($abspath,$test) -> $elem {
            take FILETEST-D($elem)
              ?? $elem ~ '/'
              !! $elem;
        }
    }
}


sub MAKE-DIR-LIST(Str $abspath, Mu $test) {

    CATCH { default {
        fail X::IO::Dir.new(
          :path(nqp::box_s($abspath,Str)), :os-error(.Str) );
    } }

    my Mu $dirh := nqp::opendir(nqp::unbox_s($abspath.chop));
    gather {
        if $test.defined {
            for <. ..> -> $elem {
                take $abspath ~ $elem if $test.ACCEPTS($elem);
            }
            loop {
                my str $elem_s = nqp::nextfiledir($dirh);
                if nqp::isnull_s($elem_s) || nqp::chars($elem_s) == 0 {
                    nqp::closedir($dirh);
                    last;
                }
                my Str $elem = nqp::box_s($elem_s,Str);
                take $elem if $test.ACCEPTS(MAKE-BASENAME($elem));
            }
        }
        else {
            loop {
                my str $elem_s = nqp::nextfiledir($dirh);
                if nqp::isnull_s($elem_s) || nqp::chars($elem_s) == 0 {
                    nqp::closedir($dirh);
                    last;
                }
                take nqp::box_s($elem_s,Str);
            }
        }
    }
}

# From 'src/core/IO/Pathy.pm'


# From 'src/core/IO/Local.pm'

my role IO::Local {
    has $!abspath;
    has @!parts;

    multi method ACCEPTS(IO::Local:D: \other) {
        nqp::p6bool(
          nqp::iseq_s(nqp::unbox_s($!abspath), nqp::unbox_s(~other))
        );
    }

    method absolute(IO::Local:D:) { $!abspath }

    proto method relative(|) { * }
    multi method relative(IO::Local:D:) { REMOVE-ROOT($*CWD ~ '/',$!abspath) }
    multi method relative(IO::Local:D: $root) { REMOVE-ROOT($root,$!abspath) }

    method !parts() { @!parts = $!abspath.split('/') unless @!parts }
    method volume(IO::Local:D:)    {
#        self!parts;  # runtime failure
        @!parts = $!abspath.split('/') unless @!parts;  # remove if above ok
        @!parts[0];
    }
    method dirname(IO::Local:D:)   {
        #self!parts;  # runtime failure
        @!parts = $!abspath.split('/') unless @!parts;  # remove if above ok
        @!parts[1 .. *-2].join('/');
    }
    method basename(IO::Local:D:)  { MAKE-BASENAME($!abspath) }
    method extension(IO::Local:D:) { MAKE-EXT(MAKE-BASENAME($!abspath))}

    method IO(IO::Local:D:)      { self }
    method Numeric(IO::Local:D:) { self.basename.Numeric }
    method Bridge(IO::Local:D:)  { self.basename.Bridge }
    method Int(IO::Local:D:)     { self.basename.Int }

    method Str(IO::Local:D:)  { $!abspath }
    multi method gist(IO::Local:D:) { qq|"{ self.relative }".IO| }
    multi method perl(IO::Local:D:) { "q|$!abspath|.IO" }

    method succ(IO::Local:D:) { $!abspath.succ }
    method pred(IO::Local:D:) { $!abspath.pred }

    method e(IO::Local:D:)   { True }
    method f(IO::Local:D:)   { FILETEST-F(  $!abspath) }
    method s(IO::Local:D:)   { FILETEST-S(  $!abspath) }
    method l(IO::Local:D:)   { FILETEST-L(  $!abspath) }
    method r(IO::Local:D:)   { FILETEST-R(  $!abspath) }
    method w(IO::Local:D:)   { FILETEST-W(  $!abspath) }
    method rw(IO::Local:D:)  { FILETEST-RW( $!abspath) }
    method x(IO::Local:D:)   { FILETEST-X(  $!abspath) }
    method rwx(IO::Local:D:) { FILETEST-RWX($!abspath) }
    method z(IO::Local:D:)   { FILETEST-Z(  $!abspath) }
    method modified(IO::Local:D:) { FILETEST-MODIFIED($!abspath) }
    method accessed(IO::Local:D:) { FILETEST-ACCESSED($!abspath) }
    method changed(IO::Local:D:)  { FILETEST-CHANGED( $!abspath) }

    method rename(IO::Local:D: Str() $to, :$createonly) {
        RENAME-PATH($!abspath,MAKE-ABSOLUTE-PATH($to,$*CWD ~ '/'),:$createonly);
    }
    method chmod(IO::Local:D: Int() $mode) {
        CHMOD-PATH($!abspath, $mode);
    }
    method symlink(IO::Local:D: Str() $name) {
        SYMLINK-PATH($!abspath, MAKE-ABSOLUTE-PATH($name,$*CWD ~ '/'));
    }

}
# From 'src/core/IO/Dir.pm'

my class IO::Dir is Cool does IO::Local {

    submethod BUILD(:$!abspath,:$check) {
        if $check {   # should really be .resolve, but we don't have that yet
            @!parts = MAKE-CLEAN-PARTS($!abspath);
            $!abspath = @!parts.join('/');
            fail "$!abspath is not a directory" unless FILETEST-D($!abspath);
        }
    }

    method child(IO::Dir:D: $child) {
        $child
          ?? self.new(:abspath($!abspath ~ $child ~ '/'),:check)
          !! self;
    }

    method parent(IO::Dir:D: $levels = 1) {
        self!parts;
        @!parts <= $levels + 1
          ?? self.new(:abspath( @!parts[0] ~ '/' ))
          !! self.new(:abspath( @!parts[0 .. *-($levels + 2)].join('/') ~ '/'));
    }

    method chdir(IO::Dir:D: Str() $path, :$test = 'r') {
        my $new := self.new( MAKE-ABSOLUTE-PATH($path,$!abspath), :check );
        $new // $new.throw;
        my $result := $new.all($test);
        $result // $result.throw;
        $new;
    }

    method rmdir(IO::Dir:D:) { REMOVE-DIR($!abspath) }

    method dirname(IO::Local:D:)   {
        self!parts;
        '/' ~ @!parts[1 .. *-3].join('/');
    }
    method basename(IO::Dir:D:)  { MAKE-BASENAME($!abspath.chop) }
    method extension(IO::Dir:D:) { MAKE-EXT(MAKE-BASENAME($!abspath.chop))}
    method succ(IO::Dir:D:) { $!abspath.chop.succ ~ '/' }
    method pred(IO::Dir:D:) { $!abspath.chop.pred ~ '/' }
    method d(IO::Dir:D:) { True }
    method f(IO::Dir:D:) { False }
    method s(IO::Dir:D:) { Nil }
    method l(IO::Dir:D:) { False }
    method z(IO::Dir:D:) { Nil }
}
# From 'src/core/IO/File.pm'

my class IO::File is Cool does IO::Local {

    submethod BUILD(:$!abspath) { }

    method open(IO::File:D: |c) { open( $!abspath, |c ) }

    method copy(IO::File:D: Str() $to, :$createonly) {
        COPY-FILE($!abspath, MAKE-ABSOLUTE-PATH($to,$*CWD ~ '/'), :$createonly);
    }

    method unlink(IO::File:D:) { UNLINK-PATH($!abspath) }

    method link(IO::File:D: Str() $name) {
        LINK-FILE($!abspath, MAKE-ABSOLUTE-PATH($name,$*CWD ~ '/'));
    }

    method d(IO::File:D:) { False }
}
# From 'src/core/IO/Huh.pm'


# From 'src/core/IO/Spec.pm'

my class IO::Spec {

    my %module =                # only list the non-Unix ones in lowercase
        'mswin32' => 'Win32',
        'os2' =>     'Win32',
        'dos'     => 'Win32',
        'symbian' => 'Win32',
        'netware' => 'Win32',
        'win32'   => 'Win32',
        'cygwin'  => 'Cygwin',
        'qnx'     => 'QNX',
        'nto'     => 'QNX',
        # <MacOS Mac>  => 'Mac',
        # 'VMS'     => 'VMS'
    ;

    method select(IO::Spec:U: $token? is copy) {

        # really just a way of getting $*DISTRO.name before we have %*ENV
        $token //=
          nqp::p6box_s(nqp::atkey(nqp::jvmgetproperties(), 'os.name'));
        ::('IO::Spec::' ~ ( %module{ lc $token } // 'Unix' ));
    }

    method MODULE(IO::Spec:U:) {
       DEPRECATED('$*SPEC', |<2014.10 2015.10>);
       $*SPEC;
    }

    method FSTYPE(IO::Spec:U: $OS?) {
        DEPRECATED('$*SPEC.select', |<2014.10 2015.10>);
        self.select($OS);
    }

    method os (Str $OS?) {
       DEPRECATED('$*SPEC.select', |<2014.10 2015.10>);
       self.select($OS);
    }

    method tmpdir() { # people seem to expect IO::Spec.tmpdir to return a Str
        DEPRECATED('$*TMPDIR', |<2014.10 2015.10>);
        $*SPEC.tmpdir.path;
    }

    method canonpath(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.canonpath', |<2014.10 2015.10>);
        $*SPEC.canonpath( |c );
    }
    method curdir(IO::Spec:U:) {
        DEPRECATED('$*SPEC.curdir', |<2014.10 2015.10>);
        $*SPEC.curdir();
    }
    method updir(IO::Spec:U:) {
        DEPRECATED('$*SPEC.updir', |<2014.10 2015.10>);
        $*SPEC.updir();
    }
    method rootdir(IO::Spec:U:) {
        DEPRECATED('$*SPEC.rootdir', |<2014.10 2015.10>);
        $*SPEC.rootdir();
    }
    method devnull(IO::Spec:U:) {
        DEPRECATED('$*SPEC.devnull', |<2014.10 2015.10>);
        $*SPEC.devnull();
    }
    method is-absolute(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.is-absolute', |<2014.10 2015.10>);
        $*SPEC.is-absolute( |c );
    }
    method no-parent-or-current-test(IO::Spec:U:) {
        DEPRECATED('$*SPEC.curupdir', |<2014.10 2015.10>);
        $*SPEC.curupdir;
    }
    method path(IO::Spec:U:) {
        DEPRECATED('$*SPEC.path', |<2014.10 2015.10>);
        $*SPEC.path();
    }
    method split(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.split', |<2014.10 2015.10>);
        $*SPEC.split( |c );
    }
    method join(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.join', |<2014.10 2015.10>);
        $*SPEC.join( |c );
    }
    method splitpath(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.splitpath', |<2014.10 2015.10>);
        $*SPEC.splitpath( |c );
    }
    method catpath(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.catpath', |<2014.10 2015.10>);
        $*SPEC.catpath( |c );
    }
    method catfile(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.catfile', |<2014.10 2015.10>);
        $*SPEC.catfile( |c );
    }
    method splitdir(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.splitdir', |<2014.10 2015.10>);
        $*SPEC.splitdir( |c );
    }
    method catdir(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.catdir', |<2014.10 2015.10>);
        $*SPEC.catdir( |c );
    }
    method abs2rel(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.abs2rel', |<2014.10 2015.10>);
        $*SPEC.abs2rel( |c );
    }
    method rel2abs(IO::Spec:U: |c ) {
        DEPRECATED('$*SPEC.rel2abs', |<2014.10 2015.10>);
        $*SPEC.rel2abs( |c );
    }
}

PROCESS::<$SPEC> = IO::Spec.select;

nqp::gethllsym('perl6', 'ModuleLoader').register_absolute_path_func(
    sub ($path) { return $*SPEC.rel2abs($path); }
);

# From 'src/core/IO/Spec/Unix.pm'

my class IO::Spec::Unix is IO::Spec {

    method canonpath( $patharg, :$parent --> Str) {
        my $path = $patharg.Str;
        return '' if $path eq '';

        $path ~~ s:g { '//' '/'* }         = '/';     # xx////xx  -> xx/xx
        $path ~~ s:g { '/.'+ ['/' | $] }   = '/';     # xx/././xx -> xx/xx
        $path ~~ s { ^ './' <!before $> }  = '';      # ./xx      -> xx
        if $parent {
            Nil while $path ~~ s:g {  [^ | <?after '/'>] <!before '../'> <-[/]>+ '/..' ['/' | $ ] } = '';
            $path = '.' if $path eq '';
        }
        $path ~~ s { ^ '/..'+ ['/' | $] }  = '/';     # /../..(/xx) -> /(xx)
        unless $path eq "/" {
            $path ~~ s { '/' $ }       = '';      # xx/       -> xx    :)
        }
        $path
    }

    method dir-sep  {  '/' }
    method curdir   {  '.' }
    method updir    { '..' }
    method curupdir { none('.','..') }
    method rootdir  { '/' }
    method devnull  { '/dev/null' }

    method basename(\path) {
        my str $str = nqp::unbox_s(path);
        my int $index = nqp::rindex($str,'/');
        nqp::p6bool($index == -1)
          ?? path
          !! substr(path,nqp::box_i($index + 1,Int) );
    }

    method extension(\path) {
        my str $str = nqp::unbox_s(path);
        my int $index = nqp::rindex($str,'.');
        nqp::p6bool($index == -1)
          ?? ''
          !! substr(path,nqp::box_i($index + 1,Int) );
    }

    method tmpdir {
        my $io;
        first( {
            if .defined {
                $io = .IO;
                $io.d && $io.r && $io.w && $io.x;
            }
    },
          %*ENV<TMPDIR>,
          '/tmp',
        ) ?? $io !! IO::Path.new(".");
    }

    method is-absolute( $file ) {
        substr( $file, 0, 1 ) eq '/';
    }

    method path {
        if %*ENV<PATH> -> $PATH {
            $PATH.split( ':' ).map: { $_ || '.' };
        }
        else {
            ();
        }
    }

    method splitpath( $path, :$nofile = False ) {
        if $nofile {
            ( '', $path, '' );
        }
        else {
            $path ~~ m/^ ( [ .* \/ [ '.'**1..2 $ ]? ]? ) (<-[\/]>*) /;
            ( '', ~$0, ~$1 );
        }
    }

    method split (Cool:D $path is copy ) {
        $path  ~~ s/<?after .> '/'+ $ //;

        $path  ~~ m/^ ( [ .* \/ ]? ) (<-[\/]>*) /;
        my ($dirname, $basename) = ~$0, ~$1;

        $dirname ~~ s/<?after .> '/'+ $ //; #/

        if $basename eq '' {
            $basename = '/'  if $dirname eq '/';
        }
        else {
            $dirname = '.'  if $dirname eq '';
        }
        # shell dirname '' produces '.', but we don't because it's probably user error

        # temporary, for the transition period
        (:volume(''), :$dirname, :$basename, :directory($dirname));
#        (:volume(''), :$dirname, :$basename);
    }


    method join ($, $dirname, $file) {
        self.catpath(
          '',
          ($dirname eq '/' && $file eq '/' or $dirname eq '.' && $file.chars)
            ?? '' !! $dirname,
          $file,
        );
    }

    method catpath( $, $dirname, $file ) {
        $dirname ne ''
          && $file ne ''
          && substr($dirname, *-1 ) ne '/'
          && substr($file, 0, 1 )   ne '/'
          ?? $dirname ~ '/' ~ $file
          !! $dirname ~ $file
    }

    method catdir( *@parts ) { self.canonpath( (@parts, '').join('/') ) }
    method splitdir( $path ) { $path.split( '/' )  }
    method catfile( |c )     { self.catdir(|c) }

    method abs2rel( $path is copy, $base is copy = Str ) {
        $base = $*CWD unless $base.defined && $base.chars;

        if self.is-absolute($path) || self.is-absolute($base) {
            $path = self.rel2abs( $path );
            $base = self.rel2abs( $base );
        }
        else {
            # save a couple of cwd()s if both paths are relative
            $path = self.catdir( self.rootdir, $path );
            $base = self.catdir( self.rootdir, $base );
        }

        my ($path_volume, $path_directories) = self.splitpath( $path, :nofile );
        my ($base_volume, $base_directories) = self.splitpath( $base, :nofile );

        # Can't relativize across volumes
        return $path unless $path_volume eq $base_volume;

        # For UNC paths, the user might give a volume like //foo/bar that
        # strictly speaking has no directory portion.  Treat it as if it
        # had the root directory for that volume.
        if !$base_directories.chars && self.is-absolute( $base ) {
            $base_directories = self.rootdir;
        }

        # Now, remove all leading components that are the same
        my @pathchunks = self.splitdir( $path_directories );
        my @basechunks = self.splitdir( $base_directories );

        if $base_directories eq self.rootdir {
            @pathchunks.shift;
            return self.canonpath( self.catpath('', self.catdir( @pathchunks ), '') );
        }

        while @pathchunks && @basechunks && @pathchunks[0] eq @basechunks[0] {
            @pathchunks.shift;
            @basechunks.shift;
        }
        return self.curdir unless @pathchunks || @basechunks;

        # $base now contains the directories the resulting relative path
        # must ascend out of before it can descend to $path_directory.
        my $result_dirs = self.catdir( self.updir() xx @basechunks.elems, @pathchunks );
        return self.canonpath( self.catpath('', $result_dirs, '') );
    }

    method rel2abs( $path, $base? is copy) {
        return self.canonpath($path) if self.is-absolute($path);

        my $cwd := $*CWD;
        if !self.is-absolute( $base //= $cwd ) {
            $base = self.rel2abs( $base, $cwd ) unless $base eq $cwd;
        }
        self.catdir( self.canonpath($base), $path );
    }

    method no-parent-or-current-test {
        DEPRECATED('curupdir', |<2014.10 2015.10>);
        none('.', '..');
    }
}

# From 'src/core/IO/Spec/Win32.pm'

my class IO::Spec::Win32 is IO::Spec::Unix {

    # Some regexes we use for path splitting
    my $slash       = regex {  <[\/ \\]> }
    my $notslash    = regex { <-[\/ \\]> }
    my $driveletter = regex { <[A..Z a..z]> ':' }
    my $UNCpath     = regex { [<$slash> ** 2] <$notslash>+  <$slash>  [<$notslash>+ | $] }
    my $volume_rx   = regex { <$driveletter> | <$UNCpath> }

    method canonpath ($patharg, :$parent) {
        my $path = $patharg.Str;
        $path eq '' ?? '' !! self!canon-cat($path, :$parent);
    }

    method catdir(*@dirs) {
        return "" unless @dirs;
        return self!canon-cat( "\\", @dirs ) if @dirs[0] eq "";
        self!canon-cat(|@dirs);
    }

    method dir-sep        { '\\' }
    method splitdir($dir) { $dir.split($slash)  }
    method catfile(|c)    { self.catdir(|c)     }
    method devnull        { 'nul'               }
    method rootdir        { '\\'                }

    method basename(\path) {
        my str $str = nqp::unbox_s(path);
        my int $indexf = nqp::rindex($str,'/');
        my int $indexb = nqp::rindex($str,'\\');
        nqp::p6bool($indexf == -1 && $indexb == -1)
          ?? path
          !! $indexf > $indexb
             ?? substr(path,nqp::box_i($indexf + 1,Int) )
             !! substr(path,nqp::box_i($indexb + 1,Int) );
    }

    method tmpdir {
        my $ENV := %*ENV;
        my $io;
        first( {
            if .defined {
                $io = .IO;
                $io.d && $io.r && $io.w && $io.x;
            }
        },
          $ENV<TMPDIR>,
          $ENV<TEMP>,
          $ENV<TMP>,
          'SYS:/temp',
          'C:\system\temp',
          'C:/temp',
          '/tmp',
          '/',
        ) ?? $io !! IO::Path.new(".");
    }

    method path {
       (".",
         split(';', %*ENV<PATH> // %*ENV<Path> // '').map( {
           .subst(:global, q/"/, '') } ).grep: *.chars );
   }

    method is-absolute ($path) {
        so $path ~~ /^ [ <$driveletter> <$slash> | <$slash> | <$UNCpath> ]/
    }

    method split (Str() $path is copy) {
        $path ~~ s[ <$slash>+ $] = ''                       #=
            unless $path ~~ /^ <$driveletter>? <$slash>+ $/;

        $path ~~
            m/^ ( <$volume_rx> ? )
            ( [ .* <$slash> ]? )
            (.*)
             /;
        my ($volume, $dirname, $basename) = (~$0, ~$1, ~$2);
        $dirname ~~ s/ <?after .> <$slash>+ $//;


        if all($dirname, $basename) eq '' && $volume ne '' {
            $dirname = $volume ~~ /^<$driveletter>/
                     ?? '.' !! '\\';
        }
        $basename = '\\' if $dirname eq any('/', '\\') && $basename eq '';
        $dirname  = '.'  if $dirname eq ''             && $basename ne '';

        # temporary, for the transition period
        (:$volume, :$dirname, :$basename, :directory($dirname));
#        (:$volume, :$dirname, :$basename);
    }

    method join ($volume, $dirname is copy, $file is copy) {
        $dirname = '' if $dirname eq '.' && $file.chars;
        if $dirname.match( /^<$slash>$/ ) && $file.match( /^<$slash>$/ ) {
            $file    = '';
            $dirname = '' if $volume.chars > 2; #i.e. UNC path
        }
        self.catpath($volume, $dirname, $file);
    }

    method splitpath(Str() $path, :$nofile = False) {

        if $nofile {
            $path ~~ /^ (<$volume_rx>?) (.*) /;
            (~$0, ~$1, '');
        }
        else {
            $path ~~
                m/^ ( <$volume_rx> ? )
                ( [ .* <$slash> [ '.' ** 1..2 $]? ]? )
                (.*)
                 /;
            (~$0, ~$1, ~$2);
        }
    }

    method catpath($volume is copy, $dirname, $file) {

        # Make sure the glue separator is present
        # unless it's a relative path like A:foo.txt
        if $volume.chars and $dirname.chars
           and $volume !~~ /^<$driveletter>/
           and $volume !~~ /<$slash> $/
           and $dirname !~~ /^ <$slash>/
            { $volume ~= '\\' }
        if $file.chars and $dirname.chars
           and $dirname !~~ /<$slash> $/
            { $volume ~ $dirname ~ '\\' ~ $file; }
        else     { $volume ~ $dirname     ~    $file; }
    }

    method rel2abs ($path is copy, $base? is copy, :$omit-volume) {

        my $is_abs = ($path ~~ /^ [<$driveletter> <$slash> | <$UNCpath>]/ && 2)
                  || ($path ~~ /^ <$slash> / && 1)
                  || 0;

        # Check for volume (should probably document the '2' thing...)
        return self.canonpath( $path ) if $is_abs == 2 || ($is_abs == 1 && $omit-volume);

        if $is_abs {
            # It's missing a volume, add one
            my $vol;
            $vol = self.splitpath($base)[0] if $base.defined;
            $vol ||= self.splitpath($*CWD)[0];
            return self.canonpath( $vol ~ $path );
        }

        if not defined $base {
        # TODO: implement _getdcwd call ( Windows maintains separate CWD for each volume )
        # See: http://msdn.microsoft.com/en-us/library/1e5zwe0c%28v=vs.80%29.aspx
            #$base = Cwd::getdcwd( (self.splitpath: $path)[0] ) if defined &Cwd::getdcwd ;
            #$base //= $*CWD ;
            $base = $*CWD;
        }
        elsif ( !self.is-absolute( $base ) ) {
            $base = self.rel2abs( $base );
        }
        else {
            $base = self.canonpath( $base );
        }

        my ($path_directories, $path_file) = self.splitpath( $path )[1..2] ;

        my ($base_volume, $base_directories) = self.splitpath( $base, :nofile ) ;

        $path = self.catpath(
                    $base_volume,
                    self.catdir( $base_directories, $path_directories ),
                    $path_file
                    ) ;

        return self.canonpath( $path ) ;
    }


    method !canon-cat ( $first, *@rest, :$parent --> Str) {

        $first ~~ /^ ([   <$driveletter> <$slash>?
                        | <$UNCpath>
                        | [<$slash> ** 2] <$notslash>+
                        | <$slash> ]?)
                       (.*)
                   /;
        my Str ($volume, $path) = ~$0, ~$1;

        $volume.=subst(:g, '/', '\\');
        if $volume ~~ /^<$driveletter>/ {
            $volume.=uc;
        }
        elsif $volume.chars && $volume !~~ / '\\' $/ {
            $volume ~= '\\';
        }

        $path = join "\\", $path, @rest.flat;
        $path ~~ s:g/ <$slash>+ /\\/;                              # /xx\\yy   --> \xx\yy
        $path ~~ s:g/[ ^ | '\\']   '.'  '\\.'*  [ '\\' | $ ]/\\/;  # xx/././yy --> xx/yy
        if $parent {
            while $path ~~ s:g { [^ | <?after '\\'>] <!before '..\\'> <-[\\]>+ '\\..' ['\\' | $ ] } = '' { };
        }
        $path ~~ s/^ '\\'+ //;        # \xx --> xx  NOTE: this is *not* root
        $path ~~ s/ '\\'+ $//;        # xx\ --> xx
        if $volume ~~ / '\\' $ / {    # <vol>\.. --> <vol>\
            $path ~~ s/ ^  '..'  '\\..'*  [ '\\' | $ ] //;
        }

        if $path eq '' {        # \\HOST\SHARE\ --> \\HOST\SHARE
            $volume ~~ s/<?after '\\\\' .*> '\\' $ //;
            $volume || '.';
        }
        else {
            $volume ~ $path;
        }
    }
}

# From 'src/core/IO/Spec/Cygwin.pm'

my class IO::Spec::Cygwin is IO::Spec::Unix {

    method canonpath (Cool:D $patharg) {
        my $path = $patharg.Str;
        $path.=subst(:g, '\\', '/');

        # Handle network path names beginning with double slash
        my $node = '';
        if $path ~~ s/^ ('//' <-[/]>+) [ '/' | $ ] /\// { #/
            $node = ~$0;
        }
        $node ~ IO::Spec::Unix.canonpath($path);
    }

    method catdir ( *@paths ) {
        my $result = IO::Spec::Unix.catdir(@paths);

        # Don't create something that looks like a //network/path
        $result.subst(/ <[\\\/]> ** 2..*/, '/');
    }

    method is-absolute ($file) {
        so $file ~~ / ^ [<[A..Z a..z]> ':']?  <[\\/]>/; # C:/test
    }

    method tmpdir {
        my %ENV := $%ENV;
        my $io;
        first( {
            if .defined {
                $io = .IO;
                $io.d && $io.r && $io.w && $io.x;
            }
        },
          %ENV<TMPDIR>,
          "/tmp",
          %ENV<TMP>,
          %ENV<TEMP>,
          'C:/temp',
        ) ?? $io !! IO::Path.new(".");
    }

    # Paths might have a volume, so we use Win32 splitpath and catpath instead
    method abs2rel(|c) {
        IO::Spec::Win32.abs2rel(|c).subst(:global, '\\', '/');
    }
    method rel2abs(|c) {
        IO::Spec::Win32.rel2abs(|c, :omit-volume).subst(:global, '\\', '/');
    }
    method splitpath(|c) {
        IO::Spec::Win32.splitpath(|c)>>.subst(:global, '\\', '/');
    }
    method catpath(|c) {
        IO::Spec::Win32.catpath(|c).subst(:global, '\\', '/');
    }
    method split($path) {
        IO::Spec::Win32.split($path).map(
          { (.key => .value.subst(:global, '\\', '/')) }
        );
    }
    method join(|c) {
        IO::Spec::Win32.join(|c).subst(:global, '\\', '/');
    }
}

# From 'src/core/IO/Spec/QNX.pm'

my class IO::Spec::QNX is IO::Spec::Unix {

    method canonpath ($patharg, :$parent) {
        my $path = $patharg.Str;
        # Handle POSIX-style node names beginning with double slash (qnx, nto)
        # (POSIX says: "a pathname that begins with two successive slashes
        # may be interpreted in an implementation-defined manner, although
        # more than two leading slashes shall be treated as a single slash.")
        my $node = '';
        if $path ~~ s {^ ( '//' <-[ / ]>+ ) '/'? $} = ''
        or $path ~~ s {^ ( '//' <-[ / ]>+ ) '/' }   = '/'
            { $node = ~ $0; }

        $path = IO::Spec::Unix.canonpath($path, :$parent);

        $node ~ $path;
    }
}

# From 'src/core/IO/Handle.pm'

my class IO::Path { ... }
my class IO::Special { ... }

my class IO::Handle does IO {
    has $.path;
    has $!PIO;
    has int $.ins;
    has $.chomp is rw = Bool::True;
    has $.nl    = "\n";
    has int $!pipe;

    method pipe(IO::Handle:D: |c) {
        self.open(:p, |c);
    }

    method open(IO::Handle:D:
      :$r is copy,
      :$w is copy,
      :$rw,
      :$a,
      :$p,
      :$bin,
      :$chomp = True,
      :$enc   = 'utf8',
      :$nl    = "\n",
    ) {

        if $!path eq '-' {
            $!path =
              IO::Special.new(:what( $w ?? << <STDOUT> >> !! << <STDIN> >> ));
        }

        if nqp::istype($!path,IO::Special) {
            my $what := $!path.what;
            if $what eq '<STDIN>' {
                $!PIO := nqp::getstdin();
            }
            elsif $what eq '<STDOUT>' {
                $!PIO := nqp::getstdout();
            }
            elsif $what eq '<STDERR>' {
                $!PIO := nqp::getstderr();
            }
            else {
                die "Don't know how to open '$_' especially";
            }
            $!chomp = $chomp;
            nqp::setencoding($!PIO, NORMALIZE_ENCODING($enc)) unless $bin;
            return self;
        }

        fail (X::IO::Directory.new(:$!path, :trying<open>))
          if $!path.e && $!path.d;
        $r = $w = True if $rw;

        if $p {
            $!pipe = 1;

            my str $errpath;
            $!PIO := nqp::openpipe(
              nqp::unbox_s($!path.Str),
              nqp::unbox_s($*CWD.Str),
              CLONE-HASH-DECONTAINERIZED(%*ENV),
              $errpath,
            );
        }
        else {
            my $mode =  $w ?? 'w' !! ($a ?? 'wa' !! 'r' );
            # TODO: catch error, and fail()
            $!PIO := nqp::open(
              nqp::unbox_s($!path.abspath),
              nqp::unbox_s($mode),
            );
        }

        $!chomp = $chomp;
        nqp::setinputlinesep($!PIO, nqp::unbox_s($!nl = $nl));
        nqp::setencoding($!PIO, NORMALIZE_ENCODING($enc)) unless $bin;
        self;
    }


    method input-line-separator {
        DEPRECATED("nl",|<2015.03 2016.03>);
        self.nl;
    }

    method nl {
        Proxy.new(
          FETCH => {
              $!nl
          },
          STORE => -> $, $nl is copy {
            nqp::setinputlinesep($!PIO, nqp::unbox_s($!nl = $nl));
          }
        );
    }

    method close(IO::Handle:D:) {
        # TODO:b catch errors
        if $!pipe {
            my $ps = Proc::Status.new;
            $ps.status( nqp::closefh_i($!PIO) ) if nqp::defined($!PIO);
            $!PIO := Mu;
            $ps;
        }
        else {
            nqp::closefh($!PIO) if nqp::defined($!PIO);
            $!PIO := Mu;
            True;
        }
    }

    method eof(IO::Handle:D:) {
        nqp::p6bool(nqp::eoffh($!PIO));
    }

    method get(IO::Handle:D:) {
        return Str if self.eof;

        my Str $x = nqp::p6box_s(nqp::readlinefh($!PIO));
        # XXX don't fail() as long as it's fatal
        # fail('end of file') if self.eof && $x eq '';
        $x.=chomp if $.chomp;
        return Str if self.eof && $x eq '';

        $!ins = $!ins + 1;
        $x;
    }

    method getc(IO::Handle:D:) {
        my $c = nqp::p6box_s(nqp::getcfh($!PIO));
        fail if $c eq '';
        $c;
    }

    proto method words (|) { * }
    multi method words(IO::Handle:D: :$close) {
        my str $str;
        my int $chars;
        my int $pos;
        my int $left;
        my int $nextpos;

        gather {
            until nqp::eoffh($!PIO) {

                my Buf $buf := Buf.new;
                nqp::readfh($!PIO, $buf, 65536);
                $str = $str ~ nqp::unbox_s($buf.decode);
                $chars = nqp::chars($str);
                $pos   = nqp::findnotcclass(
                  nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);

                while ($left = $chars - $pos) > 0 {
                    $nextpos = nqp::findcclass(
                      nqp::const::CCLASS_WHITESPACE, $str, $pos, $left);
                    last unless $left = $chars - $nextpos; # broken word

                    take
                      nqp::box_s(nqp::substr($str, $pos, $nextpos - $pos), Str);

                    $pos = nqp::findnotcclass(
                      nqp::const::CCLASS_WHITESPACE, $str, $nextpos, $left);
                }

                $str = $pos < $chars ?? nqp::substr($str,$pos) !! '';
            }
            self.close if $close;
        }
    }
    # can probably go after GLR
    multi method words(IO::Handle:D: :$eager!, :$close) {
        return self.words(:$close) if !$eager;

        my str $str;
        my int $chars;
        my int $pos;
        my int $left;
        my int $nextpos;
        my Mu $rpa := nqp::list();

        until nqp::eoffh($!PIO) {

            my Buf $buf := Buf.new;
            nqp::readfh($!PIO, $buf, 65536);
            $str   = $str ~ nqp::unbox_s($buf.decode);
            $chars = nqp::chars($str);
            $pos   = nqp::findnotcclass(
              nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);

            while ($left = $chars - $pos) > 0 {
                $nextpos = nqp::findcclass(
                  nqp::const::CCLASS_WHITESPACE, $str, $pos, $left);
                last unless $left = $chars - $nextpos; # broken word

                nqp::push($rpa,
                  nqp::box_s(nqp::substr($str, $pos, $nextpos - $pos), Str) );

                $pos = nqp::findnotcclass(
                  nqp::const::CCLASS_WHITESPACE, $str, $nextpos, $left);
            }

            $str = $pos < $chars ?? nqp::substr($str,$pos) !! '';
        }
        self.close if $close;
        nqp::p6parcel($rpa, Nil);
    }
    multi method words(IO::Handle:D: :$count!, :$close) {
        return self.words(:$close) if !$count;

        my str $str;
        my int $chars;
        my int $pos;
        my int $left;
        my int $nextpos;
        my int $found;

        until nqp::eoffh($!PIO) {

            my Buf $buf := Buf.new;
            nqp::readfh($!PIO, $buf, 65536);
            $str   = $str ~ nqp::unbox_s($buf.decode);
            $chars = nqp::chars($str);
            $pos   = nqp::findnotcclass(
              nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);

            while ($left = $chars - $pos) > 0 {
                $nextpos = nqp::findcclass(
                  nqp::const::CCLASS_WHITESPACE, $str, $pos, $left);
                last unless $left = $chars - $nextpos; # broken word

                $found = $found + 1;

                $pos = nqp::findnotcclass(
                  nqp::const::CCLASS_WHITESPACE, $str, $nextpos, $left);
            }

            $str = $pos < $chars ?? nqp::substr($str,$pos) !! '';
        }
        self.close if $close;
        nqp::box_i($found, Int);
    }
    multi method words(IO::Handle:D: $limit, :$eager, :$close) {
        return self.words(:$eager,:$close)
          if $limit == Inf or nqp::istype($limit,Whatever);

        my str $str;
        my int $chars;
        my int $pos;
        my int $left;
        my int $nextpos;
        my int $count = $limit;
        my Mu $rpa := nqp::list();

        until nqp::eoffh($!PIO) {

            my Buf $buf := Buf.new;
            nqp::readfh($!PIO, $buf, 65536);
            $str   = $str ~ nqp::unbox_s($buf.decode);
            $chars = nqp::chars($str);
            $pos   = nqp::findnotcclass(
              nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);

            while $count and ($left = $chars - $pos) > 0 {
                $nextpos = nqp::findcclass(
                  nqp::const::CCLASS_WHITESPACE, $str, $pos, $left);
                last unless $left = $chars - $nextpos; # broken word

                nqp::push($rpa,
                  nqp::box_s(nqp::substr($str, $pos, $nextpos - $pos), Str) );
                $count = $count - 1;

                $pos = nqp::findnotcclass(
                  nqp::const::CCLASS_WHITESPACE, $str, $nextpos, $left);
            }

            $str = $pos < $chars ?? nqp::substr($str,$pos) !! '';
        }
        self.close if $close;
        nqp::p6parcel($rpa, Nil);
    }

    proto method lines (|) { * }
    multi method lines(IO::Handle:D: :$close) {

        if $.chomp {
            gather {
                until nqp::eoffh($!PIO) {
                    $!ins = $!ins + 1;
                    take nqp::p6box_s(nqp::readlinefh($!PIO)).chomp;
                }
                self.close if $close;
            }
        }
        else {
            gather {
                until nqp::eoffh($!PIO) {
                    $!ins = $!ins + 1;
                    take nqp::p6box_s(nqp::readlinefh($!PIO));
                }
                self.close if $close;
            }
        }
    }
    # can probably go after GLR
    multi method lines(IO::Handle:D: :$eager!, :$close) {
        return self.lines if !$eager;

        my Mu $rpa := nqp::list();
        if $.chomp {
            until nqp::eoffh($!PIO) {
                nqp::push($rpa, nqp::p6box_s(nqp::readlinefh($!PIO)).chomp );
            }
        }
        else {
            until nqp::eoffh($!PIO) {
                nqp::push($rpa, nqp::p6box_s(nqp::readlinefh($!PIO)) );
            }
        }
        $!ins = nqp::elems($rpa);
        self.close if $close;
        nqp::p6parcel($rpa, Nil);
    }
    multi method lines(IO::Handle:D: :$count!, :$close) {
        return self.lines(:$close) if !$count;

        until nqp::eoffh($!PIO) {
            nqp::readlinefh($!PIO);
            $!ins = $!ins + 1;
        }
        nqp::box_i($!ins, Int);
    }
    multi method lines(IO::Handle:D: $limit, :$eager, :$close) {
        return self.lines(:$eager, :$close)
          if $limit == Inf or nqp::istype($limit,Whatever);

        my Mu $rpa := nqp::list();
        my int $count = $limit + 1;
        if $.chomp {
            while $count = $count - 1 {
                last if nqp::eoffh($!PIO);
                nqp::push($rpa, nqp::p6box_s(nqp::readlinefh($!PIO)).chomp );
            }
        }
        else {
            while $count = $count - 1 {
                nqp::push($rpa, nqp::p6box_s(nqp::readlinefh($!PIO)) );
            }
        }
        $!ins = nqp::elems($rpa);
        self.close if $close;
        nqp::p6parcel($rpa, Nil);
    }

    method read(IO::Handle:D: Int(Cool:D) $bytes) {
        my $buf := buf8.new();
        nqp::readfh($!PIO, $buf, nqp::unbox_i($bytes));
        $buf;
    }

    # second arguemnt should probably be an enum
    # valid values for $whence:
    #   0 -- seek from beginning of file
    #   1 -- seek relative to current position
    #   2 -- seek from the end of the file
    method seek(IO::Handle:D: Int:D $offset, Int:D $whence) {
        nqp::seekfh($!PIO, $offset, $whence);
        True;
    }

    method tell(IO::Handle:D:) returns Int {
        nqp::p6box_i(nqp::tellfh($!PIO));
    }

    method write(IO::Handle:D: Blob:D $buf) {
        nqp::writefh($!PIO, nqp::decont($buf));
        True;
    }

    method opened(IO::Handle:D:) {
        nqp::p6bool(nqp::istrue($!PIO));
    }

    method t(IO::Handle:D:) {
        self.opened && nqp::p6bool($!PIO.isatty)
    }


    proto method print(|) { * }
    multi method print(IO::Handle:D: Str:D \x) {
        nqp::printfh($!PIO, nqp::unbox_s(x));
        Bool::True
    }
    multi method print(IO::Handle:D: *@list) {
        nqp::printfh($!PIO, nqp::unbox_s(@list.shift.Str)) while @list.gimme(1);
        Bool::True
    }

    multi method say(IO::Handle:D: |) {
        my Mu $args := nqp::p6argvmarray();
        nqp::shift($args);
        self.print: nqp::shift($args).gist while $args;
        self.print: "\n";
    }

    method slurp(IO::Handle:D: |c) {
        DEPRECATED('$handle.slurp-rest', |<2014.10 2015.10>);
        self.slurp-rest(|c);
    }

    method slurp-rest(IO::Handle:D: :$bin, :$enc) {
        if $bin {
            my $Buf := buf8.new();
            loop {
                my $buf := buf8.new();
                nqp::readfh($!PIO,$buf,65536);
                last if $buf.bytes == 0;
                $Buf := $Buf ~ $buf;
            }
            $Buf;
        }
        else {
            self.encoding($enc) if $enc.defined;
            nqp::p6box_s(nqp::readallfh($!PIO));
        }
    }

    proto method spurt(|) { * }
    multi method spurt(IO::Handle:D: Cool $contents, :$nodepr) {
        DEPRECATED("IO::Path.spurt", |<2014.10 2015.10>) unless $nodepr;
        self.print($contents);
    }

    multi method spurt(IO::Handle:D: Blob $contents, :$nodepr) {
        DEPRECATED("IO::Path.spurt", |<2014.10 2015.10>) unless $nodepr;
        self.write($contents);
    }

    # not spec'd
    method copy(IO::Handle:D: $dest) {
        DEPRECATED("IO::Path.copy", |<2014.10 2015.10>);
        $!path.copy($dest);
    }

    method chmod(IO::Handle:D: Int $mode) { $!path.chmod($mode) }
    method IO(IO::Handle:D: |c)           { $!path.IO(|c) }
    method path(IO::Handle:D:)            { $!path.IO }
    multi method Str(IO::Handle:D:)       { $!path }

    multi method gist(IO::Handle:D:) {
        self.opened
            ?? "IO::Handle<$!path>(opened, at line {$.ins} / octet {$.tell})"
            !! "IO::Handle<$!path>(closed)"
    }

    multi method perl(IO::Handle:D:) {
        "IO::Handle.new(path => {$!path.perl}, ins => {$!ins.perl}, chomp => {$!chomp.perl})"
    }


    method flush(IO::Handle:D:) {
        fail("File handle not open, so cannot flush")
            unless nqp::defined($!PIO);
        nqp::flushfh($!PIO);
        True;
    }

    method encoding(IO::Handle:D: $enc?) {
        $enc.defined
            ?? nqp::setencoding($!PIO, NORMALIZE_ENCODING($enc))
            !! $!PIO.encoding
    }

    submethod DESTROY(IO::Handle:D:) {
        self.close;
    }

    # setting cannot do "handles", so it's done by hand here
    method e(IO::Handle:D:) { $!path.e }
    method d(IO::Handle:D:) { $!path.d }
    method f(IO::Handle:D:) { $!path.f }
    method s(IO::Handle:D:) { $!path.s }
    method l(IO::Handle:D:) { $!path.l }
    method r(IO::Handle:D:) { $!path.r }
    method w(IO::Handle:D:) { $!path.w }
    method x(IO::Handle:D:) { $!path.x }
    method modified(IO::Handle:D:) { $!path.modified }
    method accessed(IO::Handle:D:) { $!path.accessed }
    method changed(IO::Handle:D:)  { $!path.changed  }

}

# From 'src/core/IO/Pipe.pm'


# From 'src/core/IO/Path.pm'

my class Instant { ... }

my class IO::Path is Cool {
    has IO::Spec $.SPEC;
    has Str      $.CWD;
    has Str      $.path;
    has Bool $!is-absolute;
    has Str  $!abspath;  # should be native for faster file tests, but segfaults
    has Bool $!e;
    has %!parts;

    multi method ACCEPTS(IO::Path:D: IO::Path:D \other) {
        nqp::p6bool(nqp::iseq_s($.abspath, nqp::unbox_s(other.path.abspath)));
    }

    multi method ACCEPTS(IO::Path:D: Mu \that) {
        nqp::p6bool(nqp::iseq_s($.abspath,nqp::unbox_s(IO::Path.new(|that).abspath)));
    }

    submethod BUILD(Str() :$!path!, :$!SPEC!, Str() :$!CWD!) { }

    method new-from-absolute-path($path, :$SPEC = $*SPEC, :$CWD = $*CWD) {
        method !fap() {
            $!is-absolute = True;
            $!abspath := $path;
            self;
        }

        self.bless(:$path, :$SPEC, :$CWD)!fap;
    }

    multi method new(IO::Path: $path, :$SPEC = $*SPEC, :$CWD = $*CWD) {
        self.bless(:$path, :$SPEC, :$CWD);
    }
    multi method new(IO::Path:
      :$basename,
      :$directory!,
      :$volume = '',
      :$SPEC   = $*SPEC,
      :$CWD    = $*CWD,
    ) {
        DEPRECATED(':dirname', |<2014.10 2015.10>, :what<IO::Path.new with :directory>);
        self.bless(
          :path($SPEC.join($volume,$directory,$basename)), :$SPEC, :$CWD);
    }
    multi method new(IO::Path:
      :$basename!,
      :$dirname = '.',
      :$volume  = '',
      :$SPEC    = $*SPEC,
      :$CWD     = $*CWD,
    ) {
        self.bless(:path($SPEC.join($volume,$dirname,$basename)),:$SPEC,:$CWD);
    }

    method abspath() {
        $!abspath //= substr($!path,0,1) eq '-'
          ?? ''
          !! $!SPEC.rel2abs($!path,$!CWD);
    }
    method is-absolute() {
        $!is-absolute //= $!SPEC.is-absolute($!path);
    }
    method is-relative() {
        !( $!is-absolute //= $!SPEC.is-absolute($!path) );
    }

    method parts                  {
        %!parts ||= $!SPEC.split($!path);
    }
    method volume(IO::Path:D:)   { %.parts<volume>   }
    method dirname(IO::Path:D:)  { %.parts<dirname>  }
    method basename(IO::Path:D:) { %.parts<basename> }
    method extension(IO::Path:D:) { MAKE-EXT(self.basename) }

    # core can't do 'basename handles <Numeric Bridge Int>'
    method Numeric(IO::Path:D:) { self.basename.Numeric }
    method Bridge (IO::Path:D:) { self.basename.Bridge  }
    method Int    (IO::Path:D:) { self.basename.Int     }

    multi method Str (IO::Path:D:) { $!path }
    multi method gist(IO::Path:D:) {
        qq|"$.abspath".IO|;
    }
    multi method perl(IO::Path:D:) {
        ($.is-absolute
          ?? "q|$.abspath|.IO(:SPEC({$!SPEC.^name}))"
          !! "q|$.path|.IO(:SPEC({$!SPEC.^name}),:CWD<$!CWD>)"
        ).subst(:global, '\\', '\\\\');
    }

    method succ(IO::Path:D:) {
        self.bless(
          :path($!SPEC.join($.volume,$.dirname,$.basename.succ)),
          :$!SPEC,
          :$!CWD,
        );
    }
    method pred(IO::Path:D:) {
        self.bless(
          :path($!SPEC.join($.volume,$.dirname,$.basename.pred)),
          :$!SPEC,
          :$!CWD,
        );
    }

    method IO(IO::Path:D: |c) { self }

    method open(IO::Path:D: |c) {
        my $handle = IO::Handle.new(:path(self));
        $handle // $handle.throw;
        $handle.open(|c);
    }

    method pipe(IO::Path:D: |c) {
        my $handle = IO::Handle.new(:path(self));
        $handle // $handle.throw;
        $handle.pipe(|c);
    }


    proto method absolute(|) { * }
    multi method absolute (IO::Path:D:) { $.abspath }
    multi method absolute (IO::Path:D: $CWD) {
        self.is-absolute
          ?? $.abspath
          !! $!SPEC.rel2abs($!path, $CWD);
    }

    method relative (IO::Path:D: $CWD = $*CWD) {
        $!SPEC.abs2rel($.abspath, $CWD);
    }

    method cleanup (IO::Path:D:) {
        self.bless(:path($!SPEC.canonpath($!path)), :$!SPEC, :$!CWD);
    }
    method resolve (IO::Path:D:) {
        # XXXX: Not portable yet; assumes POSIX semantics
        my int $max-depth = 256;
        my str $sep       = $!SPEC.dir-sep;
        my str $cur       = $!SPEC.curdir;
        my str $up        = $!SPEC.updir;
        my str $empty     = '';
        my str $resolved  = $empty;
        my Mu  $res-list := nqp::list_s();

        my Mu $parts := nqp::split($sep, nqp::unbox_s(self.absolute));
        while $parts {
            fail "Resolved path too deep!"
                if $max-depth < nqp::elems($res-list) + nqp::elems($parts);

            # Grab next unprocessed part, check for '', '.', '..'
            my str $part = nqp::shift($parts);

            next if nqp::iseq_s($part, $empty) || nqp::iseq_s($part, $cur);
            if nqp::iseq_s($part, $up) {
                next unless $res-list;
                nqp::pop_s($res-list);
                $resolved = $res-list ?? $sep ~ nqp::join($sep, $res-list)
                                      !! $empty;
                next;
            }

            # Normal part, set as next path to test
            my str $next = nqp::concat($resolved, nqp::concat($sep, $part));

            # Path part doesn't exist; handle rest in non-resolving mode
            if !nqp::stat($next, nqp::const::STAT_EXISTS) {
                $resolved = $next;
                while $parts {
                    $part = nqp::shift($parts);
                    next if nqp::iseq_s($part, $empty) || nqp::iseq_s($part, $cur);
                    $resolved = nqp::concat($resolved, nqp::concat($sep, $part));
                }
            }
            # Symlink; read it and act on absolute or relative link
            elsif nqp::fileislink($next) {
                my str $link        = nqp::readlink($next);
                my Mu  $link-parts := nqp::split($sep, $link);
                next unless $link-parts;

                # Symlink to absolute path
                if nqp::iseq_s($link-parts[0], $empty) {
                    $resolved  = nqp::shift($link-parts);
                    $res-list := nqp::list_s();
                }

                nqp::unshift($parts, nqp::pop($link-parts))
                    while $link-parts;
            }
            # Just a plain old path part, so append it and go on
            else {
                $resolved = $next;
                nqp::push_s($res-list, $part);
            }
        }
        $resolved = $sep unless nqp::chars($resolved);
        $resolved;
    }

    method parent(IO::Path:D:) {    # XXX needs work
        my $curdir := $!SPEC.curdir;
        my $updir  := $!SPEC.updir;

        if self.is-absolute {
            return self.bless(
              :path($!SPEC.join($.volume, $.dirname, '')),
              :$!SPEC,
              :$!CWD,
            );
        }
        elsif $.dirname eq $curdir and $.basename eq $curdir {
            return self.bless(
              :path($!SPEC.join($.volume,$curdir,$updir)),
              :$!SPEC,
              :$!CWD,
            );
        }
        elsif $.dirname eq $curdir && $.basename eq $updir
           or !grep({$_ ne $updir}, $!SPEC.splitdir($.dirname)) {
            return self.bless(    # If all updirs, then add one more
              :path($!SPEC.join($.volume,$!SPEC.catdir($.dirname,$updir),$.basename)),
              :$!SPEC,
              :$!CWD,
            );
        }
        else {
            return self.bless(
              :path($!SPEC.join($.volume, $.dirname, '')),
              :$!SPEC,
              :$!CWD,
            );
        }
    }

    method child (IO::Path:D: $child) {
        self.bless(:path($!SPEC.catfile($!path,$child)), :$!SPEC, :$!CWD);
    }

    proto method chdir(|) { * }
    multi method chdir(IO::Path:U: $path, :$test = 'r') {
        $*CWD.chdir($path,:$test);
    }
    multi method chdir(IO::Path:D: Str() $path is copy, :$test = 'r') {
        if !$!SPEC.is-absolute($path) {
            my ($volume,$dirs) = $!SPEC.splitpath(self, :nofile);
            my @dirs = $!SPEC.splitdir($dirs);
            @dirs.shift; # the first is always empty for absolute dirs
            for $!SPEC.splitdir($path) -> $dir {
                if $dir eq '..' {
                    @dirs.pop if @dirs;
                }
                elsif $dir ne '.' {
                    @dirs.push: $dir;
                }
            }
            @dirs.push('') if !@dirs;  # need at least the rootdir
            $path = join($!SPEC.dir-sep, $volume, @dirs);
        }
        my $dir = IO::Path.new-from-absolute-path($path,:$!SPEC,:CWD(self));

        # basic sanity
        unless $dir.d {
            fail X::IO::Chdir.new(
              :$path,
              :os-error( $dir.e
                ?? "is not a directory"
                !! "does not exist"),
            );
        }

        if $test eq 'r' {
            return $dir if $dir.r;
        }
        elsif $test eq 'r w' {
            return $dir if $dir.r and $dir.w;
        }
        elsif $test eq 'r w x' {
            return $dir if $dir.r and $dir.w and $dir.x;
        }

        fail X::IO::Chdir.new(
          :$path,
          :os-error("did not pass 'd $test' test"),
        );
    }

    proto method rename(|) { * }
    multi method rename(IO::Path:D: IO::Path:D $to, :$createonly) {
        if $createonly and $to.e {
            fail X::IO::Rename.new(
              :from($.abspath),
              :$to,
              :os-error(':createonly specified and destination exists'),
            );
        }
        nqp::rename($.abspath, nqp::unbox_s($to.abspath));
        CATCH { default {
            fail X::IO::Rename.new(
              :from($!abspath), :$to($to.abspath), :os-error(.Str) );
        } }
        True;
    }
    multi method rename(IO::Path:D: $to, :$CWD = $*CWD, |c) {
        self.rename($to.IO(:$!SPEC,:$CWD),|c);
    }

    proto method copy(|) { * }
    multi method copy(IO::Path:D: IO::Path:D $to, :$createonly) {
        if $createonly and $to.e {
            fail X::IO::Copy.new(
              :from($.abspath),
              :$to,
              :os-error(':createonly specified and destination exists'),
            );
        }
        nqp::copy($.abspath, nqp::unbox_s($to.abspath));
        CATCH { default {
            fail X::IO::Copy.new(
              :from($!abspath), :$to, :os-error(.Str) );
        } }
        True;
    }
    multi method copy(IO::Path:D: $to, :$CWD  = $*CWD, |c) {
        self.copy($to.IO(:$!SPEC,:$CWD),|c);
    }

    method chmod(IO::Path:D: Int() $mode) {
        nqp::chmod($.abspath, nqp::unbox_i($mode));
        CATCH { default {
            fail X::IO::Chmod.new(
              :path($!abspath), :$mode, :os-error(.Str) );
        } }
        True;
    }
    method unlink(IO::Path:D:) {
        nqp::unlink($.abspath);
        CATCH { default {
            fail X::IO::Unlink.new( :path($!abspath), os-error => .Str );
        } }
        True;
    }

    method symlink(IO::Path:D: $name is copy, :$CWD  = $*CWD) {
        $name = $name.IO(:$!SPEC,:$CWD).path;
        nqp::symlink(nqp::unbox_s($name), $.abspath);
        CATCH { default {
            fail X::IO::Symlink.new(:target($!abspath), :$name, os-error => .Str);
        } }
        True;
    }

    method link(IO::Path:D: $name is copy, :$CWD  = $*CWD) {
        $name = $name.IO(:$!SPEC,:$CWD).path;
        nqp::link(nqp::unbox_s($name), $.abspath);
        CATCH { default {
            fail X::IO::Link.new(:target($!abspath), :$name, os-error => .Str);
        } }
        True;
    }

    method mkdir(IO::Path:D: $mode = 0o777) {
        nqp::mkdir($.abspath, $mode);
        CATCH { default {
            fail X::IO::Mkdir.new(:path($!abspath), :$mode, os-error => .Str);
        } }
        True;
    }

    method rmdir(IO::Path:D:) {
        nqp::rmdir($.abspath);
        CATCH { default {
            fail X::IO::Rmdir.new(:path($!abspath), os-error => .Str);
        } }
        True;
    }

    method contents(IO::Path:D: |c) {
        DEPRECATED('dir', |<2014.10 2015.10>);
        self.dir(|c);
    }

    method dir(IO::Path:D:
        Mu :$test = $*SPEC.curupdir,
        :$absolute,
        :$Str,
        :$CWD = $*CWD,
    ) {

        CATCH { default {
            fail X::IO::Dir.new(
              :path(nqp::box_s($.abspath,Str)), :os-error(.Str) );
        } }
        my $cwd_chars = $CWD.chars;

        my $abspath-sep := $.abspath eq $!SPEC.dir-sep
          ?? $!SPEC.dir-sep
          !! $.abspath ~ $!SPEC.dir-sep;

        my Mu $dirh := nqp::opendir(nqp::unbox_s($.abspath));
        gather {
            for <. ..> -> $elem {
                if $test.ACCEPTS($elem) {
                    $Str
                      ?? $absolute
                        ?? take $abspath-sep ~ $elem
                        !! take substr($abspath-sep ~ $elem,$cwd_chars + 1)
                      !! $absolute
                        ?? take IO::Path.new-from-absolute-path($abspath-sep ~ $elem,:$!SPEC,:$CWD)
                        !! take substr($abspath-sep ~ $elem,$cwd_chars + 1).IO(:$!SPEC,:$CWD);
                }
            }
            loop {
                my str $str_elem = nqp::nextfiledir($dirh);
                if nqp::isnull_s($str_elem) || nqp::chars($str_elem) == 0 {
                    nqp::closedir($dirh);
                    last;
                }
                my Str $elem = nqp::box_s($str_elem,Str);
                if $test.ACCEPTS($!SPEC.basename($elem)) {
                    $Str
                      ?? !$absolute && !$.is-absolute
                        ?? take substr($elem,$cwd_chars + 1)
                        !! take $elem
                      !! !$absolute && !$.is-absolute
                        ?? take substr($elem,$cwd_chars + 1).IO(:$!SPEC,:$CWD)
                        !! take IO::Path.new-from-absolute-path($elem,:$!SPEC,:$CWD);
                }
            }
        }
    }

    proto method slurp() { * }
    multi method slurp(IO::Path:D: :$bin, :$enc) {
        my $handle = self.open;
        $handle // $handle.throw;

        my Mu $PIO := nqp::getattr(nqp::decont($handle),IO::Handle,'$!PIO');
        if $bin {
            my $Buf := buf8.new();
            loop {
                my $buf := buf8.new();
                nqp::readfh($PIO,$buf,65536);
                last if $buf.bytes == 0;
                $Buf := $Buf ~ $buf;
            }
            $handle.close;
            $Buf;
        }
        else {
            $handle.encoding($enc) if $enc.defined;
            my $slurped := nqp::p6box_s(nqp::readallfh($PIO));
            $handle.close;
            $slurped;
        }
    }

    method !spurt($what, :$enc, :$append, :$createonly, :$bin, |c) {
        if $createonly and $.e {
            fail("File '$!path' already exists, and :createonly was specified");
        }
        my $mode = $append ?? :a !! :w;
        my $handle = self.open(:enc($enc // 'utf8'), :$bin, |$mode, |c);
        $handle // $handle.throw;

        my $spurt := $bin
          ?? $handle.write($what)
          !! $handle.print($what);
        $handle.close;  # can't use LEAVE in settings :-(
        $spurt;
    }

    proto method spurt(|) { * }
    multi method spurt(IO::Path:D: Blob $what, :$bin, |c) {
        self!spurt($what, :bin, |c );
    }
    multi method spurt(IO::Path:D: Cool $what, :$bin, |c) {
        self!spurt($what, :!bin, |c );
    }

    proto method lines() { * }
    multi method lines(IO::Path:D: |c) {
        my $handle = self.open(|c);
        $handle && $handle.lines(:close, |c);
    }

    proto method words() { * }
    multi method words(IO::Path:D: |c) {
        my $handle = self.open(|c);
        $handle && $handle.words(:close, |c);
    }

    my %t =
      e => -> $p { True }, # if we get here, it exists
      d => -> $p { nqp::p6bool(nqp::stat(nqp::unbox_s($p),nqp::const::STAT_ISDIR)) },
      f => -> $p { nqp::p6bool(nqp::stat(nqp::unbox_s($p),nqp::const::STAT_ISREG)) },
      s => -> $p { %t.AT-KEY("f")($p) && nqp::box_i(nqp::stat(nqp::unbox_s($p),nqp::const::STAT_FILESIZE),Int) },
      l => -> $p { nqp::p6bool(nqp::fileislink(nqp::unbox_s($p))) },
      r => -> $p { nqp::p6bool(nqp::filereadable(nqp::unbox_s($p))) },
      w => -> $p { nqp::p6bool(nqp::filewritable(nqp::unbox_s($p))) },
      x => -> $p { nqp::p6bool(nqp::fileexecutable(nqp::unbox_s($p))) },
      z => -> $p { %t.AT-KEY("f")($p) && nqp::p6bool(nqp::stat(nqp::unbox_s($p),nqp::const::STAT_FILESIZE) == 0) },

      "!e" => -> $p { False }, # if we get here, it exists
      "!d" => -> $p { !%t.AT-KEY("d")($p) },
      "!f" => -> $p { !%t.AT-KEY("f")($p) },
      "!l" => -> $p { !%t.AT-KEY("l")($p) },
      "!r" => -> $p { !%t.AT-KEY("r")($p) },
      "!w" => -> $p { !%t.AT-KEY("w")($p) },
      "!x" => -> $p { !%t.AT-KEY("x")($p) },
      "!z" => -> $p { !%t.AT-KEY("z")($p) },
    ;

    method all(*@tests) {
        return False if !@tests or !$.e;

        my $result = True;
        for @tests -> $t {
            die "Unknown test $t" unless %t.EXISTS-KEY($t);
            last unless $result = $result && %t.AT-KEY($t)($!abspath);
        }

        $result;
    }

    method e() { $!e //= FILETEST-E($.abspath) }

    method d() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<d>) if !$.e;
        FILETEST-D($!abspath);
    }

    method f() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<f>) if !$.e;
        FILETEST-F($!abspath);
    }

    method s() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<s>) if !$.e;
        fail X::IO::NotAFile.new(:path(self.Str),:trying<s>)     if !$.f;
        FILETEST-S($!abspath);
    }

    method l() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<l>) if !$.e;
        FILETEST-L($!abspath);
    }

    method r() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<r>) if !$.e;
        FILETEST-R($!abspath);
    }

    method w() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<w>) if !$.e;
        FILETEST-W($!abspath);
    }

    method rw() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<w>) if !$.e;
        FILETEST-RW($!abspath);
    }

    method x() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<x>) if !$.e;
        FILETEST-X($!abspath);
    }

    method rwx() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<w>) if !$.e;
        FILETEST-RWX($!abspath);
    }

    method z() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<z>) if !$.e;
        fail X::IO::NotAFile.new(:path(self.Str),:trying<z>)     if !$.f;
        FILETEST-Z($!abspath);
    }

    method modified() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<modified>) if !$.e;
        FILETEST-MODIFIED($!abspath);
    }

    method accessed() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<accessed>) if !$.e;
        FILETEST-ACCESSED($!abspath);
    }

    method changed() {
        fail X::IO::DoesNotExist.new(:path(self.Str),:trying<changed>) if !$.e;
        FILETEST-CHANGED($!abspath);
    }

    method directory() {
        DEPRECATED("dirname", |<2014.10 2015.10>);
        self.dirname;
    }
}

my class IO::Path::Cygwin is IO::Path {
    method new(|c) { IO::Path.new(|c, :SPEC(IO::Spec::Cygwin) ) }
}
my class IO::Path::QNX is IO::Path {
    method new(|c) { IO::Path.new(|c, :SPEC(IO::Spec::QNX) ) }
}
my class IO::Path::Unix is IO::Path {
    method new(|c) { IO::Path.new(|c, :SPEC(IO::Spec::Unix) ) }
}
my class IO::Path::Win32 is IO::Path {
    method new(|c) { IO::Path.new(|c, :SPEC(IO::Spec::Win32) ) }
}

# From 'src/core/IO/Dup.pm'


# From 'src/core/IO/Special.pm'

class IO::Special {
    has Str $.what;

    submethod BUILD(:$!what!)    { }
    method WHICH(IO::Special:D:) { "IO::Special$!what" }
    method Str(IO::Special:D:)   { $!what }

    method IO(IO::Special:D:) { self }

    method e(IO::Special:D:) { True }
    method d(IO::Special:D:) { False }
    method f(IO::Special:D:) { False }
    method s(IO::Special:D:) { 0 }
    method l(IO::Special:D:) { False }
    method r(IO::Special:D:) { $!what eq '<IN>' }
    method w(IO::Special:D:) { $!what eq '<OUT>' or $!what eq '<ERR>' }
    method x(IO::Special:D:) { False }
    method modified(IO::Special:D:) { Instant }
    method accessed(IO::Special:D:) { Instant }
    method changed(IO::Special:D:)  { Instant}
}
# From 'src/core/io_operators.pm'

my class IO::ArgFiles { ... }

sub print(|) {
    my $args := nqp::p6argvmarray();
    my $out := $*OUT;
    $out.print(nqp::shift($args)) while $args;
    Bool::True
}

proto sub say(|) { * }
multi sub say()              { $*OUT.print: "\n" }
multi sub say(Obsolete:D \o) { $*OUT.print: o.gist ~ "\n" }
multi sub say(Str:D \x)      { $*OUT.print: x ~ "\n" }
multi sub say(\x)            { $*OUT.print: x.gist ~ "\n" }
multi sub say(|) {
    my $args := nqp::p6argvmarray();
    my $out := $*OUT;
    $out.print(nqp::shift($args).gist) while $args;
    $out.print("\n");
}

proto sub note(|) { * }
multi sub note() {
    $*ERR.print("Noted\n");
}
multi sub note(Str:D \x) {
    my $err := $*ERR;
    $err.print(x);
    $err.print("\n");
}
multi sub note(\x) {
    my $err := $*ERR;
    $err.print(x.gist);
    $err.print("\n");
}
multi sub note(|) {
    my $args := nqp::p6argvmarray();
    my $err := $*ERR;
    $err.print(nqp::shift($args).gist) while $args;
    $err.print("\n");
}

sub gist(|) {
    nqp::p6parcel(nqp::p6argvmarray(), Mu).gist
}

sub prompt($msg) {
    my $out := $*OUT;
    $out.print($msg);
    $out.flush();
    $*IN.get;
}

proto sub dir(|) { * }
multi sub dir(*%_) {
    $*SPEC.curdir.IO.dir(:!absolute, |%_)
}
multi sub dir(IO::Path:D $path, |c) {
    $path.dir(|c)
}
multi sub dir(Cool $path, |c) {
    $path.IO.dir(|c)
}

proto sub open(|) { * }
multi sub open($path, :$chomp = True, :$enc = 'utf8', |c) {
    my $handle = IO::Handle.new(:path($path.IO));
    $handle // $handle.throw;
    $handle.open(:$chomp,:$enc,|c);
}

proto sub pipe(|) { * }
multi sub pipe($path, :$chomp = True, :$enc = 'utf8', |c) {
    my $handle = IO::Handle.new(:path($path.IO));
    $handle // $handle.throw;
    $handle.pipe(:$chomp,:$enc,|c);
}

proto sub lines(|) { * }
multi sub lines($what = $*ARGFILES, $limit = Inf, *%named) {
    $limit == Inf || nqp::istype($limit,Whatever)
      ?? $what.lines(|%named)
      !! $what.lines($limit, |%named);
}

proto sub get(|) { * }
multi sub get($fh = $*ARGFILES) {
    $fh.get()
}

proto sub getc(|) { * }
multi sub getc($fh = $*ARGFILES) {
    $fh.getc()
}

proto sub close(|) { * }
multi sub close($fh) {
    $fh.close()
}

proto sub slurp(|) { * }
multi sub slurp(IO::ArgFiles:D $io = $*ARGFILES, :$bin, :$enc = 'utf8', |c) {
    my $result := $io.slurp(:$bin, :$enc, |c);
    $result // $result.throw;
}
multi sub slurp(IO::Handle:D $io = $*ARGFILES, :$bin, :$enc = 'utf8', |c) {
    DEPRECATED('slurp($path,...)',|<2014.10 2015.10>,:what<slurp($handle,...)>);
    my $result := $io.slurp-rest(:$bin, :$enc, |c);
    $result // $result.throw;
}
multi sub slurp(Cool:D $path, :$bin = False, :$enc = 'utf8', |c) {
    my $result := $path.IO.slurp(:$bin, :$enc, |c);
    $result // $result.throw;
}

proto sub spurt(|) { * }
multi sub spurt(IO::Handle $fh, $what, :$enc = 'utf8', |c ) {
    DEPRECATED('spurt($path,...)',|<2014.10 2015.10>,:what<spurt($handle,...)>);
    my $result := $fh.spurt($what, :$enc, :nodepr, |c);
    $result // $result.throw;
}
multi sub spurt(Cool $path, $what, :$enc = 'utf8', |c) {
    my $result := $path.IO.spurt($what, :$enc, |c);
    $result // $result.throw;
}

{
    sub chdir(Str() $path) {
        nqp::chdir(nqp::unbox_s($path));
        $*CWD = IO::Path.new(cwd());
        return True;
        CATCH {
            default {
                X::IO::Chdir.new(
                    :$path,
                    os-error => .Str,
                ).throw;
            }
        }
    }
    PROCESS::<&chdir> := &chdir;
}

sub chdir(Str() $path, :$test = 'r') {

    if !nqp::istype($*CWD,IO::Path) {   # canary until 2014.10
        warn "\$*CWD is a {$*CWD.^name}, not an IO::Path!!!";
        $*CWD = $*CWD.IO;
    }

    my $newCWD := $*CWD.chdir($path,:$test);
    $newCWD // $newCWD.throw;

    $*CWD = $newCWD;
}

sub indir(Str() $path, $what, :$test = <r w>) {
    my $newCWD := $*CWD.chdir($path,:$test);
    $newCWD // $newCWD.throw;

    {
        my $*CWD = $newCWD;  # temp doesn't work in core settings :-(
        $what();
    }
}

sub tmpdir(Str() $path, :$test = <r w x>) {
    my $newTMPDIR := $*TMPDIR.chdir($path,:$test);
    $newTMPDIR // $newTMPDIR.throw;

    $*TMPDIR = $newTMPDIR;
}

sub homedir(Str() $path, :$test = <r w x>) {
    my $newHOME := $*HOME.chdir($path,:$test);
    $newHOME // $newHOME.throw;

    $*HOME = $newHOME;
}

PROCESS::<$IN> =
  IO::Handle.new(:path(IO::Special.new(:what(<< <STDIN>  >>)))).open;
PROCESS::<$OUT> =
  IO::Handle.new(:path(IO::Special.new(:what(<< <STDOUT> >>)))).open;
PROCESS::<$ERR> =
  IO::Handle.new(:path(IO::Special.new(:what(<< <STDERR> >>)))).open;

sub chmod($mode, *@filenames, :$SPEC = $*SPEC, :$CWD = $*CWD) {
    my @ok;
    for @filenames -> $file {
        @ok.push($file) if $file.IO(:$SPEC,:$CWD).chmod($mode);
    }
    @ok;
#    @filenames.grep( *.IO(:$SPEC,:$CWD).chmod($mode) ).eager;
}
sub unlink(*@filenames, :$SPEC = $*SPEC, :$CWD = $*CWD)       {
    my @ok;
    for @filenames -> $file {
        @ok.push($file) if $file.IO(:$SPEC,:$CWD).unlink;
    }
    @ok;
#    @filenames.grep( *.IO(:$SPEC,:$CWD).unlink ).eager;
}
sub rmdir(*@filenames, :$SPEC = $*SPEC, :$CWD = $*CWD) {
    my @ok;
    for @filenames -> $file {
        @ok.push($file) if $file.IO(:$SPEC,:$CWD).rmdir;
    }
    @ok;
#    @filenames.grep( *.IO(:$SPEC,:$CWD).rmdir ).eager;
}

proto sub mkdir(|) { * }
multi sub mkdir(Int $mode, *@dirnames, :$SPEC = $*SPEC, :$CWD = $*CWD) {
    @dirnames.grep( *.IO(:$SPEC,:$CWD).mkdir($mode) ).eager;
}
multi sub mkdir($path, $mode = 0o777, :$SPEC = $*SPEC, :$CWD = $*CWD) {
    $path.IO(:$SPEC,:$CWD).mkdir($mode) ?? ($path,) !! ();
}

sub rename($from, $to, :$SPEC = $*SPEC, :$CWD = $*CWD) {
    my $result := $from.IO(:$SPEC,:$CWD).rename($to,:$SPEC,:$CWD);
    $result // $result.throw;
}
sub copy($from, $to, :$SPEC = $*SPEC, :$CWD = $*CWD) {
    my $result := $from.IO(:$SPEC,:$CWD).copy($to,:$SPEC,:$CWD);
    $result // $result.throw;
}
sub symlink($target, $name, :$SPEC = $*SPEC, :$CWD = $*CWD) {
    my $result := $target.IO(:$SPEC,:$CWD).symlink($name,:$SPEC,:$CWD);
    $result // $result.throw;
}
sub link($target, $name, :$SPEC = $*SPEC, :$CWD = $*CWD) {
    my $result := $target.IO(:$SPEC,:$CWD).link($name,:$SPEC,:$CWD);
    $result // $result.throw;
}

sub cwd() {
    DEPRECATED('$*CWD', |<2014.10 2015.10>);
    $*CWD;
}

# From 'src/core/IO/ArgFiles.pm'

my class IO::ArgFiles is IO::Handle {
    has $.args;
    has $.filename;
    has $!io;
    has $.ins;
    has $!nl = "\n";

    method eof() {
        ! $!args && $!io.opened && $!io.eof
    }

    method get() {
        unless $!io.defined && $!io.opened {
            $!filename = $!args ?? $!args.shift !! '-';
            $!io = open($!filename, :r, :nl($!nl)) ||
                fail "Unable to open file '$!filename'";
        }
        my $x = $!io.get;
        while !$x.defined {
            $!io.close;
            $!io = IO::Handle;
            fail "End of argfiles reached" unless $!args;
            $x = self.get;
        }
        $!ins++;
        $x;
    }

    method lines($limit = *) {
        my $l = nqp::istype($limit,Whatever) ?? Inf !! $limit;
        gather while $l-- > 0 {
           take $.get // last;
        }
    }
    method slurp(IO::ArgFiles:D:) {
        my @chunks;
        if $!io && $!io.opened {
            @chunks.push: nqp::p6box_s($!io.readall);
            $!io.close;
        }
        while $!args {
            @chunks.push: slurp $!args.shift;
        }
        return $*IN.slurp-rest unless @chunks;
        @chunks.join;
    }

    method nl {
        Proxy.new(
          FETCH => {
              $!nl
          },
          STORE => -> $, $nl {
              if $!io.defined {
                  nqp::setinputlinesep($!io, nqp::unbox_s($!nl = $nl));
              }
              $!nl = $nl;
          }
        );
    }
}

# From 'src/core/AST.pm'

#      problems with the serialization context calling it that.
my class AST {
    has $!past;
    has $!quasi_context;
    has $!Str;

    submethod BUILD(:$past) {
        $!past := $past;
    }

    method incarnate($quasi_context, @unquote_asts) {
        my $incarnation = self.clone();
        nqp::bindattr(nqp::decont($incarnation), AST, '$!past', $incarnation.evaluate_unquotes(@unquote_asts));
        nqp::bindattr(nqp::decont($incarnation), AST, '$!quasi_context', $quasi_context);
        return $incarnation;
    }

    method evaluate_unquotes(@unquote_asts) {
        my $pasts := nqp::list();
        for @unquote_asts {
            # TODO: find and report macro name
            X::TypeCheck::Splice.new(
                got      => $_,
                expected => AST,
                action   => 'unquote evaluation',
            ).throw unless nqp::istype($_,AST);
            nqp::push($pasts, nqp::getattr(nqp::decont($_), AST, '$!past'))
        }
        $!past.evaluate_unquotes($pasts);
    }

    method is_quasi_ast {
        so $!quasi_context;
    }

    method Str {
        $!Str;
    }
}

# From 'src/core/CallFrame.pm'

my class CallFrame {
    has Int $.level;
    has %.annotations;
    has %.my;
    method new(Int :$level = 0) {
        my $l = $level + 1;
        my $self := nqp::create(CallFrame);
        my $i = $l;
        my Mu $ctx := nqp::ctx();
        while $i-- {
            $ctx := nqp::ctxcaller($ctx);
        }
        my $h := nqp::create(EnumMap);
        nqp::bindattr($h, EnumMap, '$!storage', $ctx);
        nqp::bindattr($self, CallFrame, '%!my', $h);
        nqp::bindattr($self, CallFrame, '$!level', $l);

        my $e  := nqp::handle(nqp::die(''), 'CATCH', nqp::exception());
        my $bt := nqp::backtrace($e);
        nqp::bindattr($self, CallFrame, '%!annotations',
            nqp::hllize(nqp::atkey(nqp::atpos($bt, $l), 'annotations')));

        $self;
    }

    method line() {
        %.annotations<line>;
    }
    method file() {
        %.annotations<file>;
    }

    method callframe(Int $level = 0) {
        X::NYI.new(feature => 'Callframe.callframe').throw;
    }
}

sub callframe(Int $level = 0) {
    CallFrame.new(level => ($level + 1));
}

# From 'src/core/Main.pm'

# * Align number parsing to STD
#   * Rakudo's .Numeric
#     * complex numbers
#   * Rakudo's grammar
#   * val()
# * Strengthen val()
#   * Make val() available globally
# * $?USAGE
#   * Create $?USAGE at compile time
#   * Make $?USAGE available globally
# * Command-line parsing
#   * Allow both = and space before argument of double-dash args
#   * Comma-separated list values
#   * Allow exact Perl 6 forms, quoted away from shell
# * Fix remaining XXXX

my sub MAIN_HELPER($retval = 0) is hidden-from-backtrace {
    # Do we have a MAIN at all?
    my $m = callframe(1).my<&MAIN>;
    return $retval unless $m;

    # Temporary stand-in for magic val() routine
    my sub hack-val ($v) {
        # Convert to native type if appropriate

        my $val;
        if    $v ~~ /^ 'Bool::'?'False' $/ { $val := Bool::False }
        elsif $v ~~ /^ 'Bool::'?'True'  $/ { $val := Bool::True  }
        elsif $v.Numeric.defined           { $val := +$v }
        else                               { return $v   }

        # Mix in original stringifications
        my role orig-string[$orig] {
                  method Str  ()      { $orig.Str  }
            multi method gist (Mu:D:) { $orig.gist }
        };
        return $val but orig-string[$v];
    }

    # Convert raw command line args into positional and named args for MAIN
    my sub process-cmd-args (@args is copy) {
        my (@positional-arguments, %named-arguments);
        while (@args) {
            my $passed-value = @args.shift;
            if $passed-value ~~ /^ ( '--' | '-' | ':' ) ('/'?) (<-[0..9\.]> .*) $/ {
                my ($switch, $negate, $arg) = (~$0, ?((~$1).chars), ~$2);

                if $arg.index('=').defined  {
                    my ($name, $value) = $arg.split('=', 2);
                    $value = hack-val($value);
                    $value = $value but False if $negate;
                    %named-arguments.push: $name => $value;
                } else {
                    %named-arguments.push: $arg => !$negate;
                }
            } else {
                @args.unshift($passed-value) unless $passed-value eq '--';
                @positional-arguments.push: @args.map: &hack-val;
                last;
            }
        }
        $PROCESS::ARGFILES = IO::ArgFiles.new(:args(@args));
        return @positional-arguments, %named-arguments;
    }

    # Generate $?USAGE string (default usage info for MAIN)
    my sub gen-usage () {
        my @help-msgs;

        my sub strip_path_prefix($name) {
            my $SPEC := $*SPEC;
            my ($vol, $dir, $base) = $SPEC.splitpath($name);
            $dir = $SPEC.canonpath($dir);
            for $SPEC.path() -> $elem {
                if $SPEC.catpath($vol, $elem, $base).IO.x {
                    return $base if $SPEC.canonpath($elem) eq $dir;
                    # Shadowed command found in earlier PATH element
                    return $name;
                }
            }
            # Not in PATH
            return $name;
        }

        my $prog-name = $*PROGRAM_NAME eq '-e' ?? "-e '...'" !! strip_path_prefix($*PROGRAM_NAME);
        for $m.candidates -> $sub {
            next if $sub.?is-hidden-from-USAGE;
            my (@required-named, @optional-named, @positional, $docs);
            for $sub.signature.params -> $param {
                my $argument;
                if $param.named {
                    my @names  = $param.named_names.reverse;
                    $argument  = @names.map({($^n.chars == 1 ?? '-' !! '--') ~ $^n}).join('|');
                    $argument ~= "=<{$param.type.^name}>" unless $param.type === Bool;
                    if $param.optional {
                        @optional-named.push("[$argument]");
                    }
                    else {
                        @required-named.push($argument);
                    }
                }
                else {
                    my $constraints  = $param.constraint_list.map(*.gist).join(' ');
                    my $simple-const = $constraints && $constraints !~~ /^_block/;
                    $argument = $param.name   ?? '<' ~ substr($param.name,1) ~ '>' !!
                                $simple-const ??       $constraints                !!
                                                 '<' ~ $param.type.^name     ~ '>' ;

                    $argument = "[$argument ...]" if $param.slurpy;
                    $argument = "[$argument]"     if $param.optional;
                    @positional.push($argument);
                }
            }
            if $sub.WHY {
                $docs = '-- ' ~ $sub.WHY.contents
            }
            my $msg = join(' ', $prog-name, @required-named, @optional-named, @positional, $docs // '');
            @help-msgs.push($msg);
        }
        my $usage = "Usage:\n" ~ @help-msgs.map('  ' ~ *).join("\n");
        return $usage;
    }

    sub has-unexpected-named-arguments($signature, %named-arguments) {
        my @named-params = $signature.params.grep: *.named;
        return False if @named-params.grep: *.slurpy;

        my %accepts-argument = @named-params.map({ .named_names }) Z=> 1 xx *;
        for %named-arguments.keys -> $name {
            return True if !%accepts-argument{$name}
        }

        return False;
    }

    # Process command line arguments
    my ($p, $n) = process-cmd-args(@*ARGS).lol;

    # Generate default $?USAGE message
    my $usage;
    my $?USAGE := Proxy.new(
        FETCH => -> | { $usage || ($usage = gen-usage()) },
        STORE => -> | { }
    );

    # Get a list of candidates that match according to the dispatcher
    my @matching_candidates = $m.cando(Capture.new(list => $p, hash => $n));
    # Sort out all that would fail due to binding
    @matching_candidates .=grep: {!has-unexpected-named-arguments($_.signature, $n)};
    # If there are still some candidates left, try to dispatch to MAIN
    if +@matching_candidates {
        return $m(|@($p), |%($n));
    }

    # We could not find the correct MAIN to dispatch to!
    # Let's try to run a user defined USAGE sub
    my $h = callframe(1).my<&USAGE>;
    return $h() if $h;

    # We could not find a user defined USAGE sub!
    # Let's display the default USAGE message
    if $n<help> {
        $*OUT.say($?USAGE);
        exit 1;
    }
    else {
        $*ERR.say($?USAGE);
        exit 2;
    }
}

# From 'src/core/tai-utc.pm'



my module tai-utc {

    #our $initial-offset = 10;
    our sub initial-offset() { 10 }
      # TAI - UTC at the Unix epoch (1970-01-01T00:00:00Z).

    # our @leap-second-dates = <
    our sub leap-second-dates() {
        BEGIN
        #BEGIN leap-second-dates
        (
        '1972-06-30',
        '1972-12-31',
        '1973-12-31',
        '1974-12-31',
        '1975-12-31',
        '1976-12-31',
        '1977-12-31',
        '1978-12-31',
        '1979-12-31',
        '1981-06-30',
        '1982-06-30',
        '1983-06-30',
        '1985-06-30',
        '1987-12-31',
        '1989-12-31',
        '1990-12-31',
        '1992-06-30',
        '1993-06-30',
        '1994-06-30',
        '1995-12-31',
        '1997-06-30',
        '1998-12-31',
        '2005-12-31',
        '2008-12-31',
        '2012-06-30',
        '2015-06-30',
        )
        #END leap-second-dates
    };

    # our %leap-seconds =
    #     @leap-second-dates Z=> $initial-offset + 1 .. *;

    # So for any date $d in @leap-second-dates, $d 23:59:00 UTC
    # is the leap second that made (or will make) UTC
    # %leap-seconds{$d} seconds behind TAI.

    # Ambiguous POSIX times.
    our sub leap-second-posix() {
        BEGIN
        #BEGIN leap-second-posix
        (
          78796800,
          94694400,
         126230400,
         157766400,
         189302400,
         220924800,
         252460800,
         283996800,
         315532800,
         362793600,
         394329600,
         425865600,
         489024000,
         567993600,
         631152000,
         662688000,
         709948800,
         741484800,
         773020800,
         820454400,
         867715200,
         915148800,
        1136073600,
        1230768000,
        1341100800,
        1435708800,
        )
        #END leap-second-posix
    };

};

# From 'src/core/Instant.pm'

my class Duration {... }

my class Instant is Cool does Real {
    has Rat $.tai;
      # A linear count of seconds since 1970-01-01T00:00:00Z, plus
      # tai-utc::initial-offset. Thus, $.tai matches TAI from 1970
      # to the present.

    method new($tai) { self.bless: tai => $tai.Rat }

    method from-posix($posix, Bool $prefer-leap-second = False) {
    # $posix is in general not expected to be an integer.
    # If $prefer-leap-second is true, 915148800 is interpreted to
    # mean 1998-12-31T23:59:60Z rather than 1999-01-01T00:00:00Z.
        my $p = $posix.floor;
        my $offset = tai-utc::initial-offset;
        for tai-utc::leap-second-posix() {
            if $_ < $p {
                ++$offset;
            } else {
                return self.new: $posix + $offset + do
                    $_ == $p && !$prefer-leap-second
            }
        }
        self.new: $posix + $offset;
    }

    method to-posix() {
    # The inverse of .from-posix, except that the second return
    # value is true if *and only if* this Instant is in a leap
    # second.
        my $n = $.tai.floor;
        my $offset = tai-utc::initial-offset;
        for tai-utc::leap-second-posix() {
            if $_ < $n - $offset {
                ++$offset;
            } else {
                return ($.tai - $offset, $n - $offset == $_)
            }
        }
        ($.tai - $offset, False)
    }

    multi method Str(Instant:D:) {
        'Instant:' ~ $.tai
    }
    multi method perl(Instant:D:) {
        "Instant.new($.tai.perl())";
    }
    method Bridge(Instant:D:) { $.tai.Bridge }
    method Num   (Instant:D:) { $.tai.Num    }
    method Int   (Instant:D:) { $.tai.Int    }
    method narrow(Instant:D:) { $.tai.narrow }

#    TODO: should be the new .gist, probably
#    method Str() {
#        'Instant:' ~ default-formatter
#            ::DateTime.new(self), :subseconds
#    }
}

multi sub infix:cmp(Instant:D $a, Instant:D $b) {
    $a.tai <=> $b.tai }

multi sub infix:<=>(Instant:D $a, Instant:D $b) {
    $a.tai <=> $b.tai
}

multi sub infix:==(Instant:D $a, Instant:D $b) {
    $a.tai == $b.tai
}

multi sub infix:!=(Instant:D $a, Instant:D $b) {
    $a.tai != $b.tai
}

multi sub infix:<(Instant:D $a, Instant:D $b) {
    $a.tai < $b.tai
}

multi sub infix:>(Instant:D $a, Instant:D $b) {
    $a.tai > $b.tai
}

multi sub infix:<=(Instant:D $a, Instant:D $b) {
    $a.tai <= $b.tai
}

multi sub infix:>=(Instant:D $a, Instant:D $b) {
    $a.tai >= $b.tai
}

multi sub infix:<+>(Instant:D $a, Real:D $b) {
    Instant.new: $a.tai + $b;
}
multi sub infix:<+>(Real:D $a, Instant:D $b) {
    Instant.new: $a + $b.tai;
}
multi sub infix:<+>(Instant:D $a, Duration:D $b) {
    Instant.new: $a.tai + $b.tai;
}
multi sub infix:<+>(Duration:D $a, Instant:D $b) {
    Instant.new: $a.tai + $b.tai;
}

multi sub infix:<->(Instant:D $a, Instant:D $b) {
    Duration.new: $a.tai - $b.tai;
}
multi sub infix:<->(Instant:D $a, Real:D $b) {
    Instant.new: $a.tai - $b;
}

sub term:<time>() { nqp::p6box_i(nqp::time_i()) }
sub term:<now>() {
    # FIXME: During a leap second, the returned value is one
    # second greater than it should be.
    Instant.from-posix: nqp::time_n
}

#{
    my num $init-time-num = nqp::time_n;  # need find a way to not leak this
    multi sub INITIALIZE_DYNAMIC('$*INITTIME') {
        PROCESS::<$INITTIME> := Instant.from-posix: $init-time-num;
    }
#}

# From 'src/core/Duration.pm'

my class Duration is Cool does Real {
    has Rat $.tai = 0;
      # A linear count of seconds.

    method new($tai) { self.bless: tai => $tai.Rat }

    method Bridge(Duration:D:) { $!tai.Num }
    method Rat(Duration:D:)    { $!tai     }
    method Num(Duration:D:)    { $!tai.Num }
    method narrow(Duration:D:) { $!tai.narrow }

    multi method Str(Duration:D:) { ~$.tai }

    multi method perl(Duration:D:) { "Duration.new({$.tai.perl})" }
}

multi sub prefix:<->(Duration:D $a) {
    Duration.new: -$a.tai;
}

multi sub infix:<+>(Duration:D $a, Real $b) {
    Duration.new: $a.tai + $b;
}
multi sub infix:<+>(Real $a, Duration:D $b) {
    Duration.new: $a + $b.tai;
}
multi sub infix:<+>(Duration:D $a, Duration:D $b) {
    Duration.new: $a.tai + $b.tai;
}

multi sub infix:<->(Duration:D $a, Real $b) {
    Duration.new: $a.tai - $b;
}
multi sub infix:<->(Duration:D $a, Duration:D $b) {
    Duration.new: $a.tai - $b.tai;
}

multi sub infix:<%>(Duration:D $a, Real $b) {
    Duration.new: $a.tai % $b
}

# From 'src/core/Temporal.pm'

my class DateTime { ... }
my class Date     { ... }

my @UNITS = <second minute hour day week month year> X~ '', 's';

my role Dateish {

    method IO(|c) { IO::Path.new(self) }

    method is-leap-year($y = $.year) {
        $y %% 4 and not $y %% 100 or $y %% 400
    }

    method days-in-month($year = $.year, $month = $.month) {
           $month == 2        ?? self.is-leap-year($year) ?? 29 !! 28
        !! $month == 4|6|9|11 ?? 30
        !! 31
    }

    method daycount-from-ymd(Int() $y is copy, Int() $m is copy, $d) {
        # taken from <http://www.merlyn.demon.co.uk/daycount.htm>
        if $m < 3 {
            $m += 12;
            --$y;
        }
        -678973 + $d + (153 * $m - 2) div 5
            + 365 * $y + $y div 4
            - $y div 100  + $y div 400;
    }

    method ymd-from-daycount($daycount) {
        # taken from <http://www.merlyn.demon.co.uk/daycount.htm>
        my int $day = $daycount.Int + 678881;
        my int $t = (4 * ($day + 36525)) div 146097 - 1;
        my int $year = 100 * $t;
        $day = $day - (36524 * $t + ($t div 4));
        $t = (4 * ($day + 366)) div 1461 - 1;
        $year = $year + $t;
        $day = $day - (365 * $t + ($t div 4));
        my int $month = (5 * $day + 2) div 153;
        $day = $day - ((2 + $month * 153) div 5 - 1);
        if ($month > 9) {
            $month = $month - 12;
            $year = $year + 1;
        }
        ($year, $month + 3, $day)
    }

    method get-daycount {
        self.daycount-from-ymd($.year, $.month, $.day)
    }

    method day-of-month() { $.day }

    method day-of-week($daycount = self.get-daycount) {
        ($daycount + 2) % 7 + 1
    }

    method week() { # algorithm from Claus Tndering
        my $a = $.year - ($.month <= 2).floor.Int;
        my $b = $a div 4 - $a div 100 + $a div 400;
        my $c = ($a - 1) div 4 - ($a - 1) div 100 + ($a - 1) div 400;
        my $s = $b - $c;
        my $e = $.month <= 2 ?? 0 !! $s + 1;
        my $f = $.day + do $.month <= 2
         ?? 31*($.month - 1) - 1
         !! (153*($.month - 3) + 2) div 5 + 58 + $s;

        my $g = ($a + $b) % 7;
        my $d = ($f + $g - $e) % 7;
        my $n = $f + 3 - $d;

           $n < 0           ?? ($.year - 1, 53 - ($g - $s) div 5)
        !! $n > 364 + $s    ?? ($.year + 1, 1)
        !!                     ($.year,     $n div 7 + 1);
    }

    method week-year() {
        self.week.[0]
    }

    method week-number() {
        self.week.[1]
    }

    method weekday-of-month {
        ($.day - 1) div 7 + 1
    }

    method day-of-year() {
        [+] $.day, map { self.days-in-month($.year, $^m) }, 1 ..^ $.month
    }

    method check-value($val is copy, $name, $range, :$allow-nonint) {
        $val = $allow-nonint ?? +$val !! $val.Int;
        $val ~~ $range
            or X::OutOfRange.new(
                        what    => $name,
                        got     => $val,
                        range   => $range,
               ).throw;
    }

    method check-date {
        self.check-value($.month, 'month', 1 .. 12);
        self.check-value($.day, "day of $.year/$.month",
            1 .. self.days-in-month);
    }

    method truncate-parts(Cool:D $unit, %parts? is copy) {
        # Helper for DateTime.truncated-to and Date.truncated-to.
        X::DateTime::InvalidDeltaUnit.new(:$unit).throw
            unless $unit eq any(@UNITS);
        if $unit eq 'week' | 'weeks' {
            my $dc = self.get-daycount;
            my $new-dc = $dc - self.day-of-week($dc) + 1;
            %parts<year month day> =
                self.ymd-from-daycount($new-dc);
        } else { # $unit eq 'month' | 'months' | 'year' | 'years'
            %parts<day> = 1;
            $unit eq 'year' and %parts<month> = 1;
        }
        %parts;
    }

}

sub default-formatter(DateTime $dt, Bool :$subseconds) {
    my $o = $dt.offset;
    $o %% 60
        or warn "Default DateTime formatter: offset $o not divisible by 60.\n";
    sprintf '%04d-%02d-%02dT%02d:%02d:%s%s',
        $dt.year, $dt.month, $dt.day, $dt.hour, $dt.minute,
        $subseconds
          ?? $dt.second.fmt('%09.6f')
          !! $dt.whole-second.fmt('%02d'),
        do $o
         ?? sprintf '%s%02d%02d',
                $o < 0 ?? '-' !! '+',
                ($o.abs / 60 / 60).floor,
                ($o.abs / 60 % 60).floor
         !! 'Z';
}

sub get-local-timezone-offset {
  my $utc = DateTime.new(now).posix.Int;
  my Mu $fia := nqp::p6decodelocaltime(nqp::unbox_i($utc));
  my $second = nqp::p6box_i(nqp::atpos_i($fia, 0));
  my $minute = nqp::p6box_i(nqp::atpos_i($fia, 1));
  my $hour   = nqp::p6box_i(nqp::atpos_i($fia, 2));
  my $day    = nqp::p6box_i(nqp::atpos_i($fia, 3));
  my $month  = nqp::p6box_i(nqp::atpos_i($fia, 4));
  my $year   = nqp::p6box_i(nqp::atpos_i($fia, 5));
  my $local  = DateTime.new(:$year, :$month, :$day, :$hour, :$minute, :$second);
  my $ltime  = $local.posix(True).Int;
  $ltime - $utc;
}

my class DateTime does Dateish {
     has Int $.year;
     has Int $.month = 1;
     has Int $.day = 1;

     has Int $.hour      = 0;
     has Int $.minute    = 0;
     has     $.second    = 0.0;
     has     $.timezone  = 0; # UTC
     has     &.formatter = &default-formatter;
       # Not an optimization but a necessity to ensure that
       # $dt.utc.local.utc is equivalent to $dt.utc. Otherwise,
       # DST-induced ambiguity could ruin our day.

     multi method new() {
        fail "Must provide arguments to DateTime.new()";
    }

    multi method new(Int :$year!, :&formatter=&default-formatter, *%_) {
        my $dt = self.bless(:$year, :&formatter, |%_);
        $dt.check-date;
        $dt.check-time;
        $dt;
    }

    method check-time {
        # Asserts the validity of and numifies $!hour, $!minute, and $!second.
        self.check-value($!hour, 'hour', 0 ..^ 24);
        self.check-value($!minute, 'minute', 0 ..^ 60);
        self.check-value($!second, 'second', 0 ..^ 62, :allow-nonint);
        if $!second >= 60 {
            # Ensure this is an actual leap second.
            self.second < 61
                or X::OutOfRange.new(
                        what  => 'second',
                        range => (0..^60),
                        got   => self.second,
                        comment => 'No second 61 has yet been defined',
                ).throw;
            my $dt = self.utc;
            $dt.hour == 23 && $dt.minute == 59
                or X::OutOfRange.new(
                        what  => 'second',
                        range => (0..^60),
                        got   => self.second,
                        comment => 'a leap second can occur only at hour 23 and minute 59 UTC',
                ).throw;
            my $date = sprintf '%04d-%02d-%02d',
                $dt.year, $dt.month, $dt.day;
            $date eq any(tai-utc::leap-second-dates)
                or X::OutOfRange.new(
                        what  => 'second',
                        range => (0..^60),
                        got   => self.second,
                        comment => "There is no leap second on UTC $date",
                ).throw;
        }
    }

    multi method new(Date:D :$date!, *%_) {
        self.new(year => $date.year, month => $date.month,
            day => $date.day, |%_)
    }

    multi method new(Instant:D $i, :$timezone=0, :&formatter=&default-formatter) {
        my ($p, $leap-second) = $i.to-posix;
        my $dt = self.new: floor($p - $leap-second).Int, :&formatter;
        $dt.clone(second => ($dt.second + $p % 1 + $leap-second)
            ).in-timezone($timezone);
    }

    multi method new(Int:D $time is copy, :$timezone=0, :&formatter=&default-formatter) {
        # Interpret $time as a POSIX time.
        my $second  = $time % 60; $time = $time div 60;
        my $minute  = $time % 60; $time = $time div 60;
        my $hour    = $time % 24; $time = $time div 24;
        # Day month and leap year arithmetic, based on Gregorian day #.
        # 2000-01-01 noon UTC == 2451558.0 Julian == 2451545.0 Gregorian
        $time += 2440588;   # because 2000-01-01 == Unix epoch day 10957
        my $a = $time + 32044;     # date algorithm from Claus Tndering
        my $b = (4 * $a + 3) div 146097; # 146097 = days in 400 years
        my $c = $a - (146097 * $b) div 4;
        my $d = (4 * $c + 3) div 1461;       # 1461 = days in 4 years
        my $e = $c - ($d * 1461) div 4;
        my $m = (5 * $e + 2) div 153; # 153 = days in Mar-Jul Aug-Dec
        my $day   = $e - (153 * $m + 2) div 5 + 1;
        my $month = $m + 3 - 12 * ($m div 10);
        my $year  = $b * 100 + $d - 4800 + $m div 10;
        self.bless(:$year, :$month, :$day,
            :$hour, :$minute, :$second,
            :&formatter).in-timezone($timezone);
    }

    multi method new(Str $format, :$timezone is copy = 0, :&formatter=&default-formatter) {
        $format ~~ /^ (\d**4) '-' (\d\d) '-' (\d\d) T (\d\d) ':' (\d\d) ':' (\d\d) (Z || (<[\-\+]>) (\d\d) (':'? (\d\d))? )? $/
            or X::Temporal::InvalidFormat.new(
                    invalid-str => $format,
                    target      => 'DateTime',
                    format      => 'an ISO 8601 timestamp (yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100)',
                ).throw;
        my $year   = (+$0).Int;
        my $month  = (+$1).Int;
        my $day    = (+$2).Int;
        my $hour   = (+$3).Int;
        my $minute = (+$4).Int;
        my $second = +$5;
        if $6 {
            $timezone
                and X::DateTime::TimezoneClash.new.throw;
            if $6 eq 'Z' {
                $timezone = 0;
            } else {
                $timezone = (($6[1]*60 + ($6[2][0] // 0)) * 60).Int;
                  # RAKUDO: .Int is needed to avoid to avoid the nasty '-0'.
                $6[0] eq '-' and $timezone = -$timezone;
            }
        }
        self.new(:$year, :$month, :$day, :$hour, :$minute,
            :$second, :$timezone, :&formatter);
    }

    method now(:$timezone=$*TZ, :&formatter=&default-formatter) returns DateTime:D {
        self.new(now, :$timezone, :&formatter)
    }

    method clone(*%_) {
        my %args = :$!year, :$!month, :$!day, :$!hour, :$!minute,
                   :$!second, :$!timezone, :&!formatter, %_;
        self.new(|%args);
    }

    method clone-without-validating(*%_) { # A premature optimization.
        my %args = :$!year, :$!month, :$!day, :$!hour, :$!minute,
                   :$!second, :$!timezone, :&!formatter, %_;
        self.bless(|%args);
    }

    method Instant() {
        Instant.from-posix: self.posix + $.second % 1, $.second >= 60;
    }

    method posix($ignore-timezone?) {
        $ignore-timezone or self.offset == 0
            or return self.utc.posix;
        # algorithm from Claus Tndering
        my $a = (14 - $.month.Int) div 12;
        my $y = $.year.Int + 4800 - $a;
        my $m = $.month.Int + 12 * $a - 3;
        my $jd = $.day + (153 * $m + 2) div 5 + 365 * $y
            + $y div 4 - $y div 100 + $y div 400 - 32045;
        ($jd - 2440588) * 24 * 60 * 60
            + 60*(60*$.hour + $.minute) + self.whole-second;
    }

    method offset {
        $!timezone.Int;
    }

    method offset-in-minutes {
        $!timezone.Int / 60;
    }

    method offset-in-hours {
        $!timezone.Int / 60 / 60;
    }

    method later(*%unit) {
        die "More than one time unit supplied"
            if %unit.keys > 1;

        die "No time unit supplied"
            unless %unit.keys;

        my ($unit, $amount) = %unit.kv;

        X::DateTime::InvalidDeltaUnit.new(:$unit).throw
            unless $unit eq any(@UNITS);

        my ($hour, $minute) = $!hour, $!minute;
        my $date;

        given $unit {
            when 'second' | 'seconds' {
                return self.new(self.Instant + $amount);
            }

            when 'minute' | 'minutes' { $minute += $amount; proceed }

            $hour += floor($minute / 60);
            $minute %= 60;

            when 'hour' | 'hours' { $hour += $amount; proceed }

            my $day-delta += floor($hour / 24);
            $hour %= 24;

            when 'day' | 'days' { $day-delta += $amount; proceed }
            when 'week' | 'weeks' { $day-delta += 7 * $amount; proceed }

            when 'month' | 'months' {
                my ($month, $year) = $!month, $!year;
                $month += $amount;
                $year += floor(($month - 1) / 12);
                $month = ($month - 1) % 12 + 1;
                $date = Date.new(:$year, :$month, :$!day);
                succeed;
            }

            when 'year' | 'years' {
                my $year = $!year + $amount;
                $date = Date.new(:$year, :$!month, :$!day);
                succeed;
            }

            my $daycount = Date.new(self).daycount;
            $daycount += $day-delta;
            $date = Date.new-from-daycount($daycount);
        }

        my $second = $!second;
        if $second > 59 && $date ne any(tai-utc::leap-second-dates) {
            $second -= 60;
            $minute++;
            if $minute > 59 {
                $minute -= 60;
                $hour++;
                if $hour > 23 {
                    $hour -= 24;
                    $date++;
                }
            }
        }
        self.new(:$date, :$hour, :$minute, :$second);
    }

    method earlier(*%unit) {
        self.later(| -<< %unit);
    }

    method truncated-to(Cool $unit) {
        my %parts;
        given $unit {
            %parts<second> = self.whole-second;
            when 'second'   {}
            %parts<second> = 0;
            when 'minute'   {}
            %parts<minute> = 0;
            when 'hour'     {}
            %parts<hour> = 0;
            when 'day'      {}
            # Fall through to Dateish.
            %parts = self.truncate-parts($unit, %parts);
        }
        self.clone-without-validating(|%parts);
    }

    method whole-second() {
        floor($.second).Int
    }

    method in-timezone($timezone) {
        $timezone eqv $!timezone and return self;
        my $old-offset = self.offset;
        my $new-offset = $timezone.Int;
        my %parts;
        # Is the logic for handling leap seconds right?
        # I don't know, but it passes the tests!
        my $a = ($!second >= 60 ?? 59 !! $!second)
            + $new-offset - $old-offset;
        %parts<second> = $!second >= 60 ?? $!second !! ($a % 60).Int;
        my $b = $!minute + floor $a / 60;
        %parts<minute> = ($b % 60).Int;
        my $c = $!hour + floor $b / 60;
        %parts<hour> = ($c % 24).Int;
        # Let Dateish handle any further rollover.
        floor $c / 24 and %parts<year month day> =
           self.ymd-from-daycount\
               (self.get-daycount + floor $c / 24);
        self.clone-without-validating:
            :$timezone, |%parts;
    }

    method utc() {
        self.in-timezone(0)
    }
    method local() {
        self.in-timezone($*TZ)
    }

    method Date() {
        Date.new(:$.year, :$.month, :$.day);
    }

    method Str() {
        &!formatter(self)
    }

    multi method perl(DateTime:D:) {
        sprintf '%s.new(%s)', self.^name, join ', ', map { "{.key} => {.value}" }, do
            :$.year, :$.month, :$.day, :$.hour, :$.minute,
            second => $.second.perl,
            (timezone => $.timezone.perl
                unless $.timezone === 0),
            (formatter => $.formatter.perl
                unless &.formatter eqv &default-formatter)
    }

    multi method gist(DateTime:D:) {
            self.Str;
    }
}

my class Date does Dateish {
    has Int $.year;
    has Int $.month = 1;
    has Int $.day = 1;

    has Int $.daycount;

    method !set-daycount($dc) { $!daycount = $dc }

    method get-daycount { $!daycount }

    multi method new(:$year!, :$month = 1, :$day = 1) {
        my $d = self.bless(:$year, :$month, :$day);
        $d.check-date;
        $d!set-daycount(self.daycount-from-ymd($year,$month,$day));
        $d;
    }

    multi method new($year, $month, $day) {
        self.new(:$year, :$month, :$day);
    }

    multi method new(Str $date) {
        $date ~~ /^ \d\d\d\d '-' \d\d '-' \d\d $/
            or X::Temporal::InvalidFormat.new(
                    invalid-str => $date,
                    format      => 'yyyy-mm-dd',
            ).throw;
        self.new(|$date.split('-').map({.Int}));
    }

    multi method new() {
        my $n = self.today;
        if $n.month == 12 && $n.day >= 24 {
            self.new($n.year + 1, 12, 24);
        } else {
            self.new($n.year, 12, 24);
        }
    }

    multi method new(Dateish $d) {
        self.bless(
            :year($d.year), :month($d.month), :day($d.day),
            :daycount(self.daycount-from-ymd($d.year,$d.month,$d.day))
        );
    }

    multi method new(Instant $i) {
        my $dt = DateTime.new($i);
        self.new($dt);
    }

    multi method WHICH(Date:D:) {
        nqp::box_s(
            nqp::concat(
                nqp::concat(nqp::unbox_s(self.^name), '|'),
                nqp::unbox_i($!daycount)
            ),
            ObjAt
        );
    }

    method new-from-daycount($daycount) {
        my ($year, $month, $day) = self.ymd-from-daycount($daycount);
        self.bless(:$daycount, :$year, :$month, :$day);
    }

    method today() {
        self.new(DateTime.now);
    }

    method truncated-to(Cool $unit) {
        self.clone(|self.truncate-parts($unit));
    }

    method later(*%unit) {
        die "More than one time unit supplied"
            if %unit.keys > 1;

        my ($unit, $amount) = %unit.kv;

        X::DateTime::InvalidDeltaUnit.new(:$unit).throw
            unless $unit eq any(@UNITS);

        my $date;

        given $unit {
            X::DateTime::InvalidDeltaUnit.new(:$unit).throw
                when 'second' | 'seconds' | 'minute' | 'minutes' | 'hour' | 'hours';

            my $day-delta;
            when 'day' | 'days' { $day-delta = $amount; proceed }
            when 'week' | 'weeks' { $day-delta = 7 * $amount; proceed }

            when 'month' | 'months' {
                my ($month, $year) = $!month, $!year;
                $month += $amount;
                $year += floor(($month - 1) / 12);
                $month = ($month - 1) % 12 + 1;
                $date = self.new(:$year, :$month, :$!day);
                succeed;
            }

            when 'year' | 'years' {
                my $year = $!year + $amount;
                $date = self.new(:$year, :$!month, :$!day);
                succeed;
            }

            $date = self.new-from-daycount(self.daycount + $day-delta);
        }

        $date;
    }

    method earlier(*%unit) {
        self.later(| -<< %unit);
    }

    method clone(*%_) {
        my %args = :$!year, :$!month, :$!day, %_;
        self.new(|%args);
    }

    method succ() {
        self.new-from-daycount($!daycount + 1);
    }
    method pred() {
        self.new-from-daycount($!daycount - 1);
    }

    multi method gist(Date:D:) {
        sprintf '%04d-%02d-%02d', $.year, $.month, $.day;
    }

    multi method Str(Date:D:) {
        sprintf '%04d-%02d-%02d', $.year, $.month, $.day;
    }

    multi method perl(Date:D:) {
        self.^name ~ ".new($.year.perl(), $.month.perl(), $.day.perl())";
    }

    multi method ACCEPTS(Date:D: DateTime:D $dt) {
        return $dt.year == $.year && $dt.month == $.month && $dt.day == $.day;
    }
}

multi sub infix:<+>(Date:D $d, Int:D $x) {
    Date.new-from-daycount($d.daycount + $x)
}
multi sub infix:<+>(Int:D $x, Date:D $d) {
    Date.new-from-daycount($d.daycount + $x)
}
multi sub infix:<->(Date:D $d, Int:D $x) {
    Date.new-from-daycount($d.daycount - $x)
}
multi sub infix:<->(Date:D $a, Date:D $b) {
    $a.daycount - $b.daycount;
}
multi sub infix:<cmp>(Date:D $a, Date:D $b) {
    $a.daycount cmp $b.daycount
}
multi sub infix:<=>(Date:D $a, Date:D $b) {
    $a.daycount <=> $b.daycount
}
multi sub infix:<==>(Date:D $a, Date:D $b) {
    $a.daycount == $b.daycount
}
multi sub infix:<=(Date:D $a, Date:D $b) {
    $a.daycount <= $b.daycount
}
multi sub infix:<(Date:D $a, Date:D $b) {
    $a.daycount < $b.daycount
}
multi sub infix:>=(Date:D $a, Date:D $b) {
    $a.daycount >= $b.daycount
}
multi sub infix:>(Date:D $a, Date:D $b) {
    $a.daycount > $b.daycount
}

multi sub INITIALIZE_DYNAMIC('$*TZ') {
    PROCESS::<$TZ> = get-local-timezone-offset();
}

sub sleep($seconds = Inf --> Nil) {
    if $seconds == Inf || nqp::istype($seconds,Whatever) {
        nqp::sleep(1e16) while True;
    }
    elsif $seconds > 0 {
        nqp::sleep($seconds.Num);
    }
    Nil;
}

sub sleep-timer (Real $seconds = Inf --> Duration) {
    if $seconds <= 0 {
        Duration.new(0);
    }
    else {
        my $time1 = now;
        nqp::sleep($seconds.Num);
        Duration.new( ( $seconds - (now - $time1) ) max 0 );
    }
}

sub sleep-till (Instant $till --> Bool) {
    my $seconds = $till - now;
    return False if $seconds < 0;

    1 while $seconds = sleep-timer($seconds);
    True;
}

# =begin pod
#
# =head1 SEE ALSO
#
#
# <ISO 8601|http://en.wikipedia.org/wiki/ISO_8601>
# <Time zones|http://en.wikipedia.org/wiki/List_of_time_zones>
#
#
# =end pod

# From 'src/core/EXPORTHOW.pm'

my module EXPORTHOW {
    nqp::bindkey($?PACKAGE.WHO, 'package', Perl6::Metamodel::PackageHOW);
    nqp::bindkey($?PACKAGE.WHO, 'module', Perl6::Metamodel::ModuleHOW);
    nqp::bindkey($?PACKAGE.WHO, 'generic', Perl6::Metamodel::GenericHOW);
    nqp::bindkey($?PACKAGE.WHO, 'class', Perl6::Metamodel::ClassHOW);
    nqp::bindkey($?PACKAGE.WHO, 'class-attr', Attribute);
    nqp::bindkey($?PACKAGE.WHO, 'role', Perl6::Metamodel::ParametricRoleHOW);
    nqp::bindkey($?PACKAGE.WHO, 'role-attr', Attribute);
    nqp::bindkey($?PACKAGE.WHO, 'role-group', Perl6::Metamodel::ParametricRoleGroupHOW);
    nqp::bindkey($?PACKAGE.WHO, 'grammar', Perl6::Metamodel::GrammarHOW);
    nqp::bindkey($?PACKAGE.WHO, 'grammar-attr', Attribute);
    nqp::bindkey($?PACKAGE.WHO, 'native', Perl6::Metamodel::NativeHOW);
    nqp::bindkey($?PACKAGE.WHO, 'subset', Perl6::Metamodel::SubsetHOW);
    nqp::bindkey($?PACKAGE.WHO, 'enum', Perl6::Metamodel::EnumHOW);
    nqp::bindkey($?PACKAGE.WHO, 'coercion', Perl6::Metamodel::CoercionHOW);
}

# From 'src/core/Pod.pm'

my class Pod::Block {
    has %.config;
    has @.contents;

    submethod BUILD(:$content = Any, :%!config, :@!contents) {
        if $content.defined {
            DEPRECATED("Pod::Block.new(:contents)", |<2014.09 2015.09>, :up(5), :what('Pod::Block.new(:content)'));
            @!contents.push: $content.list;
        }
    }

    sub pod-gist(Pod::Block $pod, $level = 0) {
        my $leading = ' ' x $level;
        my %confs;
        my @chunks;
        for <config name level caption type> {
            my $thing = $pod.?"$_"();
            if $thing {
                %confs{$_} = nqp::istype($thing,Iterable)
                  ?? $thing.perl
                  !! $thing.Str;
            }
        }
        @chunks = $leading, $pod.^name, (%confs.perl if %confs), "\n";
        for $pod.contents.list -> $c {
            if nqp::istype($c,Pod::Block) {
                @chunks.push: pod-gist($c, $level + 2);
            }
            elsif nqp::istype($c,Positional) {
                @chunks.push: $c>>.Str.perl.indent($level + 2), "\n";
            }
            else {
                @chunks.push: $c.Str.indent($level + 2), "\n";
            }
        }
        @chunks.join;
    }

    multi method gist(Pod::Block:D:) {
        pod-gist(self)
    }

    method content { # is DEPRECATED doesn't work in settings
        DEPRECATED("Pod::Block.contents", |<2014.09 2015.09>);
        @.contents
    }
}

my class Pod::Block::Para is Pod::Block {
}

my class Pod::Block::Named is Pod::Block {
    has $.name;
}

my class Pod::Block::Comment is Pod::Block { }

my class Pod::Block::Code is Pod::Block {
    has @.allowed;
}

my class Pod::Block::Declarator is Pod::Block {
    has $.WHEREFORE;
    has @!leading;
    has @!trailing;

    submethod BUILD(:@!leading, :@!trailing) {}

    method set_docee($d) {
        $!WHEREFORE = $d
    }
    method Str {
        @.contents.join('')
    }
    multi method gist(Pod::Block::Declarator:D:) {
        @.contents.join('')
    }

    method contents {
        if @!leading && @!trailing {
            [ $.leading ~ "\n" ~ $.trailing ]
        } elsif @!leading {
            [ $.leading ]
        } elsif @!trailing {
            [ $.trailing ]
        } else {
            []
        }
    }

    method leading  { @!leading  ?? @!leading.join(' ')  !! Any }
    method trailing { @!trailing ?? @!trailing.join(' ') !! Any }

    method _add_leading($addition) {
        @!leading.push: ~$addition;
    }

    method _add_trailing($addition) {
        @!trailing.push: ~$addition;
    }
}

my class Pod::Block::Table is Pod::Block {
    has $.caption;
    has @.headers; # optional, may be empty
}

my class Pod::FormattingCode is Pod::Block {
    has $.type;
    has @.meta;
}

my class Pod::Heading is Pod::Block {
    has $.level;
}

my class Pod::Item is Pod::Block {
    has $.level;
}

class Pod::Config {
    has $.type;
    has %.config;
}

class Pod::Raw {
    has $.target;
    has @.contents;

    method content { # is DEPRECATED doesn't work in settings
        DEPRECATED("Pod::Raw.contents", |<2014.09 2015.09>);
        @.contents
    }
}

# From 'src/core/PairMap.pm'

my class PairMap is Hash {

    method BUILD(@pairs) {
        my Mu $storage    := nqp::hash();
        my Mu $descriptor := nqp::getattr(self,Hash,'$!descriptor');
        for @pairs -> $pair {
            nqp::bindkey($storage,nqp::unbox_s($pair.key.Str),
              nqp::p6scalarfromdesc($descriptor) = $pair.value)
        }

        nqp::bindattr(self, EnumMap, '$!storage', $storage);
        self;
    }

    multi method new(PairMap:U: *@params) {
        nqp::create(self).BUILD(@params.pairup);
    }

    multi method AT-KEY(PairMap:D: \key) is rw {
        self.EXISTS-KEY(key)
          ?? nextsame()
          !! fail X::PairMap::DoesNotExist.new(:key(key), :method<AT-KEY>);
    }
    multi method BIND-KEY(PairMap:D: \key) is rw {
        self.EXISTS-KEY(key)
          ?? nextsame()
          !! X::PairMap::DoesNotExist.new(:key(key), :method<BIND-KEY>).throw;
    }
    multi method ASSIGN-KEY(PairMap:D: \key, Mu \assignval) {
        self.EXISTS-KEY(key)
          ?? nextsame()
          !! X::PairMap::DoesNotExist.new(:key(key), :method<ASSIGN-KEY>).throw;
    }
    multi method DELETE-KEY(PairMap:D: \key) {
        fail X::PairMap::NotAllowed.new(:method<DELETE-KEY>);
    }
    multi method push(PairMap:D: *@values) {
        for @values.pairup -> $pair {
            my $key   := $pair.key;
            my $value := self.AT-KEY($key);
            nqp::istype($value,Array)
              ?? $value.push($pair.value)
              !! self.ASSIGN-KEY($key, [ $value, $pair.value ]);
        }
    }

    multi method perl(PairMap:D:) {
        self.^name
          ~ '.new('
          ~ self.pairs.map({.perl}).join(', ')
          ~ ')';
    }
}

# From 'src/core/QuantHash.pm'

my role QuantHash does Associative {
    method Int     ( --> Int)     { self.total.Int }
    method Num     ( --> Num)     { self.total.Num }
    method Numeric ( --> Numeric) { self.total.Numeric }
    method Real    ( --> Real)    { self.total.Real }

    method minpairs ( --> List ) {
        my @found;
        my $min = Inf;
        for self.pairs {
            my $value := .value;
            if $value > $min {
                next;
            }
            elsif $value < $min {
                @found = $_;
                $min = $value;
            }
            else {
                @found.push: $_;
            }
        }
        @found;
    }

    method maxpairs ( --> List ) {
        my @found;
        my $max = -Inf;
        for self.pairs {
            my $value := .value;
            if $value < $max {
                next;
            }
            elsif $value > $max {
                @found = $_;
                $max = $value;
            }
            else {
                @found.push: $_;
            }
        }
        @found;
    }

    method fmt(QuantHash: Cool $format = "%s\t\%s", $sep = "\n") {
        if nqp::p6box_i(nqp::sprintfdirectives( nqp::unbox_s($format.Stringy) )) == 1 {
            self.keys.fmt($format, $sep);
        }
        else {
            self.pairs.fmt($format, $sep);
        }
    }
}

# From 'src/core/Setty.pm'

my role Setty does QuantHash {
    has %!elems; # key.WHICH => key

    method BUILD (:%!elems)  { self }
    method default(--> Bool) { False }

    multi method keys(Setty:D:)   { %!elems.values }
    multi method kv(Setty:D:)     { %!elems.values X, True }
    multi method values(Setty:D:) { True xx %!elems.elems }

    method elems(--> Int) { %!elems.elems }
    method total(--> Int) { %!elems.elems }
    method minpairs(--> List) { self.pairs }
    method maxpairs(--> List) { self.pairs }
    multi method Bool(Setty:D:) { %!elems.Bool }

    multi method hash(Setty:D: --> Hash) {
        my %e;
        %e{$_} = True for %!elems.values;
        %e;
    }

    method new(*@args --> Setty) {
        my %e;
        %e{$_.WHICH} = $_ for @args;
        nqp::create(self).BUILD(:elems(%e));
    }
    method new-from-pairs(*@pairs --> Setty) {
        my %e;
        for @pairs {
            when Pair {
                %e{.key.WHICH} //= $_.key if .value;
            }
            default {
                %e{.WHICH} //= $_;
            }
        }
        self.bless(:elems(%e));
    }

    method ACCEPTS($other) {
        self.defined
          ?? $other (<=) self && self (<=) $other
          !! $other.^does(self);
    }

    multi method Str(Setty:D $ : --> Str) { ~ %!elems.values }
    multi method gist(Setty:D $ : --> Str) {
        my $name := self.^name;
        ( $name eq 'Set' ?? 'set' !! "$name.new" )
        ~ '('
        ~ %!elems.values.map( {.gist} ).join(', ')
        ~ ')';
    }
    multi method perl(Setty:D $ : --> Str) {
        my $name := self.^name;
        ( $name eq 'Set' ?? 'set' !! "$name.new" )
        ~ '('
        ~ %!elems.values.map( {.perl} ).join(',')
        ~ ')';
    }

    method list() { %!elems.values }
    multi method pairs(Setty:D:)    { %!elems.values.map: { $_ => True } }
    multi method antipairs(Setty:D:) { %!elems.values.map: { True => $_ } }
    method grab($count = 1) {
        (%!elems{ %!elems.keys.pick($count) }:delete).list;
    }
    method grabpairs($count = 1) {
        (%!elems{ %!elems.keys.pick($count) }:delete).map( { ($_=>True) } );
    }

    proto method pick(|) { * }
    multi method pick()       { %!elems.values.pick()       }
    multi method pick($count) { %!elems.values.pick($count) }

    proto method roll(|) { * }
    multi method roll()       { %!elems.values.roll()       }
    multi method roll($count) { %!elems.values.roll($count) }

    multi method EXISTS-KEY(Setty:D: \k --> Bool) {
        nqp::p6bool(
          %!elems.elems && nqp::existskey(%!elems, nqp::unbox_s(k.WHICH))
        );
    }

    # TODO: WHICH will require the capability for >1 pointer in ObjAt
}

# From 'src/core/Set.pm'

my class Set does Setty {
    has Int $!total;
    has $!WHICH;

    method total (--> Int) { $!total //= %!elems.elems }
    multi method WHICH (Set:D:) {
        $!WHICH := self.^name ~ '|' ~ %!elems.keys.sort if !$!WHICH.defined;
        $!WHICH
    }
    submethod BUILD (:%elems) {
        nqp::bindattr(self, Set, '%!elems', %elems);
        self;
    }

    method grab ($count?) {
        X::Immutable.new( method => 'grab', typename => self.^name ).throw;
    }
    method grabpairs ($count?) {
        X::Immutable.new( method => 'grabpairs', typename => self.^name ).throw;
    }

    multi method pairs(Set:D:) {    # must copy else we can change the Set
        %!elems.values.map: { Enum.new(:key($_),:value(True)) };
    }
    multi method antipairs(Set:D:) { # must copy else we can change the Set
        %!elems.values.map: { Enum.new(:key(True),:value($_)) };
    }

    method Set { self }
    method SetHash { SetHash.new(self.keys) }

    multi method AT-KEY(Set:D: \k --> Bool) {
        %!elems.EXISTS-KEY(k.WHICH);
    }
    multi method ASSIGN-KEY(Set:D: \k,\v) is hidden-from-backtrace {
        fail X::Assignment::RO.new(typename => self.^name);
    }
    multi method DELETE-KEY(Set:D: \k) is hidden-from-backtrace {
        fail X::Immutable.new(method => 'DELETE-KEY', typename => self.^name);
    }
}

# From 'src/core/SetHash.pm'

my class SetHash does Setty {

    method Set (:$view) {
        if $view {
            my $set := nqp::create(Set);
            $set.BUILD( :elems(%!elems) );
            $set;
        }
        else {
            Set.new(self.keys);
        }
    }
    method SetHash { self }

    multi method AT-KEY(SetHash:D: \k --> Bool) {
        Proxy.new(
          FETCH => {
              %!elems.EXISTS-KEY(k.WHICH);
          },
          STORE => -> $, $value {
              $value
                ?? %!elems.ASSIGN-KEY(k.WHICH,k)
                !! %!elems.DELETE-KEY(k.WHICH);
              so $value;
          });
    }
    multi method DELETE-KEY(SetHash:D: \k --> Bool) {
        my $key := k.WHICH;
        return False unless %!elems.EXISTS-KEY($key);

        %!elems.DELETE-KEY($key);
        True;
    }
}

# From 'src/core/Baggy.pm'

my role Baggy does QuantHash {
    has %!elems; # key.WHICH => (key,value)

    method BUILD (:%!elems) { self }
    method default(--> Int) { 0 }

    multi method keys(Baggy:D:)     { %!elems.values.map( {.key} ) }
    multi method kv(Baggy:D:)       { %!elems.values.map( {.key, .value} ) }
    multi method values(Baggy:D:)   { %!elems.values.map( {.value} ) }
    multi method pairs(Baggy:D:)    { %!elems.values.map: { (.key => .value) } }
    multi method antipairs(Baggy:D:) { %!elems.values.map: { (.value => .key) } }
    multi method invert(Baggy:D:)   { %!elems.values.map: { (.value => .key) } } # NB value can't be listy

    method kxxv { %!elems.values.map( {.key xx .value} ) }
    method elems(--> Int) { %!elems.elems }
    method total(--> Int) { [+] self.values }
    method Bool { %!elems.Bool }

    method hash(--> Hash) { %!elems.values.hash }

    method new(*@args --> Baggy) {
        my %e;
        # need explicit signature because of #119609
        -> $_ { (%e{$_.WHICH} //= ($_ => 0)).value++ } for @args;
        nqp::create(self).BUILD(:elems(%e));
    }
    method new-from-pairs(*@pairs) {
        my %e;
        for @pairs {
            when Pair {
                (%e.AT-KEY($_.key.WHICH) //= ($_.key => 0)).value += $_.value.Int;
            }
            default {
                (%e.AT-KEY($_.WHICH) //= ($_ => 0)).value++;
            }
        }
        my @toolow;
        for %e -> $p {
            my $pair := $p.value;
            @toolow.push( $pair.key ) if $pair.value <  0;
            %e.DELETE-KEY($p.key)     if $pair.value <= 0;
        }
        fail "Found negative values for {@toolow} in {self.^name}" if @toolow;
        self.bless(:elems(%e));
    }

    method ACCEPTS($other) {
        self.defined
          ?? $other (<+) self && self (<+) $other
          !! $other.^does(self);
    }

    multi method Str(Baggy:D $ : --> Str) {
        ~ %!elems.values.map( {
              .value == 1 ?? .key.gist !! "{.key.gist}({.value})"
          } );
    }
    multi method gist(Baggy:D $ : --> Str) {
        my $name := self.^name;
        ( $name eq 'Bag' ?? 'bag' !! "$name.new" )
        ~ '('
        ~ %!elems.values.map( {
              .value == 1 ?? .key.gist !! "{.key.gist}({.value})"
          } ).join(', ')
        ~ ')';
    }
    multi method perl(Baggy:D $ : --> Str) {
        '('
        ~ %!elems.values.map( {"{.key.perl}=>{.value}"} ).join(',')
        ~ ").{self.^name}"
    }

    method list() { self.pairs }

    proto method grabpairs (|) { * }
    multi method grabpairs(Baggy:D:) {
        %!elems.DELETE-KEY(%!elems.keys.pick);
    }
    multi method grabpairs(Baggy:D: $count) {
        if nqp::istype($count,Whatever) || $count == Inf {
            my @grabbed = %!elems{%!elems.keys.pick(%!elems.elems)};
            %!elems = ();
            @grabbed;
        }
        else {
            %!elems{ %!elems.keys.pick($count) }:delete;
        }
    }

    proto method pickpairs(|) { * }
    multi method pickpairs(Baggy:D:) {
        %!elems.AT-KEY(%!elems.keys.pick);
    }
    multi method pickpairs(Baggy:D: $count) {
        %!elems{ %!elems.keys.pick(
          nqp::istype($count,Whatever) || $count == Inf
            ?? %!elems.elems
            !! $count
        ) };
    }

    proto method grab(|) { * }
    multi method grab(Baggy:D:) {
        my \grabbed := ROLLPICKGRAB1(self,%!elems.values);
        %!elems.DELETE-KEY(grabbed.WHICH)
          if %!elems.AT-KEY(grabbed.WHICH).value-- == 1;
        grabbed;
    }
    multi method grab(Baggy:D: $count) {
        if nqp::istype($count,Whatever) || $count == Inf {
            my @grabbed = ROLLPICKGRABN(self,self.total,%!elems.values);
            %!elems = ();
            @grabbed;
        }
        else {
            my @grabbed = ROLLPICKGRABN(self,$count,%!elems.values);
            for @grabbed {
                if %!elems.AT-KEY(.WHICH) -> $pair {
                    %!elems.DELETE-KEY(.WHICH) unless $pair.value;
                }
            }
            @grabbed;
        }
    }

    proto method pick(|) { * }
    multi method pick(Baggy:D:) {
        ROLLPICKGRAB1(self,%!elems.values);
    }
    multi method pick(Baggy:D: $count) {
        ROLLPICKGRABN(self,
          nqp::istype($count,Whatever) || $count == Inf ?? self.total !! $count,
          %!elems.values.map: { (.key => .value) }
        );
    }

    proto method roll(|) { * }
    multi method roll(Baggy:D:) {
        ROLLPICKGRAB1(self,%!elems.values);
    }
    multi method roll(Baggy:D: $count) {
        nqp::istype($count,Whatever) || $count == Inf
          ?? ROLLPICKGRABW(self,%!elems.values)
          !! ROLLPICKGRABN(self,$count, %!elems.values, :keep);
    }

    sub ROLLPICKGRAB1($self,@pairs) is hidden-from-backtrace { # one time
        my Int $rand = $self.total.rand.Int;
        my Int $seen = 0;
        for @pairs -> $pair {
            return $pair.key if ( $seen += $pair.value ) > $rand;
        }
        Nil;
    }

    sub ROLLPICKGRABN(                                        # N times
      $self, $count, @pairs is rw, :$keep
    ) is hidden-from-backtrace {
        my Int $total = $self.total;
        my Int $rand;
        my Int $seen;
        my int $todo = ($keep ?? $count !! ($total min $count)) + 1;

        map {
            my $selected is default(Nil);
            $rand = $total.rand.Int;
            $seen = 0;
            for @pairs -> $pair {
                next if ( $seen += $pair.value ) <= $rand;

                $selected = $pair.key;
                last if $keep;

                $pair.value--;
                $total = $total - 1;
                last;
            }
            $selected;
        }, 2..$todo;
    }

    sub ROLLPICKGRABW($self,@pairs) is hidden-from-backtrace { # keep going
        my Int $total = $self.total;
        my Int $rand;
        my Int $seen;

        map {
            my $selected is default(Nil);
            $rand = $total.rand.Int;
            $seen = 0;
            for @pairs -> $pair {
                next if ( $seen += $pair.value ) <= $rand;
                $selected = $pair.key;
                last;
            }
            $selected;
        }, *;
    }

    proto method classify-list(|) { * }
    multi method classify-list( &test, *@list ) {
        fail X::Cannot::Infinite.new(:action<.classify>) if @list.infinite;
        if @list {

            # multi-level classify
            if nqp::istype(test(@list[0]),List) {
                for @list -> $l {
                    my @keys  = test($l);
                    my $last := @keys.pop;
                    my $bag   = self;
                    $bag = $bag{$_} //= self.new for @keys;
                    $bag{$last}++;
                }
            }

            # just a simple classify
            else {
                self{test $_}++ for @list;
            }
        }
        self;
    }
    multi method classify-list( %test, *@list ) {
        samewith( { %test{$^a} }, @list );
    }
    multi method classify-list( @test, *@list ) {
        samewith( { @test[$^a] }, @list );
    }

    proto method categorize-list(|) { * }
    multi method categorize-list( &test, *@list ) {
        fail X::Cannot::Infinite.new(:action<.categorize>) if @list.infinite;
        if @list {

            # multi-level categorize
            if nqp::istype(test(@list[0])[0],List) {
                for @list -> $l {
                    for test($l) -> $k {
                        my @keys  = @($k);
                        my $last := @keys.pop;
                        my $bag   = self;
                        $bag = $bag{$_} //= self.new for @keys;
                        $bag{$last}++;
                    }
                }
            }

            # just a simple categorize
            else {
                for @list -> $l {
                    self{$_}++ for test($l);
                }
            }
        }
        self;
    }
    multi method categorize-list( %test, *@list ) {
        samewith( { %test{$^a} }, @list );
    }
    multi method categorize-list( @test, *@list ) {
        samewith( { @test[$^a] }, @list );
    }

    method Set()     {     Set.new(self.keys) }
    method SetHash() { SetHash.new(self.keys) }

    # all read/write candidates, to be shared with Mixes
    multi method DELETE-KEY(Baggy:D: \k) {
        my \v := %!elems.DELETE-KEY(k.WHICH);
        nqp::istype(v,Pair) ?? v.value !! 0;
    }
    multi method EXISTS-KEY(Baggy:D: \k)    { %!elems.EXISTS-KEY(k.WHICH) }
}

# From 'src/core/Bag.pm'

my class Bag does Baggy {
    has Int $!total;
    has $!WHICH;

    method total (--> Int) { $!total //= [+] self.values }

    multi method WHICH (Bag:D:) {
        $!WHICH //= self.^name
          ~ '|'
          ~ %!elems.keys.sort.map( { $_ ~ '(' ~ %!elems{$_}.value ~ ')' } );
    }

    multi method pairs(Bag:D:) {    # must copy, else we would change the Bag
        %!elems.values.map: { Enum.new(:key(.key),:value(.value)) };
    }
    multi method antipairs(Bag:D:) { # must copy, else we would change the Bag
        %!elems.values.map: { Enum.new(:key(.value),:value(.key)) };
    }
    multi method grab(Bag:D: $count?) is hidden-from-backtrace {
        X::Immutable.new( method => 'grab', typename => self.^name ).throw;
    }
    multi method grabpairs(Bag:D: $count?) is hidden-from-backtrace {
        X::Immutable.new( method => 'grabpairs', typename => self.^name ).throw;
    }

    method Bag     { self }
    method BagHash { BagHash.new-from-pairs(%!elems.values) }
    method Mix     {     Mix.new-from-pairs(%!elems.values) }
    method MixHash { MixHash.new-from-pairs(%!elems.values) }

    multi method AT-KEY(Bag:D: \k) {
        my \v := %!elems.AT-KEY(k.WHICH);
        nqp::istype(v,Pair) ?? v.value !! 0;
    }
    multi method ASSIGN-KEY(Bag:D: \k,\v) is hidden-from-backtrace {
        fail X::Assignment::RO.new(typename => self.^name);
    }
    multi method DELETE-KEY(Bag:D: \k) is hidden-from-backtrace {
        fail X::Immutable.new(method => 'DELETE-KEY', typename => self.^name);
    }
}

# From 'src/core/BagHash.pm'

my class BagHash does Baggy {

    method Bag (:$view) {
        if $view {
            my $bag := nqp::create(Bag);
            $bag.BUILD( :elems(%!elems) );
            $bag;
        }
        else {
            Bag.new-from-pairs(%!elems.values);
        }
    }
    method BagHash { self }
    method Mix     { Mix.new-from-pairs(%!elems.values) }
    method MixHash { MixHash.new-from-pairs(%!elems.values) }

    multi method AT-KEY(BagHash:D: \k) {
        Proxy.new(
          FETCH => {
              my \v := %!elems.AT-KEY(k.WHICH);
              nqp::istype(v,Pair) ?? v.value !! 0;
          },
          STORE => -> $, $value is copy {
              if $value > 0 {
                  (%!elems.AT-KEY(k.WHICH) //= ((k) => 0)).value = $value;
              }
              elsif $value == 0 {
                  %!elems.DELETE-KEY(k.WHICH);
              }
              else {
                  $value = 0;
              }
              $value;
          }
        );
    }
}

# From 'src/core/Mixy.pm'

my role Mixy does Baggy  {
    method default(--> Real) { 0 }
    method total(--> Real) { [+] self.values }

    method new-from-pairs(*@pairs --> Mixy) {
        my %e;
        for @pairs {
            when Pair {
                (%e.AT-KEY($_.key.WHICH) //= ($_.key => 0)).value += $_.value;
            }
            default {
                (%e.AT-KEY($_.WHICH) //= ($_ => 0)).value++;
            }
        }
        for %e -> $p {
            %e.DELETE-KEY($p.key) if $p.value.value == 0;
        }
        nqp::create(self).BUILD(:elems(%e));
    }

    multi method gist(Mixy:D $ : --> Str) {
        my $name := self.^name;
        ( $name eq 'Mix' ?? 'mix' !! "$name.new" )
        ~ '('
#        ~ %!elems.values.map( {
        ~ self.pairs.map( {
              .value == 1 ?? .key.gist !! "{.key.gist}({.value})"
          } ).join(', ')
        ~ ')';
    }

    multi method grab(Mixy:D: $count?) {
        fail ".grab is not supported on a {self.^name}";
    }

    multi method pick(Mixy:D: $count?) {
        fail ".pick is not supported on a {self.^name}";
    }

    multi method roll($count = 1) {
        my @pairs := self.pairs.grep: *.value > 0;
        my $total := [+] @pairs.map: *.value;
        my $rolls = nqp::istype($count,Num)
          ?? $total min $count !! nqp::istype($count,Whatever) ?? Inf !! $count;

        sub roll-one ($ignore?){
            my $rand = $total.rand;
            my $seen = 0;
            for @pairs -> $pair {
                return $pair.key if ( $seen += $pair.value ) > $rand;
            }
        }
        return roll-one if $rolls == 1;

        map &roll-one, 1 .. $rolls;
    }
}

# From 'src/core/Mix.pm'

my class Mix does Mixy {
    has Real $!total;
    has $!WHICH;

    multi method WHICH (Mix:D:) {
        $!WHICH //= self.^name
          ~ '|'
          ~ %!elems.keys.sort.map( { $_ ~ '(' ~ %!elems{$_}.value ~ ')' } );
    }
    multi method pairs(Mix:D:) {    # copy values else we can change the Mix
        %!elems.values.map: { Enum.new(:key(.key),:value(.value)) };
    }
    multi method antipairs(Mix:D:) { # copy values else we can change the Mix
        %!elems.values.map: { Enum.new(:key(.value),:value(.key)) };
    }

    method total (--> Real) { $!total //= [+] self.values }

    multi method grab($count? --> Real) is hidden-from-backtrace {
        X::Immutable.new( method => 'grab', typename => self.^name ).throw;
    }
    multi method grabpairs($count? --> Real) is hidden-from-backtrace {
        X::Immutable.new( method => 'grabpairs', typename => self.^name ).throw;
    }

    method Mix { self }
    method MixHash { MixHash.new-from-pairs(%!elems.values) }
    method Bag     {     Bag.new-from-pairs(%!elems.values) }
    method BagHash { BagHash.new-from-pairs(%!elems.values) }

    # identical to Bag.pm
    multi method AT-KEY(Mix:D: \k) {
        my \v := %!elems.AT-KEY(k.WHICH);
        nqp::istype(v,Pair) ?? v.value !! 0;
    }
    multi method ASSIGN-KEY(Mix:D: \k,\v) is hidden-from-backtrace {
        fail X::Assignment::RO.new(typename => self.^name);
    }
    multi method DELETE-KEY(Mix:D: \k) is hidden-from-backtrace {
        fail X::Immutable.new(method => 'DELETE-KEY', typename => self.^name);
    }
}

# From 'src/core/MixHash.pm'

my class MixHash does Mixy {

    method Mix (:$view) {
        if $view {
            my $mix := nqp::create(Mix);
            $mix.BUILD( :elems(%!elems) );
            $mix;
        }
        else {
            Mix.new-from-pairs(%!elems.values);
        }
    }
    method MixHash { self }
    method Bag     { Bag.new-from-pairs(%!elems.values) }
    method BagHash { BagHash.new-from-pairs(%!elems.values) }

    multi method AT-KEY(MixHash:D: \k) {
        Proxy.new(
          FETCH => {
              my \v := %!elems.AT-KEY(k.WHICH);
              nqp::istype(v,Pair) ?? v.value !! 0;
          },
          STORE => -> $, $value is copy {
              if $value != 0 {
                  (%!elems.AT-KEY(k.WHICH) //= ((k) => 0)).value = $value;
              }
              else {
                  %!elems.DELETE-KEY(k.WHICH);
              }
              $value;
          }
        );
    }
}

# From 'src/core/set_operators.pm'


proto sub infix:<(elem)>($, $ --> Bool) {*}
multi sub infix:<(elem)>($a, Any $b --> Bool) {
    $a (elem) $b.Set(:view);
}
multi sub infix:<(elem)>($a, Set $b --> Bool) {
    $b.EXISTS-KEY($a);
}
only sub infix:<<"\x2208">>($a, $b --> Bool) {
    $a (elem) $b;
}
only sub infix:<<"\x2209">>($a, $b --> Bool) {
    $a !(elem) $b;
}

proto sub infix:<(cont)>($, $ --> Bool) {*}
multi sub infix:<(cont)>(Any $a, $b --> Bool) {
    $a.Set(:view) (cont) $b;
}
multi sub infix:<(cont)>(Set $a, $b --> Bool) {
    $a.EXISTS-KEY($b);
}
only sub infix:<<"\x220B">>($a, $b --> Bool) {
    $a (cont) $b;
}
only sub infix:<<"\x220C">>($a, $b --> Bool) {
    $a !(cont) $b;
}

only sub infix:<(|)>(**@p) {
    if @p.first(Mixy) {
        my $mixhash = nqp::istype(@p[0], MixHash)
            ?? MixHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.MixHash;
        for @p.map(*.Mix(:view)) -> $mix {
            $mixhash{$_} max= $mix{$_} for $mix.keys;
        }
        $mixhash.Mix(:view);
    } elsif @p.first(Baggy) {
        my $baghash = nqp::istype(@p[0], BagHash)
            ?? BagHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.BagHash;
        for @p.map(*.Bag(:view)) -> $bag {
            $baghash{$_} max= $bag{$_} for $bag.keys;
        }
        $baghash.Bag(:view);
    } else {
        Set.new( @p.map(*.Set(:view).keys) );
    }
}
only sub infix:<<"\x222A">>(|p) {
    infix:<(|)>(|p);
}

only sub infix:<(&)>(**@p) {
    return set() unless @p;

    if @p.first(Mixy) {
        my $mixhash = nqp::istype(@p[0], MixHash)
            ?? MixHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.MixHash;
        for @p.map(*.Mix(:view)) -> $mix {
            $mix{$_}
              ?? ($mixhash{$_} min= $mix{$_})
              !! $mixhash.DELETE-KEY($_)
              for $mixhash.keys;
        }
        $mixhash.Mix(:view);
    } elsif @p.first(Baggy) {
        my $baghash = nqp::istype(@p[0], BagHash)
            ?? BagHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.BagHash;
        for @p.map(*.Bag(:view)) -> $bag {
            $bag{$_}
              ?? ($baghash{$_} min= $bag{$_})
              !! $baghash.DELETE-KEY($_)
              for $baghash.keys;
        }
        $baghash.Bag(:view);
    } else {
        my $sethash = nqp::istype(@p[0], SetHash)
          ?? SetHash.new(@p.shift.keys)
          !! @p.shift.SetHash;
        for @p.map(*.Set(:view)) -> $set {
            $set{$_} || $sethash.DELETE-KEY($_) for $sethash.keys;
        }
        $sethash.Set(:view);
    }
}
only sub infix:<<"\x2229">>(|p) {
    infix:<(&)>(|p);
}

only sub infix:<(-)>(**@p) {
    return set() unless @p;

    if @p.first(Mixy) {
        my $mixhash = nqp::istype(@p[0], MixHash)
            ?? MixHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.MixHash;
        for @p.map(*.Mix(:view)) -> $mix {
            $mix{$_} < $mixhash{$_}
              ?? ($mixhash{$_} -= $mix{$_})
              !! $mixhash.DELETE-KEY($_)
              for $mixhash.keys;
        }
        $mixhash.Mix(:view);
    } elsif @p.first(Baggy) {
        my $baghash = nqp::istype(@p[0], BagHash)
            ?? BagHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.BagHash;
        for @p.map(*.Bag(:view)) -> $bag {
            $bag{$_} < $baghash{$_}
              ?? ($baghash{$_} -= $bag{$_})
              !! $baghash.DELETE-KEY($_)
              for $baghash.keys;
        }
        $baghash.Bag(:view);
    } else {
        my $sethash = nqp::istype(@p[0],SetHash)
          ?? SetHash.new(@p.shift.keys)
          !! @p.shift.SetHash;
        for @p.map(*.Set(:view)) -> $set {
            $set{$_} && $sethash.DELETE-KEY($_) for $sethash.keys;
        }
        $sethash.Set(:view);
    }
}
only sub infix:<<"\x2216">>(|p) {
    infix:<(-)>(|p);
}
only sub infix:<(^)>(**@p) {
    Set.new(BagHash.new(@p.map(*.Set(:view).keys)).pairs.map({.key if .value == 1}));
}
only sub infix:<<"\x2296">>($a, $b --> Setty) {
    $a (^) $b;
}

#     $a.Set(:view) eqv $b.Set(:view);
# }
#     $a == $b and so $a.keys.all (elem) $b
# }

proto sub infix:<<(<=)>>($, $ --> Bool) {*}
multi sub infix:<<(<=)>>(Any $a, Any $b --> Bool) {
    $a.Set(:view) (<=) $b.Set(:view);
}
multi sub infix:<<(<=)>>(Setty $a, Setty $b --> Bool) {
    $a <= $b and so $a.keys.all (elem) $b
}
only sub infix:<<"\x2286">>($a, $b --> Bool) {
    $a (<=) $b;
}
only sub infix:<<"\x2288">>($a, $b --> Bool) {
    $a !(<=) $b;
}

proto sub infix:<<(<)>>($, $ --> Bool) {*}
multi sub infix:<<(<)>>(Any $a, Any $b --> Bool) {
    $a.Set(:view) (<) $b.Set(:view);
}
multi sub infix:<<(<)>>(Setty $a, Setty $b --> Bool) {
    $a < $b and so $a.keys.all (elem) $b;
}
only sub infix:<<"\x2282">>($a, $b --> Bool) {
    $a (<) $b;
}
only sub infix:<<"\x2284">>($a, $b --> Bool) {
    $a !(<) $b;
}

proto sub infix:<<(>=)>>($, $ --> Bool) {*}
multi sub infix:<<(>=)>>(Any $a, Any $b --> Bool) {
    $a.Set(:view) (>=) $b.Set(:view);
}
multi sub infix:<<(>=)>>(Setty $a, Setty $b --> Bool) {
    $a >= $b and so $b.keys.all (elem) $a;
}
only sub infix:<<"\x2287">>($a, $b --> Bool) {
    $a (>=) $b;
}
only sub infix:<<"\x2289">>($a, $b --> Bool) {
    $a !(>=) $b;
}

proto sub infix:<<(>)>>($, $ --> Bool) {*}
multi sub infix:<<(>)>>(Any $a, Any $b --> Bool) {
    $a.Set(:view) (>) $b.Set(:view);
}
multi sub infix:<<(>)>>(Setty $a, Setty $b --> Bool) {
    $a > $b and so $b.keys.all (elem) $a;
}
only sub infix:<<"\x2283">>($a, $b --> Bool) {
    $a (>) $b;
}
only sub infix:<<"\x2285">>($a, $b --> Bool) {
    $a !(>) $b;
}

only sub infix:<(.)>(**@p) {
    return bag() unless @p;

    if @p.first(Mixy) {
        my $mixhash = nqp::istype(@p[0], MixHash)
            ?? MixHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.MixHash;
        for @p.map(*.Mix(:view)) -> $mix {
            $mix{$_}
              ?? ($mixhash{$_} *= $mix{$_})
              !! $mixhash.DELETE-KEY($_)
              for $mixhash.keys;
        }
        $mixhash.Mix(:view);
    } else {  # go Baggy by default
        my $baghash = nqp::istype(@p[0], BagHash)
            ?? BagHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.BagHash;
        for @p.map(*.Bag(:view)) -> $bag {
            $bag{$_}
              ?? ($baghash{$_} *= $bag{$_})
              !! $baghash.DELETE-KEY($_)
              for $baghash.keys;
        }
        $baghash.Bag(:view);
    }
}
only sub infix:<<"\x228D">>(|p) {
    infix:<(.)>(|p);
}

only sub infix:<(+)>(**@p) {
    return bag() unless @p;

    if @p.first(Mixy) {
        my $mixhash = nqp::istype(@p[0], MixHash)
            ?? MixHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.MixHash;
        for @p.map(*.Mix(:view)) -> $mix {
            $mixhash{$_} += $mix{$_} for $mix.keys;
        }
        $mixhash.Mix(:view);
    } else {  # go Baggy by default
        my $baghash = nqp::istype(@p[0], BagHash)
            ?? BagHash.new-from-pairs(@p.shift.pairs)
            !! @p.shift.BagHash;
        for @p.map(*.Bag(:view)) -> $bag {
            $baghash{$_} += $bag{$_} for $bag.keys;
        }
        $baghash.Bag(:view);
    }
}
only sub infix:<<"\x228E">>(|p) {
    infix:<(+)>(|p);
}

proto sub infix:<<(<+)>>($, $ --> Bool) {*}
multi sub infix:<<(<+)>>(Any $a, Any $b --> Bool) {
    if nqp::istype($a, Mixy) or nqp::istype($b, Mixy) {
        $a.Mix(:view) (<+) $b.Mix(:view);
    } else {
        $a.Bag(:view) (<+) $b.Bag(:view);
    }
}
multi sub infix:<<(<+)>>(QuantHash $a, QuantHash $b --> Bool) {
    for $a.keys {
        return False if $a{$_} > $b{$_};
    }
    True;
}
only sub infix:<<"\x227C">>($a, $b --> Bool) {
    $a (<+) $b;
}

proto sub infix:<<(>+)>>($, $ --> Bool) {*}
multi sub infix:<<(>+)>>(Baggy $a, Baggy $b --> Bool) {
    for $b.keys {
        return False if $b{$_} > $a{$_};
    }
    True;
}
multi sub infix:<<(>+)>>(Any $a, Any $b --> Bool) {
    if nqp::istype($a, Mixy) or nqp::istype($b, Mixy) {
        $a.Mix(:view) (>+) $b.Mix(:view);
    } else {
        $a.Bag(:view) (>+) $b.Bag(:view);
    }
}
only sub infix:<<"\x227D">>($a, $b --> Bool) {
    $a (>+) $b;
}

sub set(*@args --> Set) { Set.new(@args) }
sub bag(*@args --> Bag) { Bag.new(@args) }
sub mix(*@args --> Mix) { Mix.new(@args) }

# From 'src/core/ObjAt.pm'

my class ObjAt { # declared in BOOTSTRAP
    # class ObjAt is Any {
    #     has str $!value;
    method new(str $s) {
        nqp::box_s($s, self.WHAT)
    }

    multi method WHICH(ObjAt:D:) {
        nqp::box_s(
            nqp::concat(
                nqp::concat(nqp::unbox_s(self.^name), '|'),
                $!value
            ),
            ObjAt
        );
    }
    multi method Str(ObjAt:D:) {
        nqp::p6box_s(nqp::unbox_s(self));
    }
    multi method gist(ObjAt:D:) {
        nqp::p6box_s(nqp::unbox_s(self));
    }
}

# From 'src/core/Version.pm'

class Version {
    has @.parts;
    has Bool $.plus = False;

    multi method new(Str() $s) {
        my @parts = $s.comb(/:r '*' || \d+ || <.alpha>+/);
        for @parts {
            $_ .= Numeric if .Numeric.defined ;
            $_ = * if $_ eq '*';
        }
        self.bless(
          :parts(@parts),
          :plus($s.ends-with("+")),
        );
    };

    multi method Str(Version:D:) {
        @!parts.map({ nqp::istype($_,Whatever) ?? '*' !! $_}).join('.')
          ~ ($!plus ?? '+' !! '');
    }
    multi method gist(Version:D:) { 'v' ~ self.Str }
    multi method perl(Version:D:) {
        self.^name ~ ".new('" ~ self.Str ~ "')";

    }
    multi method ACCEPTS(Version:D: Version:D $other) {
        for @!parts.kv -> $i, $v {
            next if nqp::istype($v,Whatever);
            my $o = $other.parts[$i];
            return True unless defined $o;
            next if nqp::istype($o,Whatever);
            return $.plus if $o after  $v;
            return False  if $o before $v;
        }
        True;
    }

    multi method WHICH(Version:D:) {
        my $s := join '|', self.^name, self.Str;
        nqp::box_s(nqp::unbox_s($s), ObjAt);
    }
}


multi sub infix:<eqv>(Version:D $a, Version:D $b) {
    $a.WHAT === $b.WHAT && $a.Str eq $b.Str
}


multi sub infix:<cmp>(Version:D $a, Version:D $b) {
    proto vnumcmp(|) { * }
    multi vnumcmp(Str, Int) { Order::Less }
    multi vnumcmp(Int, Str) { Order::More }
    multi vnumcmp($av, $bv) { $av cmp $bv }

    my @av = $a.parts.values;
    my @bv = $b.parts.values;
    while @av || @bv {
       my $cmp = vnumcmp(@av.shift // 0, @bv.shift // 0);
       return $cmp if $cmp != Order::Same;
    }
    $a.plus cmp $b.plus;
}

# From 'src/core/ForeignCode.pm'


my class ForeignCode does Callable { # declared in BOOTSTRAP
    # class ForeignCode {
    #     has Mu $!do;                # Code object we delegate to

    method arity() { self.signature.arity }

    method count() { self.signature.count }

    method signature(ForeignCode:D:) { (sub (|) { }).signature }

    method name() { (nqp::can($!do, 'name') ?? $!do.name !! nqp::getcodename($!do)) || '<anon>' }

    multi method gist(ForeignCode:D:) { self.name }

    multi method Str(ForeignCode:D:) { self.name }
}

# From 'src/core/operators.pm'

## miscellaneous operators can go here.
##   generic numeric operators are in Numeric.pm
##   generic string operators are in Stringy.pm
##   Int/Rat/Num operators are in {Int|Rat|Num}.pm

sub infix:<=>(Mu \a, Mu \b) is rw {
    nqp::p6store(a, b)
}

my class X::Does::TypeObject is Exception {
    has Mu $.type;
    method message() { "Cannot use 'does' operator with a type object." }
}

proto sub infix:<does>(Mu, Mu, *%) { * }
multi sub infix:<does>(Mu:D \obj, Mu:U \rolish) is rw {
    # XXX Mutability check.
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    obj.^mixin($role).BUILD_LEAST_DERIVED({});
}
multi sub infix:<does>(Mu:D \obj, Mu:U \rolish, :$value! is parcel) is rw {
    # XXX Mutability check.
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    my \mixedin = obj.^mixin($role, :need-mixin-attribute);
    mixedin.BUILD_LEAST_DERIVED({ substr(mixedin.^mixin_attribute.Str,2) => $value });
}
multi sub infix:<does>(Mu:U \obj, Mu:U \role) is rw {
    X::Does::TypeObject.new(type => obj).throw
}
multi sub infix:<does>(Mu:D \obj, @roles) is rw {
    # XXX Mutability check.
    obj.^mixin(|@roles).BUILD_LEAST_DERIVED({});
}
multi sub infix:<does>(Mu:U \obj, @roles) is rw {
    X::Does::TypeObject.new(type => obj).throw
}

proto sub infix:<but>(Mu, Mu, *%) { * }
multi sub infix:<but>(Mu:D \obj, Mu:U \rolish) {
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    obj.clone.^mixin($role).BUILD_LEAST_DERIVED({});
}
multi sub infix:<but>(Mu:D \obj, Mu:U \rolish, :$value! is parcel) {
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    my \mixedin = obj.clone.^mixin($role, :need-mixin-attribute);
    my \attr = mixedin.^mixin_attribute;
    my $mixin-value := $value;
    unless nqp::istype($value, attr.type) {
        if attr.type.HOW.^name eq 'Perl6::Metamodel::EnumHOW' {
            $mixin-value := attr.type.($value);
        }
    }
    mixedin.BUILD_LEAST_DERIVED({ substr(attr.Str,2) => $mixin-value });
}
multi sub infix:<but>(Mu:U \obj, Mu:U \rolish) {
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    obj.^mixin($role);
}
multi sub infix:<but>(Mu \obj, Mu:D $val) is rw {
    my $role := Metamodel::ParametricRoleHOW.new_type();
    my $meth := method () { $val };
    $meth.set_name($val.^name);
    $role.^add_method($meth.name, $meth);
    $role.^set_body_block(
      -> |c { nqp::list($role, nqp::hash('$?CLASS', c<$?CLASS>)) });
    $role.^compose;
    obj.clone.^mixin($role);
}
multi sub infix:<but>(Mu:D \obj, @roles) {
    obj.clone.^mixin(|@roles).BUILD_LEAST_DERIVED({});
}
multi sub infix:<but>(Mu:U \obj, @roles) {
    obj.^mixin(|@roles)
}

sub SEQUENCE($left, Mu $right, :$exclude_end) {
    my @right := nqp::istype($right, Junction) || !$right.DEFINITE
      ?? [$right] !! $right.flat;
    my $endpoint = @right.shift;
    $endpoint.sink if $endpoint ~~ Failure;
    my $infinite = nqp::istype($endpoint,Whatever) || $endpoint === Inf;
    $endpoint = Bool::False if $infinite;
    my $tail := ().list;
    my $end_code_arity = 0;
    my $end_tail := ().list;
    if nqp::istype($endpoint,Code) {
        $end_code_arity = $endpoint.arity;
        $end_code_arity = $endpoint.count if $end_code_arity == 0;
        $end_code_arity = -Inf if $end_code_arity == Inf;
    }

    my sub succpred($a,$b) {
        my $cmp = $a cmp $b;
        if $a.WHAT === $b.WHAT === $endpoint.WHAT {
            $cmp < 0 && $a ~~ Stringy
                ?? -> $x {
                    my $new = $x.succ;
                    last if $new after $endpoint or $new.chars > $endpoint.chars;
                    $new;
                }
                !! $cmp < 0
                    ?? -> $x {
                        my $new = $x.succ;
                        last if $new after $endpoint;
                        $new;
                    }
                    !! $cmp > 0
                        ?? -> $x {
                            my $new = $x.pred;
                            last if $x before $endpoint;
                            $new;
                        }
                        !! { $_ }
        }
        else {
            $cmp < 0
                ?? { $^x.succ }
                !! $cmp > 0
                    ?? { $^x.pred }
                    !! { $^x }
        }
    }
    my sub unisuccpred($a,$b) {
        my $cmp = $a.ord cmp $b.ord;
        $cmp < 0
            ?? { $^x.ord.succ.chr }
            !! $cmp > 0
                ?? { $^x.ord.pred.chr }
                !! { $^x }
    }

    (GATHER({
        my @left := $left.flat;
        my $value;
        my $code;
        my $stop;
        for @left -> $v {
            $value := $v;
            if nqp::istype($value,Code) { $code = $value; last }
            if $end_code_arity != 0 {
                $end_tail.push($value);
                if +@$end_tail >= $end_code_arity {
                    $end_tail.munch($end_tail.elems - $end_code_arity) unless $end_code_arity ~~ -Inf;
                    if $endpoint(|@$end_tail) { $stop = 1; last }
                }
            } elsif $value ~~ $endpoint  { $stop = 1; last }
            $tail.push($value);
        }
        if $stop {
            take $_ for @$tail;
            take $value unless $exclude_end;
        }
        else {
            my $badseq;
            my ($a, $b, $c);
            unless $code.defined {
                take $tail.shift while $tail.elems > 3;
                $a = $tail[0];
                $b = $tail[1];
                $c = $tail[2];
            }
            if $code.defined { }
            elsif $tail.grep(Real).elems != $tail.elems {
                if $tail.elems > 1 {
                    if $tail[*-1].WHAT === $endpoint.WHAT {
                        $code = succpred($tail[*-1], $endpoint);
                    }
                    else {
                        $code = succpred($tail[*-2], $tail[*-1]);
                    }
                }
                elsif nqp::istype($endpoint, Stringy) and nqp::istype($a, Stringy) and nqp::isconcrete($endpoint) {
                    if $a.codes == 1 && $endpoint.codes == 1 {
                        $code = unisuccpred($a, $endpoint);
                    }
                    elsif $a.codes == $endpoint.codes {
                        my @a = $a.comb;
                        my @e = $endpoint.comb;
                        my @ranges;
                        for @a Z @e -> $from, $to {
                            @ranges.push: $($from ... $to);
                        }
                        .take for [X~] |@ranges;
                        $stop = 1;
                    }
                    elsif $a lt $endpoint {
                        $stop = 1 if $a gt $endpoint;
                        $code = -> $x {
                            my $new = $x.succ;
                            last if $new gt $endpoint or $new.chars > $endpoint.chars;
                            $new;
                        }
                    }
                    else {
                        $stop = 1 if $a lt $endpoint;
                        $code = -> $x {
                            my $new = $x.pred;
                            last if $new lt $endpoint;
                            $new;
                        }
                    }
                }
                elsif $infinite or nqp::istype($endpoint, Code) {
                    $code = *.succ;
                }
                else {
                    $code = succpred($a,$endpoint);
                }
            }
            elsif $tail.elems == 3 {
                my $ab = $b - $a;
                if $ab == $c - $b {
                    if $ab != 0 || nqp::istype($a,Real) && nqp::istype($b,Real) && nqp::istype($c,Real) {
                        if nqp::istype($endpoint, Real) and nqp::isconcrete($endpoint) {
                            if $ab > 0 {
                                $stop = 1 if $a > $endpoint;
                                $code = -> $x {
                                    my $new = $x + $ab;
                                    last if $new > $endpoint;
                                    $new;
                                }
                            }
                            else {
                                $stop = 1 if $a < $endpoint;
                                $code = -> $x {
                                    my $new = $x + $ab;
                                    last if $new < $endpoint;
                                    $new;
                                }
                            }
                        }
                        else {
                            $code = { $^x + $ab }
                        }
                    }
                    else {
                        $code = succpred($b, $c)
                    }
                }
                elsif $a != 0 && $b != 0 && $c != 0 {
                    $ab = $b / $a;
                    if $ab == $c / $b {
                        $ab = $ab.Int if nqp::istype($ab,Rat) && $ab.denominator == 1;
                        if nqp::istype($endpoint, Real) and nqp::isconcrete($endpoint) {
                            if $ab > 0 {
                                if $ab > 1  {
                                    $stop = 1 if $a > $endpoint;
                                    $code = -> $x {
                                        my $new = $x * $ab;
                                        last if $new > $endpoint;
                                        $new;
                                    }
                                }
                                else {
                                    $stop = 1 if $a < $endpoint;
                                    $code = -> $x {
                                        my $new = $x * $ab;
                                        last if $new < $endpoint;
                                        $new;
                                    }
                                }
                            }
                            else {
                                $code = -> $x {
                                    my $new = $x * $ab;
                                    my $absend = $endpoint.abs;
                                    last if sign($x.abs - $absend) == -sign($new.abs - $absend);
                                    $new;
                                }
                            }
                        }
                        else {
                            $code = { $^x * $ab }
                        }
                    }
                }
                if $code {
                    $tail.pop;
                    $tail.pop;
                }
                else {
                    $badseq = "$a,$b,$c" unless $code;
                }
            }
            elsif $tail.elems == 2 {
                my $ab = $b - $a;
                if $ab != 0 || nqp::istype($a,Real) && nqp::istype($b,Real) {
                    if nqp::istype($endpoint, Real) and nqp::isconcrete($endpoint) {
                        if $ab > 0 {
                            $stop = 1 if $a > $endpoint;
                            $code = -> $x {
                                my $new = $x + $ab;
                                last if $new > $endpoint;
                                $new;
                            }
                        }
                        else {
                            $stop = 1 if $a < $endpoint;
                            $code = -> $x {
                                my $new = $x + $ab;
                                last if $new < $endpoint;
                                $new;
                            }
                        }
                    }
                    else {
                        $code = { $^x + $ab }
                    }
                }
                else {
                    $code = succpred($a, $b)
                }
                $tail.pop;
            }
            elsif $tail.elems == 1 {
                if nqp::istype($endpoint,Code) or not nqp::isconcrete($endpoint) {
                    $code = { $^x.succ }
                }
                elsif nqp::istype($endpoint, Real) and nqp::istype($a, Real) {
                    if $a < $endpoint {
                        $code = -> $x {
                            my $new = $x.succ;
                            last if $new > $endpoint;
                            $new;
                        }
                    }
                    else {
                        $code = -> $x {
                            my $new = $x.pred;
                            last if $new < $endpoint;
                            $new;
                        }
                    }
                }
                else {
                    $code = { $^x.succ }
                }
            }
            elsif $tail.elems == 0 {
                $code = {()}
            }

            if $stop { }
            elsif $code.defined {
                take $_ for @$tail;

                my $count = $code.count;
                while 1 {
                    $tail.shift while $tail.elems > $count;
                    my \value = $code(|$tail);
                    if $end_code_arity != 0 {
                        $end_tail.push(|value);
                        if $end_tail.elems >= $end_code_arity {
                            $end_tail.munch($end_tail.elems - $end_code_arity) unless $end_code_arity == -Inf;
                            if $endpoint(|@$end_tail) {
                                (.take for value) unless $exclude_end;
                                last;
                            }
                        }
                    }
                    elsif value ~~ $endpoint {
                        (.take for value) unless $exclude_end;
                        last;
                    }
                    if value {
                        $tail.push(|value);
                        .take for value;
                    }
                    else {
                        $tail.push(value.item);
                        take value;
                    }
                }
            }
            elsif $badseq {
                take (sub { fail X::Sequence::Deduction.new(:from($badseq)) })();
            }
            else {
                take (sub { fail X::Sequence::Deduction.new() })();
            }
        }
    }, :$infinite), @right).list;
}

sub WHAT(Mu \x) { x.WHAT }
sub VAR (Mu \x) { x.VAR }

proto sub infix:<...>(|) { * }
multi sub infix:<...>($a, Mu $b) { SEQUENCE($a, $b) }
multi sub infix:<...>(**@lol) {
    my @ret;
    my int $i = 0;
    my int $m = +@lol - 1;
    my @tail = @lol[$m].list.splice(1); # trailing elems of last list added back later
    my $current_left;
    while $m > $i {
        if @ret { # 1st elem of left part can be closure; take computed value instead
            $current_left = (@ret.pop, @lol[$i].list.splice(1));
        }
        else { # no need to modify left part for first list
            $current_left = @lol[$i];
        }
        @ret := (@ret,
            SEQUENCE(
                $current_left,        # from-range (adjusted if needed), specifies steps
                @lol[$i + 1].list[0], # to, we only need the endpoint (= first item)
                :exclude_end( False ) # never exclude end; we take care of that
            )
        ).flat;
        $i = nqp::add_i($i, 1);
    }
    push @ret, @tail if @tail;  # add back trailing elements of last list
    @ret
}

proto sub infix:<...^>(|) { * }
multi sub infix:<...^>($a, Mu $b) { SEQUENCE($a, $b, :exclude_end(1)) }

proto sub infix:<>(|) { * }
multi sub infix:<>(|c) { infix:<...>(|c) }

proto sub infix:<^>(|) { * }
multi sub infix:<^>(|c) { infix:<...^>(|c) }

sub undefine(Mu \x) is rw { x = Nil }

sub prefix:<temp>(\cont) is rw {
    my $temp_restore := nqp::getlexcaller('!TEMP-RESTORE');
    my int $i = nqp::elems($temp_restore);
    while $i > 0 {
        $i = $i - 2;
        return-rw cont if nqp::atpos($temp_restore, $i) =:= cont;
    }
    if nqp::iscont(cont) {
        nqp::push($temp_restore, cont);
        nqp::push($temp_restore, nqp::decont(cont));
    }
    elsif nqp::istype(cont, Array) {
        nqp::push($temp_restore, cont);
        nqp::push($temp_restore, my @a = cont);
    }
    elsif nqp::istype(cont, Hash) {
        nqp::push($temp_restore, cont);
        nqp::push($temp_restore, my %h = cont);
    }
    else {
        X::Localizer::NoContainer.new(localizer => 'temp').throw;
    }
    cont
}

sub prefix:<let>(\cont) is rw {
    my $let_restore := nqp::getlexcaller('!LET-RESTORE');
    my int $i = nqp::elems($let_restore);
    while $i > 0 {
        $i = $i - 2;
        return-rw cont if nqp::atpos($let_restore, $i) =:= cont;
    }
    if nqp::iscont(cont) {
        nqp::push($let_restore, cont);
        nqp::push($let_restore, nqp::decont(cont));
    }
    elsif nqp::istype(cont, Array) {
        nqp::push($let_restore, cont);
        nqp::push($let_restore, my @a = cont);
    }
    elsif nqp::istype(cont, Hash) {
        nqp::push($let_restore, cont);
        nqp::push($let_restore, my %h = cont);
    }
    else {
        X::Localizer::NoContainer.new(localizer => 'let').throw;
    }
    cont
}

sub INDIRECT_NAME_LOOKUP($root, *@chunks) is rw {
    # note that each part of @chunks itself can
    # contain double colons. That's why joining and
    # re-splitting is necessary
    my Str $name = @chunks.join('::');
    my @parts    = $name.split('::');
    my $first    = @parts.shift;
    if @parts && '$@%&'.index(substr($first,0, 1)).defined {
        # move sigil from first to last chunk, because
        # $Foo::Bar::baz is actually stored as Foo::Bar::$baz
        my $last_idx      = @parts.end;
        @parts[$last_idx] = substr($first,0, 1) ~ @parts[$last_idx];
        $first            = substr($first,1);
        if $first eq '' {
            $first = @parts.shift;
            $name = @chunks.join('::');
        }
    }
    my Mu $thing := $root.EXISTS-KEY($first) ?? $root{$first} !!
                    GLOBAL::.EXISTS-KEY($first) ?? GLOBAL::{$first} !!
                    X::NoSuchSymbol.new(symbol => $name).fail;
    for @parts {
        X::NoSuchSymbol.new(symbol => $name).fail unless $thing.WHO.EXISTS-KEY($_);
        $thing := $thing.WHO{$_};
    }
    $thing;
}

sub REQUIRE_IMPORT($package-name, *@syms) {
    my $package = CALLER::OUR::($package-name);
    my $who     = $package.WHO;
    unless $who.EXISTS-KEY('EXPORT') {
        die "Trying to import symbols @syms.join(', ') from '$package-name', but it does not export anything";
    }
    $who := $who<EXPORT>.WHO<DEFAULT>.WHO;
    my @missing;
    for @syms {
        unless $who.EXISTS-KEY($_) {
            @missing.push: $_;
            next;
        }
        OUTER::CALLER::{$_} := $who{$_};
    }
    if @missing {
        X::Import::MissingSymbols.new(:from($package-name), :@missing).throw;
    }
    $package
}
sub infix:<andthen>(*@a) {
    my Mu $current := @a.shift;
    for @a {
        return $current unless $current.defined;
        $current := .count ?? $_(|$current) !! $_();
    }
    $current;
}

# From 'src/core/metaops.pm'


sub METAOP_ASSIGN(\op) {
    -> Mu \a, Mu \b { a = op.( a // op.(), b) }
}

sub METAOP_TEST_ASSIGN:<//>(\lhs, $rhs) is rw { lhs // (lhs = $rhs()) }
sub METAOP_TEST_ASSIGN:<||>(\lhs, $rhs) is rw { lhs || (lhs = $rhs()) }
sub METAOP_TEST_ASSIGN:<&&>(\lhs, $rhs) is rw { lhs && (lhs = $rhs()) }

sub METAOP_NEGATE(\op) {
    -> Mu \a, Mu \b { !op.(a ,b) }
}

sub METAOP_REVERSE(\op) {
    -> |args { op.(|args.reverse) }
}

sub METAOP_CROSS(\op, &reduce) {
    return &infix:<X> if op === &infix:<,>;

    -> |lol {
        my $rop = lol.elems == 2 ?? op !! &reduce(op);
        my $Inf = False;
        my @lol = eager for ^lol.elems -> $i {
            my \elem = lol[$i];         # can't use mapping here, mustn't flatten
            $Inf = True if elem.infinite;

            if nqp::iscont(elem) { (elem,).list.item }
            else                 { (elem,).flat.item }
        }
        my Mu $cache := nqp::list();
        my int $i = 0;
        for ^lol.elems {
            $i = $_;
            my Mu $rpa := nqp::list();
            nqp::bindpos($cache, $i, $rpa);
        }
        my int $n = lol.elems - 1;
        my $j = 0;
        my @j;
        my @v;

        # Don't care if a finite Range is lazy
        my $policy = &list;
        if nqp::istype(lol[0],Range) {
            $policy = &EAGER unless $Inf || lol[0].infinite;
        }

        $i = 0;
        $policy(gather {
            while $i >= 0 {
                my Mu $sublist := nqp::atpos($cache, $i);
                if $j < nqp::elems($sublist) {
                    my Mu $o := nqp::atpos($sublist, $j);
                    @v[$i] := $o;
                    $j = $j + 1;
                    if $i >= $n { take $rop(|@v); }
                    else { $i = $i + 1; @j.push($j); $j = 0; }
                }
                elsif @lol[$i].gimme(1) {
                    my Mu $o := @lol[$i].shift;
                    nqp::bindpos($sublist, $j, $o);
                    redo;
                }
                else {
                    $i = $i - 1;
                    if $i { $j = @j.pop if $i > 0 }  # continue previous dimension where we left off
                    else  {
                        $j = 0;
                        my Mu $sublist := nqp::atpos($cache,$i);
                        nqp::pop($sublist);          # don't cache 1st dimension (could be infinite)
                    }
                }
            }
        })
    }
}

sub METAOP_ZIP(\op, &reduce) {
    -> |lol {
        my $arity = lol.elems;
        my $rop = $arity == 2 ?? op !! &reduce(op);
        my @lol = eager for ^lol.elems -> $i {
            my \elem = lol[$i];         # can't use mapping here, mustn't flatten

            if nqp::iscont(elem) { (elem,).list.item }
            else                 { (elem,).flat.item }
        }
        gather {
            loop {
                my \z = @lol.map: { last unless .gimme(1); .shift }
                last if z.elems < $arity;
                take-rw $rop(|z);
            }
        }
    }
}

sub METAOP_REDUCE_LEFT(\op, :$triangle) {
    my $x := $triangle ??
        (sub (*@values) {
            return () unless @values.gimme(1);
            GATHER({
                my $result := @values.shift;
                take $result;
                take ($result := op.($result, @values.shift))
                    while @values.gimme(1);
            }, :infinite(@values.infinite))
        }) !!
        (sub (*@values) {
            return op.() unless @values.gimme(1);
            my $result := @values.shift;
            return op.($result) unless @values.gimme(1);
            my int $i;
            while my int $c = @values.gimme(1000) {
                $i = 0;
                $result := op.($result, @values.shift)
                    while ($i = $i + 1) <= $c;
            }
            $result;
        })
}

sub METAOP_REDUCE_RIGHT(\op, :$triangle) {
    my $x :=
    sub (*@values) {
        my $list = @values.reverse;
        if $triangle {
            return () unless $list.gimme(1);
            gather {
                my $result := $list.shift;
                take $result;
                take ($result := op.($list.shift, $result))
                    while $list.gimme(1);
            }
        }
        else {
            return op.() unless $list.gimme(1);
            my $result := $list.shift;
            return op.($result) unless $list.gimme(1);
            my int $i;
            while my int $c = $list.gimme(1000) {
                $i = 0;
                $result := op.($list.shift, $result)
                    while ($i = $i + 1) <= $c;
            }
            $result;
        }
    }
}


sub METAOP_REDUCE_LIST(\op, :$triangle) {
    $triangle
        ??  sub (*@values) {
                return () unless @values.gimme(1);
                GATHER({
                    my @list;
                    while @values {
                        @list.push(@values.shift);
                        take op.(|@list);
                    }
                }, :infinite(@values.infinite))
            }
        !!  sub (*@values) { op.(|@values) }
}


sub METAOP_REDUCE_LISTINFIX(\op, :$triangle) {
    $triangle
        ??  sub (|values) {
                my \p = values[0];
                return () unless p.elems;
                my int $i = 0;
                GATHER({
                    my @list;
                    while $i < p.elems {
                        @list.push(p[$i]);
                        $i = $i + 1;
                        take op.(|@list);
                    }
                }, :infinite(p.infinite))
            }
        !!  sub (|values) { my \p = values[0]; nqp::iscont(p[0]) ?? op.(|p.map({nqp::decont($_).list.Parcel})) !! op.(|p) }
}


sub METAOP_REDUCE_CHAIN(\op, :$triangle) {
    $triangle
        ??  sub (*@values) {
                my $state = True;
                my Mu $current = @values.shift;
                gather {
                    take $state;
                    while $state && @values.gimme(1) {
                        $state = op.($current, @values[0]);
                        take $state;
                        $current = @values.shift;
                    }
                    take False for @values;
                }

            }
        !! sub (*@values) {
                my $state = True;
                my Mu $current = @values.shift;
                while @values.gimme(1) {
                    $state = op.($current, @values[0]);
                    $current = @values.shift;
                    return $state unless $state;
                }
                $state;
            }
}


sub METAOP_REDUCE_XOR(\op, :$triangle) {
    X::NYI.new(feature => 'xor reduce').throw;
}

sub METAOP_HYPER(\op, *%opt) {
    -> Mu \a, Mu \b { hyper(op, a, b, |%opt) }
}

proto sub METAOP_HYPER_POSTFIX(|) {*}
multi sub METAOP_HYPER_POSTFIX(\obj, \op) { flatmap(op, obj) }
multi sub METAOP_HYPER_POSTFIX(\obj, \args, \op) { flatmap( -> \o { op.(o,|args) }, obj ) }

sub METAOP_HYPER_PREFIX(\op, \obj) { deepmap(op, obj) }

sub METAOP_HYPER_CALL(\list, |args) { deepmap(-> $c { $c(|args) }, list) }

proto sub hyper(|) { * }

multi sub hyper(&op, \left, \right, :$dwim-left, :$dwim-right) {
    op(left, right);
}

multi sub hyper(&operator, Positional:D \left, \right, :$dwim-left, :$dwim-right) {
    my @result;
    X::HyperOp::Infinite.new(:side<left>, :&operator).throw if left.infinite;
    my int $elems = left.elems;
    X::HyperOp::NonDWIM.new(:&operator, :left-elems($elems), :right-elems(1)).throw
        unless $elems == 1 or $elems > 1 and $dwim-right or $elems == 0 and $dwim-left || $dwim-right;
    my @left := left.eager;
    for ^$elems {
        @result[$_] := hyper(&operator, @left[$_], right, :$dwim-left, :$dwim-right);
    }
    # Coerce to the original type
    my $type = left.WHAT;
    nqp::iscont(left) ?? $type(@result.eager).item !! $type(@result.eager)
}

multi sub hyper(&operator, \left, Positional:D \right, :$dwim-left, :$dwim-right) {
    my @result;
    X::HyperOp::Infinite.new(:side<right>, :&operator).throw if right.infinite;
    my int $elems = right.elems;
    X::HyperOp::NonDWIM.new(:&operator, :left-elems(1), :right-elems($elems)).throw
        unless $elems == 1 or $elems > 1 and $dwim-left or $elems == 0 and $dwim-left || $dwim-right;
    my @right := right.eager;
    for ^$elems {
        @result[$_] := hyper(&operator, left, @right[$_], :$dwim-left, :$dwim-right);
    }
    # Coerce to the original type
    my $type = right.WHAT;
    nqp::iscont(right) ?? $type(@result.eager).item !! $type(@result.eager)
}

multi sub hyper(&operator, Positional:D \left, Positional:D \right, :$dwim-left, :$dwim-right) {
    my @result;

    # Check if a dwimmy side ends *. If so, that's considered a replication of the final element
    my $left-elems  = left.elems;
    my $right-elems = right.elems;
    my $left-whatev = 0;
    my $right-whatev = 0;
    if $dwim-left and 1 < $left-elems < Inf and left[$left-elems - 1] ~~ Whatever {
        $left-whatev++; $left-elems--;
    }
    if $dwim-right and 1 < $right-elems < Inf and right[$right-elems - 1] ~~ Whatever {
        $right-whatev++; $right-elems--;
    }

    # Determine the number of elements we need, and how many we non-dwimmily have
    my int $max-elems;
    my int $min-elems;
    if $left-elems == $right-elems {
        X::HyperOp::Infinite.new(:side<both>, :&operator).throw
            if $left-elems == Inf;
        $max-elems = $min-elems = $left-elems;
    }
    elsif $dwim-left && $dwim-right {
        X::HyperOp::Infinite.new(:side($left-elems == Inf ?? "left" !! "right"), :&operator).throw
            if $left-elems | $right-elems == Inf;
        $max-elems = $left-elems max $right-elems;
        $min-elems = $left-elems min $right-elems;
    }
    elsif $dwim-left {
        X::HyperOp::Infinite.new(:side<right>, :&operator).throw
            if $right-elems == Inf;
        $max-elems = $right-elems;
        $min-elems = $left-elems min $right-elems; # could be truncation
    }
    elsif $dwim-right {
        X::HyperOp::Infinite.new(:side<left>, :&operator).throw
            if $left-elems == Inf;
        $max-elems = $left-elems;
        $min-elems = $left-elems min $right-elems; # could be truncation
    }
    else {
        X::HyperOp::NonDWIM.new(:&operator, :$left-elems, :$right-elems).throw
    }

    # Generate all of the non-dwimmmy results
    my @left  :=  left.list;
    my @right := right.list;
    @left.gimme($max-elems);
    @right.gimme($max-elems);
    for ^$min-elems {
        @result[$_] := hyper(&operator, @left[$_], @right[$_], :$dwim-left, :$dwim-right);
    }

    # Check if 0 < $elems since if either side is empty and dwimmy (or both are empty),
    # and so @result should just remain empty.
    # If $elems < $max-elems, on the other hand, we still have more dwimmy results to generate
    if 0 < $left-elems < $max-elems {
        if $left-whatev || $left-elems == 1 {
            # Repeat last element
            my $last-elem := @left[$left-elems - 1];
            for $left-elems..^$max-elems {
                @result[$_] := hyper(&operator, $last-elem, @right[$_], :$dwim-left, :$dwim-right);
            }
        } else {
            # Cycle through the elements
            for $left-elems..^$max-elems {
                @result[$_] := hyper(&operator, @left[$_ % $left-elems], @right[$_], :$dwim-left, :$dwim-right);
            }
        }
    } elsif 0 < $right-elems < $max-elems {
        if $right-whatev || $right-elems == 1 {
            # Repeat last element
            my $last-elem := @right[$right-elems - 1];
            for $right-elems..^$max-elems {
                @result[$_] := hyper(&operator, @left[$_], $last-elem, :$dwim-left, :$dwim-right);
            }
        } else {
            # Cycle through the elements
            for $right-elems..^$max-elems {
                @result[$_] := hyper(&operator, @left[$_], @right[$_ % $right-elems], :$dwim-left, :$dwim-right);
            }
        }
    }

    # Coerce to the original type
    my $type = left.WHAT;
    nqp::iscont(left) ?? $type(@result.eager).item !! $type(@result.eager)
}

multi sub hyper(\op, \obj) {
    # fake it till we get a nodal trait
    my $nodal = True;

    $nodal ?? flatmap(op, obj) !! deepmap(op,obj);
}

proto sub deepmap(|) { * }

multi sub deepmap(\op, \obj) {
    my Mu $rpa := nqp::list();
    my Mu $items := nqp::p6listitems(obj.flat.eager);
    my Mu $o;
    # We process the elements in two passes, end to start, to
    # prevent users from relying on a sequential ordering of hyper.
    # Also, starting at the end pre-allocates $rpa for us.
    my int $i = nqp::elems($items) - 1;
    nqp::while(
        nqp::isge_i($i, 0),
        nqp::stmts(
            ($o := nqp::atpos($items, $i)),
            nqp::bindpos($rpa, $i,
                nqp::if(nqp::istype($o, Iterable),
                        $o.new(deepmap(op, $o)).item,
                        op.($o))),
            $i = nqp::sub_i($i, 2)
        )
    );
    $i = nqp::elems($items) - 2;
    nqp::while(
        nqp::isge_i($i, 0),
        nqp::stmts(
            ($o := nqp::atpos($items, $i)),
            nqp::bindpos($rpa, $i,
                nqp::if(nqp::istype($o, Iterable),
                        $o.new(deepmap(op, $o)).item,
                        op.($o))),
            $i = nqp::sub_i($i, 2)
        )
    );
    nqp::p6parcel($rpa, Nil);
}

multi sub deepmap(\op, Associative \h) {
    my @keys = h.keys;
    hash @keys Z deepmap(op, h{@keys})
}

proto sub flatmap(|) { * }
multi sub flatmap(\op, \obj) {
    my Mu $rpa := nqp::list();
    my Mu $items := nqp::p6listitems(obj.flat.eager);
    my Mu $o;
    # We process the elements in two passes, end to start, to
    # prevent users from relying on a sequential ordering of hyper.
    # Also, starting at the end pre-allocates $rpa for us.
    my int $i = nqp::elems($items) - 1;
    nqp::while(
        nqp::isge_i($i, 0),
        nqp::stmts(
            ($o := nqp::atpos($items, $i)),
            nqp::bindpos($rpa, $i,
                nqp::if(Mu,             # hack cuz I don't understand nqp
                        $o.new(flatmap(op, $o)).item,
                        op.($o))),
            $i = nqp::sub_i($i, 2)
        )
    );
    $i = nqp::elems($items) - 2;
    nqp::while(
        nqp::isge_i($i, 0),
        nqp::stmts(
            ($o := nqp::atpos($items, $i)),
            nqp::bindpos($rpa, $i,
                nqp::if(Mu,             # hack cuz I don't understand nqp
                        $o.new(flatmap(op, $o)).item,
                        op.($o))),
            $i = nqp::sub_i($i, 2)
        )
    );
    nqp::p6parcel($rpa, Nil);
}

multi sub flatmap(\op, Associative \h) {
    my @keys = h.keys;
    hash @keys Z flatmap(op, h{@keys})
}

proto sub duckmap(|) { * }
multi sub duckmap(\op, \obj) {
    flatmap(-> \arg { try { op.(arg) } // try { duckmap(op,arg) } }, obj);
}

multi sub duckmap(\op, Associative \h) {
    my @keys = h.keys;
    hash @keys Z duckmap(op, h{@keys})
}

multi sub hyper(&op, Associative:D \left, Associative:D \right, :$dwim-left, :$dwim-right) {
    my %keyset;
    if !$dwim-left {
        %keyset{$_} = 1 for left.keys;
    }
    else {
        %keyset{$_} = 1 if right.EXISTS-KEY($_) for left.keys;
    }
    if !$dwim-right {
        %keyset{$_} = 1 for right.keys;
    }
    my @keys := %keyset.keys;
    my $type = left.WHAT;
    my %result := $type(@keys Z=> hyper(&op, left{@keys}, right{@keys}, :$dwim-left, :$dwim-right));
    nqp::iscont(left) ?? $%result !! %result;
}

multi sub hyper(&op, Associative:D \left, \right, :$dwim-left, :$dwim-right) {
    my @keys = left.keys;
    my $type = left.WHAT;
    my %result := $type(@keys Z=> hyper(&op, left{@keys}, right, :$dwim-left, :$dwim-right));
    nqp::iscont(left) ?? $%result !! %result;
}

multi sub hyper(&op, \left, Associative:D \right, :$dwim-left, :$dwim-right) {
    my @keys = right.keys;
    my $type = right.WHAT;
    my %result := $type(@keys Z=> hyper(&op, left, right{@keys}, :$dwim-left, :$dwim-right));
    nqp::iscont(right) ?? $%result !! %result;
}

# From 'src/core/precedence.pm'

BEGIN {
    my Mu $methodcall       := nqp::hash('prec', 'y=');
    my Mu $autoincrement    := nqp::hash('prec', 'x=');
    my Mu $exponentiation   := nqp::hash('prec', 'w=', 'assoc', 'right');
    my Mu $symbolic_unary   := nqp::hash('prec', 'v=');
    my Mu $multiplicative   := nqp::hash('prec', 'u=', 'assoc', 'left');
    my Mu $iffy             := nqp::hash('prec', 'u=', 'assoc', 'left', 'iffy', 1);
    my Mu $additive         := nqp::hash('prec', 't=', 'assoc', 'left');
    my Mu $replication      := nqp::hash('prec', 's=', 'assoc', 'left');
    my Mu $concatenation    := nqp::hash('prec', 'r=', 'assoc', 'list');
    my Mu $junctive_and     := nqp::hash('prec', 'q=', 'assoc', 'list');
    my Mu $junctive_or      := nqp::hash('prec', 'p=', 'assoc', 'list');
    my Mu $structural       := nqp::hash('prec', 'n=', 'assoc', 'non');
    my Mu $chaining         := nqp::hash('prec', 'm=', 'assoc', 'chain', 'iffy', 1, 'pasttype', 'chain');
    my Mu $tight_and        := nqp::hash('prec', 'l=', 'assoc', 'list');
    my Mu $tight_or         := nqp::hash('prec', 'k=', 'assoc', 'list');
    my Mu $conditional      := nqp::hash('prec', 'j=', 'assoc', 'right', 'iffy', 1);
    my Mu $item_assignment  := nqp::hash('prec', 'i=', 'assoc', 'right');
    my Mu $loose_unary      := nqp::hash('prec', 'h=');
    my Mu $comma            := nqp::hash('prec', 'g=', 'assoc', 'list');
    my Mu $list_infix       := nqp::hash('prec', 'f=', 'assoc', 'list');
    my Mu $list_prefix      := nqp::hash('prec', 'e=');
    my Mu $loose_and        := nqp::hash('prec', 'd=', 'assoc', 'list');
    my Mu $loose_or         := nqp::hash('prec', 'c=', 'assoc', 'list');

    trait_mod:<is>(&postfix:<i>, :prec($methodcall));

    trait_mod:<is>(&prefix:<++>,  :prec($autoincrement));
    trait_mod:<is>(&prefix:<-->,  :prec($autoincrement));
    trait_mod:<is>(&postfix:<++>, :prec($autoincrement));
    trait_mod:<is>(&postfix:<-->, :prec($autoincrement));

    trait_mod:<is>(&infix:<**>, :prec($exponentiation));

    trait_mod:<is>(&prefix:<+>,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<~>,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<->,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<?>,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<!>,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<+^>, :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<~^>, :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<?^>, :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<^>,  :prec($symbolic_unary));

    trait_mod:<is>(&infix:<*>,   :prec($multiplicative));
    trait_mod:<is>(&infix:</>,   :prec($multiplicative));
    trait_mod:<is>(&infix:<div>, :prec($multiplicative));
    trait_mod:<is>(&infix:<gcd>, :prec($multiplicative));
    trait_mod:<is>(&infix:<lcm>, :prec($multiplicative));
    trait_mod:<is>(&infix:<%>,   :prec($multiplicative));
    trait_mod:<is>(&infix:<mod>, :prec($multiplicative));
    trait_mod:<is>(&infix:<+&>,  :prec($multiplicative));
    trait_mod:<is>(&infix:<~&>,  :prec($multiplicative));
    trait_mod:<is>(&infix:<?&>,  :prec($multiplicative));

    trait_mod:<is>(&infix:<%%>,  :prec($iffy));

    trait_mod:<is>(&infix:<+>,  :prec($additive));
    trait_mod:<is>(&infix:<->,  :prec($additive));
    trait_mod:<is>(&infix:<+|>, :prec($additive));
    trait_mod:<is>(&infix:<+^>, :prec($additive));
    trait_mod:<is>(&infix:<~|>, :prec($additive));
    trait_mod:<is>(&infix:<~^>, :prec($additive));
    trait_mod:<is>(&infix:<?|>, :prec($additive));
    trait_mod:<is>(&infix:<?^>, :prec($additive));

    trait_mod:<is>(&infix:<x>,  :prec($replication));
    trait_mod:<is>(&infix:<xx>, :prec($replication));

    trait_mod:<is>(&infix:<~>, :prec($concatenation));

    trait_mod:<is>(&infix:<&>,          :prec($junctive_and));
    trait_mod:<is>(&infix:<(&)>,        :prec($junctive_and));
    trait_mod:<is>(&infix:<<"\x2229">>, :prec($junctive_and));
    trait_mod:<is>(&infix:<(.)>,        :prec($junctive_and));
    trait_mod:<is>(&infix:<<"\x228D">>, :prec($junctive_and));

    trait_mod:<is>(&infix:<|>,          :prec($junctive_or));
    trait_mod:<is>(&infix:<^>,          :prec($junctive_or));
    trait_mod:<is>(&infix:<(+)>,        :prec($junctive_or));
    trait_mod:<is>(&infix:<<"\x228E">>, :prec($junctive_or));
    trait_mod:<is>(&infix:<(|)>,        :prec($junctive_or));
    trait_mod:<is>(&infix:<<"\x222A">>, :prec($junctive_or));
    trait_mod:<is>(&infix:<(-)>,        :prec($junctive_or));
    trait_mod:<is>(&infix:<<"\x2216">>, :prec($junctive_or));
    trait_mod:<is>(&infix:<(^)>,        :prec($junctive_or));
    trait_mod:<is>(&infix:<<"\x2296">>, :prec($junctive_or));

    trait_mod:<is>(&infix:<==>,         :prec($chaining));
    trait_mod:<is>(&infix:<!=>,         :prec($chaining));
    trait_mod:<is>(&infix:<eq>,         :prec($chaining));
    trait_mod:<is>(&infix:<ne>,         :prec($chaining));
    trait_mod:<is>(&infix:<le>,         :prec($chaining));
    trait_mod:<is>(&infix:<ge>,         :prec($chaining));
    trait_mod:<is>(&infix:<lt>,         :prec($chaining));
    trait_mod:<is>(&infix:<gt>,         :prec($chaining));
    trait_mod:<is>(&infix:<=:=>,        :prec($chaining));
    trait_mod:<is>(&infix:<===>,        :prec($chaining));
    trait_mod:<is>(&infix:<eqv>,        :prec($chaining));
    trait_mod:<is>(&infix:<before>,     :prec($chaining));
    trait_mod:<is>(&infix:<after>,      :prec($chaining));
    trait_mod:<is>(&infix:<~~>,         :prec($chaining));
    trait_mod:<is>(&infix:<(elem)>,     :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2208">>, :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2209">>, :prec($chaining));
    trait_mod:<is>(&infix:<(cont)>,     :prec($chaining));
    trait_mod:<is>(&infix:<<"\x220B">>, :prec($chaining));
    trait_mod:<is>(&infix:<<"\x220C">>, :prec($chaining));
    trait_mod:<is>(&infix:<<(<)>>,      :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2282">>, :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2284">>, :prec($chaining));
    trait_mod:<is>(&infix:<<(>)>>,      :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2283">>, :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2285">>, :prec($chaining));
    trait_mod:<is>(&infix:<<(<=)>>,     :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2286">>, :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2288">>, :prec($chaining));
    trait_mod:<is>(&infix:<<(>=)>>,     :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2287">>, :prec($chaining));
    trait_mod:<is>(&infix:<<"\x2289">>, :prec($chaining));
    trait_mod:<is>(&infix:<<(<+)>>,     :prec($chaining));
    trait_mod:<is>(&infix:<<"\x227C">>, :prec($chaining));
    trait_mod:<is>(&infix:<<(>+)>>,     :prec($chaining));
    trait_mod:<is>(&infix:<<"\x227D">>, :prec($chaining));

    trait_mod:<is>(&infix:<..>,   :prec($structural));
    trait_mod:<is>(&infix:<^..>,  :prec($structural));
    trait_mod:<is>(&infix:<..^>,  :prec($structural));
    trait_mod:<is>(&infix:<^..^>, :prec($structural));
    trait_mod:<is>(&infix:<leg>,  :prec($structural));
    trait_mod:<is>(&infix:<cmp>,  :prec($structural));
    trait_mod:<is>(&infix:<but>,  :prec($structural));
    trait_mod:<is>(&infix:<does>, :prec($structural));

    trait_mod:<is>(&infix:<&&>, :prec($tight_and));

    trait_mod:<is>(&infix:<||>,  :prec($tight_or));
    trait_mod:<is>(&infix:<^^>,  :prec($tight_or));
    trait_mod:<is>(&infix:<//>,  :prec($tight_or));
    trait_mod:<is>(&infix:<min>, :prec($tight_or));
    trait_mod:<is>(&infix:<max>, :prec($tight_or));

    #trait_mod:<is>(&infix:<ff>,  :prec($conditional));
    #trait_mod:<is>(&infix:<fff>, :prec($conditional));

    trait_mod:<is>(&infix:<< => >>, :prec($item_assignment));

    trait_mod:<is>(&prefix:<so>,   :prec($loose_unary));
    trait_mod:<is>(&prefix:<not>,  :prec($loose_unary));

    trait_mod:<is>(&infix:<,>, :prec($comma));

    trait_mod:<is>(&infix:<Z>,      :prec($list_infix));
    trait_mod:<is>(&infix:<X>,      :prec($list_infix));
    trait_mod:<is>(&infix:<...>,    :prec($list_infix));
    trait_mod:<is>(&infix:<minmax>, :prec($list_infix));

    trait_mod:<is>(&infix:<=>,   :prec($list_prefix));
    #trait_mod:<is>(&infix:<:=>,  :prec($list_prefix));
    #trait_mod:<is>(&infix:<::=>, :prec($list_prefix));

    trait_mod:<is>(&infix:<and>,     :prec($loose_and));
    trait_mod:<is>(&infix:<andthen>, :prec($loose_and));

    trait_mod:<is>(&infix:<or>,     :prec($loose_or));
    trait_mod:<is>(&infix:<xor>,    :prec($loose_or));
    trait_mod:<is>(&infix:<orelse>, :prec($loose_or));
}

# From 'src/core/Deprecations.pm'


my %DEPRECATIONS; # where we keep our deprecation info

class Obsolete is Str {
    has $!name;
    has $!value;
    has $!instead;
    has $!from;
    has $!removed;

    submethod BUILD (:$!name, :$!value, :$!instead, :$!from, :$!removed) { }

    method Str  { DEPRECATED( $!instead, $!from, $!removed, :up(2), :what($!name) ); $!value }
    multi method gist(Obsolete:D:) { DEPRECATED( $!instead, $!from, $!removed, :up(2), :what($!name) ); $!value }
}

class Deprecation {
    has $.file;         # file of the code that is deprecated
    has $.type;         # type of code (sub/method etc.) that is deprecated
    has $.package;      # package of code that is deprecated
    has $.name;         # name of code that is deprecated
    has $.alternative;  # alternative for code that is deprecated
    has %.callsites;    # places where called (file -> line -> count)
    has Version $.from;    # release version from which deprecated
    has Version $.removed; # release version when will be removed

    multi method WHICH (Deprecation:D:) {
        ($!file||"",$!type||"",$!package||"",$!name).join(':');
    }

    proto method report (|) { * }
    multi method report (Deprecation:U:) {
        return Nil unless %DEPRECATIONS;

        my $message = "Saw {+%DEPRECATIONS} call{ 's' if +%DEPRECATIONS != 1 } to deprecated code during execution.\n";
        $message ~= ("=" x 80) ~ "\n";
        for %DEPRECATIONS.values -> $d {
            $message ~= $d.report;
            $message ~= ("-" x 80) ~ "\n";
        }

        %DEPRECATIONS = ();  # reset for new batches if applicable

        $message.chop;
    }
    multi method report (Deprecation:D:) {
        my $type    = $.type ?? "$.type " !! "";
        my $name    = $.name ?? "$.name " !! "";
        my $package = $.package ?? "(from $.package) " !! "";
        my $message = $type ~ $name ~ $package ~ "called at:\n";
        for %.callsites.kv -> $file, $lines {
            $message ~=
              "  $file, line{ 's' if +$lines > 1 } {$lines.keys.sort.join(',')}\n";
            $message ~=
              "Deprecated since v$.from, will be removed {$.removed
                ?? 'with release v' ~ $.removed ~ '!'
                !! 'sometime in the future'
              }\n" if $.from;
        }
        $message ~= "Please use $.alternative instead.\n";
        $message;
    }

    # system variable deprecations
    method obsolete (|c) { Obsolete.new(|c) }
}

sub DEPRECATED ( $alternative, $from?, $removed?, :$up = 1, :$what ) {

    # not deprecated yet
    state $version = $*PERL.compiler.version;
    my Version $vfrom;
    my Version $vremoved;
    if $from {
        $vfrom = Version.new($from);
        return if $version cmp $vfrom ~~ Less | Same; # can be better?
    }
    $vremoved = Version.new($removed) if $removed;

    my $bt = Backtrace.new;
    my $deprecated = $bt[ my $index = $bt.next-interesting-index(2, :named) ];
    my $callsite;
    $callsite = $bt[$index = $bt.next-interesting-index($index, :noproto)]
      for ^$up;

    # get object, existing or new
    my $dep = $what
      ?? Deprecation.new(
        :name($what),
        :$alternative,
        :from($vfrom),
        :removed($vremoved) )
      !! Deprecation.new(
        file    => $deprecated.file,
        type    => $deprecated.subtype.tc,
        package => try { $deprecated.package.^name } // 'unknown',
        name    => $deprecated.subname,
        :$alternative,
        :from($vfrom),
        :removed($vremoved),
    );
    $dep = %DEPRECATIONS{$dep.WHICH} //= $dep;

    # update callsite
    $dep.callsites{$callsite.file.IO}{$callsite.line}++;
}

END {
    unless %*ENV<RAKUDO_NO_DEPRECATIONS> {
        if Deprecation.report -> $message {
            note $message;   # q:to/TEXT/ doesn't work in settings
            note 'Please contact the author to have these calls to deprecated code adapted,
so that this message will disappear!

Please note that *ALL* deprecated features will be removed at the release
of Perl 6.0.0 (expected sometime in 2015).'
        }
    }
}

# From 'src/core/Thread.pm'

my class Thread {
    # The VM-level thread handle.
    has Mu $!vm_thread;

    # Is the thread's lifetime bounded by that of the application, such
    # that when it exits, so does the thread?
    has Bool $.app_lifetime;

    # Thread's (user-defined) name.
    has Str $.name;

    submethod BUILD(:&code!, Bool() :$!app_lifetime = False, Str() :$!name = "<anon>") {
        $!vm_thread := nqp::newthread(
            {
                my $*THREAD = self;
                CONTROL {
                    default {
                        my Mu $vm-ex := nqp::getattr(nqp::decont($_), Exception, '$!ex');
                        nqp::getcomp('perl6').handle-control($vm-ex);
                    }
                }
                code();
            },
            $!app_lifetime ?? 1 !! 0);
    }

    method start(Thread:U: &code, *%adverbs) {
        Thread.new(:&code, |%adverbs).run()
    }

    method run(Thread:D:) {
        nqp::threadrun($!vm_thread);
        self
    }

    method id(Thread:D:) {
        nqp::p6box_i(nqp::threadid($!vm_thread));
    }

    method finish(Thread:D:) {
        nqp::threadjoin($!vm_thread);
        self
    }

    multi method Str(Thread:D:) {
        "Thread<$.id>($.name)"
    }

    method yield(Thread:U:) {
        nqp::threadyield();
        Nil
    }
}

multi sub INITIALIZE_DYNAMIC ('$*THREAD') {
    my $init_thread := nqp::create(Thread);
    nqp::bindattr($init_thread, Thread, '$!vm_thread', nqp::currentthread());
    nqp::bindattr($init_thread, Thread, '$!app_lifetime', False);
    nqp::bindattr($init_thread, Thread, '$!name', 'Initial thread');
    PROCESS::<$THREAD> := $init_thread;
}

# From 'src/core/Lock.pm'

my class X::Lock::ConditionVariable::New is Exception {
    method message() {
        "Cannot directly create a ConditionVariable; use the 'condition' method on a lock"
    }
}
my class Lock is repr('ReentrantMutex') {
    class ConditionVariable is repr('ConditionVariable') {
        method new() {
            X::Lock::ConditionVariable::New.new.throw
        }
        method wait() { nqp::condwait(self) }
        method signal() { nqp::condsignalone(self) }
        method signal_all() { nqp::condsignalall(self) }
    }

    method lock(Lock:D:) { nqp::lock(self) }

    method unlock(Lock:D:) { nqp::unlock(self) }

    method protect(Lock:D: &code) {
        nqp::lock(self);
        my \res := code();
        nqp::unlock(self);
        CATCH { nqp::unlock(self); }
        res
    }

    method condition(Lock:D:) {
        nqp::getlockcondvar(self, ConditionVariable)
    }
}

# From 'src/core/Semaphore.pm'

my class Semaphore is repr('Semaphore') {
    method new(int $permits) {
        return nqp::box_i($permits, Semaphore);
    }
    method acquire() {
        nqp::semacquire(self);
    }
    method try_acquire() returns Bool {
        nqp::semtryacquire(self) ?? True !! False;
    }
    method release() {
        nqp::semrelease(self);
    }
}

# From 'src/core/Cancellation.pm'

my class Cancellation {
    has $.cancelled;
    has $!lock;
    has @!async_handles;

    submethod BUILD(:@!async_handles) {
        $!cancelled = False;
        $!lock      = Lock.new;
    }

    method cancel() {
        $!lock.protect({
            unless $!cancelled {
                for @!async_handles {
                    nqp::cancel(nqp::decont($_));
                }
                $!cancelled = True;
            }
        })
    }
}

# From 'src/core/Scheduler.pm'


my role Scheduler {
    has &.uncaught_handler is rw;

    method handle_uncaught($exception) {
        my $ch = &!uncaught_handler;
        if $ch {
            $ch($exception);
        }
        else {
            # No default handler, so terminate the application.
            note "Unhandled exception in code scheduled on thread " ~ $*THREAD.id;
            note $exception.gist;
            exit(1);
        }
    }

    method cue { ... }

    method loads() { ... }
}

# From 'src/core/Env.pm'

{
    my %ENV;
    my Mu $env := nqp::getenvhash();
    my Mu $enviter := nqp::iterator($env);
    my $envelem;
    my $key;
    while $enviter {
        $envelem := nqp::shift($enviter);
        $key = nqp::p6box_s(nqp::iterkey_s($envelem));
        %ENV{$key} = nqp::p6box_s(nqp::iterval($envelem));
    }
    PROCESS::<%ENV> := %ENV;
}

multi sub INITIALIZE_DYNAMIC('$*CWD') {
#    PROCESS::<$CWD> = nqp::p6box_s(nqp::cwd());
    my $CWD := nqp::p6box_s(nqp::cwd());
    PROCESS::<$CWD> = IO::Path.new($CWD, :$CWD); # need :CWD to prevent looping
}

# From 'src/core/ThreadPoolScheduler.pm'


my class ThreadPoolScheduler does Scheduler {
    # A concurrent work queue that blocks any worker threads that poll it
    # when empty until some work arrives.
    my class Queue is repr('ConcBlockingQueue') { }
    has $!queue;

    # Semaphore to ensure we don't start more than the maximum number of
    # threads allowed.
    has $!thread_start_semaphore;

    # Number of outstanding work items, used for rough management of the
    # pool size.
    has int $!loads;

    # Number of threads started so far.
    has int $!threads_started;

    # Lock protecting updates to the above 2 fields.
    has $!counts_lock;

    # If we've got incoming I/O events we need a thread to handle.
    has int $!need_io_thread;

    # Initial and maximum threads.
    has Int $.initial_threads;
    has Int $.max_threads;

    # Have we started any threads yet?
    has int $!started_any;

    # Adds a new thread to the pool, respecting the maximum.
    method !maybe_new_thread() {
        if $!thread_start_semaphore.try_acquire() {
            $!started_any = 1;
            $!counts_lock.protect: { $!threads_started = $!threads_started + 1 };
            Thread.start(:app_lifetime, {
                loop {
                    my Mu $task := nqp::shift($!queue);
                    $!counts_lock.protect: { $!loads = $!loads + 1 };
                    try {
                        if nqp::islist($task) {
                            my Mu $code := nqp::shift($task);
                            $code(|nqp::p6parcel($task, Any));
                        }
                        else {
                            $task();
                        }
                        CATCH {
                            default {
                                self.handle_uncaught($_)
                            }
                        }
                    }
                    $!counts_lock.protect: { $!loads = $!loads - 1 };
                }
            });
        }
    }

    submethod BUILD(
        Int :$!initial_threads = 0,
        Int :$!max_threads = (%*ENV<RAKUDO_MAX_THREADS> // 16).Int,
    ) {
        die "Initial thread pool threads ($!initial_threads) must be less than or equal to maximum threads ($!max_threads)"
            if $!initial_threads > $!max_threads;
    }

    method queue() {
        self!initialize unless $!started_any;
        self!maybe_new_thread();
        $!need_io_thread = 1;
        $!queue
    }

    method cue(&code, :$at, :$in, :$every, :$times = 1, :&stop, :&catch ) {
        my class TimerCancellation is repr('AsyncTask') { }
        die "Cannot specify :at and :in at the same time"
          if $at.defined and $in.defined;
        die "Cannot specify :every and :times at the same time"
          if $every.defined and $times > 1;
        my $delay = $at ?? $at - now !! $in // 0;
        self!initialize unless $!started_any;

        # need repeating
        if $every {

            # we have a stopper
            if &stop {
                my $cancellation;
                my $handle := nqp::timer($!queue,
                    &catch
                      ?? -> {
                          code();
                          $cancellation.cancel if stop();
                          CATCH { default { catch($_) } };
                      }
                      !! -> {
                          code();
                          $cancellation.cancel if stop();
                      },
                    ($delay * 1000).Int, ($every * 1000).Int,
                    TimerCancellation);
                self!maybe_new_thread() if !$!started_any;
                return
                  $cancellation = Cancellation.new(async_handles => [$handle]);
            }

            # no stopper
            else {
                my $handle := nqp::timer($!queue,
                    &catch
                      ?? -> { code(); CATCH { default { catch($_) } } }
                      !! &code,
                    ($delay * 1000).Int, ($every * 1000).Int,
                    TimerCancellation);
                self!maybe_new_thread() if !$!started_any;
                return Cancellation.new(async_handles => [$handle]);
            }
        }

        # only after waiting a bit or more than once
        elsif $delay or $times > 1 {
            my $todo := &catch
                ?? -> { code(); CATCH { default { catch($_) } } }
                !! &code;
            my @async_handles;
            for 1 .. $times {
                @async_handles.push(nqp::timer($!queue, $todo,
                    ($delay * 1000).Int, 0, TimerCancellation));
                $delay = 0;
            }
            self!maybe_new_thread() if !$!started_any;
            return Cancellation.new(:@async_handles);
        }

        # just cue the code
        else {
            my &run := &catch
               ?? -> { code(); CATCH { default { catch($_) } } }
               !! &code;
            self!maybe_new_thread() if $!loads + $!need_io_thread <= $!threads_started;
            nqp::push($!queue, &run);
            return Nil;
        }
    }

    method loads() {
        return 0 unless $!started_any;
        $!loads
    }

    method !initialize() {
        $!queue                  := nqp::create(Queue);
        $!thread_start_semaphore := Semaphore.new($!max_threads.Int);
        $!counts_lock             := nqp::create(Lock);
        self!maybe_new_thread() for 1..$!initial_threads;
    }
}

multi sub INITIALIZE_DYNAMIC('$*SCHEDULER') {
    PROCESS::<$SCHEDULER> = ThreadPoolScheduler.new();
}

# From 'src/core/CurrentThreadScheduler.pm'


my class CurrentThreadScheduler does Scheduler {

    method handle_uncaught($exception) {
        $exception.throw
    }

    method cue(&code, :$at, :$in, :$every, :$times = 1, :&catch is copy ) {
        die "Cannot specify :at and :in at the same time"
          if $at.defined and $in.defined;
        die "Cannot specify :every and :times at the same time"
          if $every.defined and $times > 1;
        die "Cannot specify :every in {self.^name}"
          if $every;

        my $delay = $at ?? $at - now !! $in;
        sleep $delay if $delay;
        &catch //=
          self.uncaught_handler // -> $ex { self.handle_uncaught($ex) };

        code() for 1 .. $times;
        CATCH { default { catch($_) } };
        class { method cancel() {} }
    }

    method loads() { 0 }
}

# From 'src/core/Promise.pm'

my enum PromiseStatus (:Planned(0), :Kept(1), :Broken(2));
my class X::Promise::Combinator is Exception {
    has $.combinator;
    method message() { "Can only use $!combinator to combine defined Promise objects" }
}
my class X::Promise::CauseOnlyValidOnBroken is Exception {
    has $.promise;
    has $.status;
    method message() { "Can only call cause on a broken promise (status: $.status)" }
}
my class X::Promise::Vowed is Exception {
    has $.promise;
    method message() { "Access denied to keep/break this Promise; already vowed" }
}
my class Promise {
    has $.scheduler;
    has $.status;
    has $!result;
    has int $!vow_taken;
    has $!lock;
    has $!cond;
    has @!thens;

    submethod BUILD(:$!scheduler = $*SCHEDULER) {
        $!lock            := nqp::create(Lock);
        $!cond            := $!lock.condition();
        $!status           = Planned;
    }

    # A Vow is used to enable the right to keep/break a promise
    # to be restricted to a given "owner". Taking the Vow for a Promise
    # prevents anybody else from getting hold of it.
    my class Vow { ... }
    trusts Vow;
    my class Vow {
        has $.promise;
        method keep(\result) {
            $!promise!Promise::keep(result)
        }
        method break(\exception) {
            $!promise!Promise::break(exception)
        }
    }
    method vow() {
        nqp::lock($!lock);
        if $!vow_taken {
            nqp::unlock($!lock);
            X::Promise::Vowed.new(promise => self).throw
        }
        my $vow := nqp::create(Vow);
        nqp::bindattr($vow, Vow, '$!promise', self);
        $!vow_taken = 1;
        nqp::unlock($!lock);
        $vow
    }

    proto method keep(|) { * }
    multi method keep(Promise:D:) {
        self.vow.keep(True)
    }
    multi method keep(Promise:D: \result) {
        self.vow.keep(result)
    }

    method !keep(\result) {
        $!lock.protect({
            $!result := result;
            $!status = Kept;
            self!schedule_thens();
            $!cond.signal_all;
        });
        $!result
    }

    proto method break(|) { * }
    multi method break(Promise:D:) {
        self.vow.break(False)
    }
    multi method break(Promise:D: \result) {
        self.vow.break(result)
    }

    method !break(\result) {
        $!lock.protect({
            $!result = nqp::istype(result, Exception)
                ?? result
                !! X::AdHoc.new(payload => result);
            $!status = Broken;
            self!schedule_thens();
            $!cond.signal_all;
        });
    }

    method !schedule_thens() {
        while @!thens {
            $!scheduler.cue(@!thens.shift, :catch(@!thens.shift))
        }
    }

    method result(Promise:D:) {
        # One important missing optimization here is that if the promise is
        # not yet started, then the work can be done immediately by the
        # thing that is blocking on it.
        if $!status == Planned {
            $!lock.protect({
                # Re-check planned to avoid data race.
                $!cond.wait() if $!status == Planned;
            });
        }
        if $!status == Kept {
            $!result
        }
        elsif $!status == Broken {
            $!result.throw
        }
    }

    multi method Bool(Promise:D:) {
        so $!status == any(Broken, Kept)
    }

    method cause(Promise:D:) {
        my $status = $!status;
        if $status == Broken {
            $!result
        } else {
            X::Promise::CauseOnlyValidOnBroken.new(
                promise => self,
                status  => $status,
            ).throw
        }
    }

    method then(Promise:D: &code) {
        nqp::lock($!lock);
        if $!status == Broken | Kept {
            # Already have the result, start immediately.
            nqp::unlock($!lock);
            Promise.start( { code(self) }, :$!scheduler);
        }
        else {
            # Create a Promise, and push 2 entries to @!thens: something that
            # starts the then code, and something that handles its exceptions.
            # They will be sent to the scheduler when this promise is kept or
            # broken.
            my $then_promise = Promise.new(:$!scheduler);
            my $vow = $then_promise.vow;
            @!thens.push({ $vow.keep(code(self)) });
            @!thens.push(-> $ex { $vow.break($ex) });
            nqp::unlock($!lock);
            $then_promise
        }
    }

    method start(Promise:U: &code, :&catch, :$scheduler = $*SCHEDULER) {
        my $p   = Promise.new(:$scheduler);
        my $vow = $p.vow;
        $scheduler.cue(
            { $vow.keep(code()) },
            :catch(-> $ex { catch($ex) if &catch; $vow.break($ex); }) );
        $p
    }

    method in(Promise:U: $seconds, :$scheduler = $*SCHEDULER) {
        my $p   = Promise.new(:$scheduler);
        my $vow = $p.vow;
        $scheduler.cue({ $vow.keep(True) }, :in($seconds));
        $p
    }

    method anyof(Promise:U: *@p) { self!until_n_kept(@p,   1, 'anyof') }
    method allof(Promise:U: *@p) { self!until_n_kept(@p, +@p, 'allof') }

    method !until_n_kept(@promises, Int $N, Str $combinator) is hidden-from-backtrace {
        X::Promise::Combinator.new(:$combinator).throw if NOT_ALL_DEFINED_TYPE(@promises, Promise);

        my int $n  = $N;
        my int $c  = $n;
        my $lock  := nqp::create(Lock);
        my $p      = Promise.new;
        my $vow    = $p.vow;
        for @promises -> $cand {
            $cand.then({
                if .status == Kept {
                    if $lock.protect({ $c = $c - 1 }) == 0 {
                        $vow.keep(True)
                    }
                }
                else {
                    if $lock.protect({ my int $o = $c; $c = $c - ($n + 1); $o }) > 0 {
                        $vow.break(.cause)
                    }
                }
            })
        }
        $p
    }
}

sub start(&code, :&catch) { Promise.start(&code, :&catch) }

# From 'src/core/Channel.pm'

my class X::Channel::SendOnClosed is Exception {
    has $.channel;
    method message() { "Cannot send a message on a closed channel" }
}
my class X::Channel::ReceiveOnClosed is Exception {
    has $.channel;
    method message() { "Cannot receive a message on a closed channel" }
}
my class Channel {
    # The queue of events moving through the channel.
    my class Queue is repr('ConcBlockingQueue') { }
    has $!queue;

    # Promise that is triggered when all values are received, or an error is
    # received and the channel is thus closed.
    has $!closed_promise;

    # Closed promise's vow.
    has $!closed_promise_vow;

    # Flag for if the channel is closed to senders.
    has $!closed;

    # Magical objects for various ways a channel can end.
    my class CHANNEL_CLOSE { }
    my class CHANNEL_FAIL  { has $.error }

    submethod BUILD() {
        $!queue := nqp::create(Queue);
        $!closed_promise = Promise.new;
        $!closed_promise_vow = $!closed_promise.vow;
    }

    method send(Channel:D: \item) {
        X::Channel::SendOnClosed.new(channel => self).throw if $!closed;
        nqp::push($!queue, nqp::decont(item));
    }

    method receive(Channel:D:) {
        my \msg := nqp::shift($!queue);
        if nqp::istype(msg, CHANNEL_CLOSE) {
            nqp::push($!queue, msg);  # make sure other readers see it
            $!closed_promise_vow.keep(Nil);
            X::Channel::ReceiveOnClosed.new(channel => self).throw
        }
        elsif nqp::istype(msg, CHANNEL_FAIL) {
            nqp::push($!queue, msg);  # make sure other readers see it
            $!closed_promise_vow.break(msg.error);
            die msg.error;
        }
        msg
    }

    method poll(Channel:D:) {
        my \msg := nqp::queuepoll($!queue);
        if nqp::isnull(msg) {
            Nil
        } else {
            if nqp::istype(msg, CHANNEL_CLOSE) {
                $!closed_promise_vow.keep(Nil);
                Nil
            }
            elsif nqp::istype(msg, CHANNEL_FAIL) {
                $!closed_promise_vow.break(msg.error);
                Nil
            }
            else {
                msg
            }
        }
    }

    method !peek(Channel:D:) {
        my \msg := nqp::atpos($!queue, 0);
        if nqp::isnull(msg) {
            Nil
        } else {
            if nqp::istype(msg, CHANNEL_CLOSE) {
                $!closed_promise_vow.keep(Nil);
                Nil
            }
            elsif nqp::istype(msg, CHANNEL_FAIL) {
                $!closed_promise_vow.break(msg.error);
                Nil
            }
            else {
                msg
            }
        }
    }

    multi method list(Channel:D $self:) {
        gather {
            loop {
                earliest $self {
                  more * { take $_ }
                  done * { last }
                }
            }
        }
    }
    multi method list(Channel:D $self: :$wait! ) {
        gather {
            loop {
                earliest $self {
                  more * { take $_ }
                  done * { last }
                  wait $wait { Nil }
                }
            }
        }
    }

    method close() {
        $!closed = 1;
        nqp::push($!queue, CHANNEL_CLOSE);
        # if $!queue is otherwise empty, make sure that $!closed_promise
        # learns about the new value
        self!peek();
        Nil
    }

    method fail($error is copy) {
        $!closed = 1;
        $error = X::AdHoc.new(payload => $error) unless nqp::istype($error, Exception);
        nqp::push($!queue, CHANNEL_FAIL.new(:$error));
        Nil
    }

    method closed() {
        self!peek();
        $!closed_promise
    }
}

# From 'src/core/Supply.pm'


my class SupplyOperations { ... }
my class X::Supply::Combinator is Exception {
    has $.combinator;
    method message() { "Can only use $!combinator to combine defined Supply objects" }
}

my class Tap {
    has &.emit;
    has &.done;
    has &.quit;
    has &.closing;
    has $.supply;

    method close (Tap:D:) { $!supply.close(self) }
}

my role Supply {
    has $!tappers_lock = Lock.new;
    has @!tappers;
    has $!been_tapped;
    has @!paused;

    method tap(Supply:D: &emit = -> $ { }, :&done,:&quit={die $_},:&closing) {
        my $tap = Tap.new(:&emit, :&done, :&quit, :&closing, :supply(self));
        $!tappers_lock.protect({
            @!tappers.push($tap);
            if @!paused -> \todo {
                $tap.emit().($_) for todo;
                @!paused = ();
            }
            $!been_tapped = True;
        });
        $tap
    }

    proto method close(|) { * }
    multi method close(Supply:D:) { self.close($_) for self.tappers }
    multi method close(Supply:D: Tap $t) {
        my $found;
        $!tappers_lock.protect({
            @!tappers .= grep( { $_ === $t ?? !($found = True) !! True } );
        });
        if $t.closing -> &closing {
            closing();
        }
        $found // False;
    }

    method tappers(Supply:D:) {
        # Shallow clone to provide safe snapshot.
        my @tappers;
        $!tappers_lock.protect({ @tappers = @!tappers });
        @tappers
    }

    method emit(Supply:D: \msg) {
        if self.tappers -> \tappers {
            .emit().(msg) for tappers;
        }
        elsif !$!been_tapped {
            $!tappers_lock.protect({ @!paused.push: msg });
        }
        Nil;
    }

    method more(Supply:D: \msg) {
        DEPRECATED('emit', |<2014.10 2015.10>);
        self.emit(msg);
    }

    method done(Supply:D:) {
        for self.tappers -> $t {
            my $l = $t.done();
            $l() if $l;
        }
        Nil;
    }

    method quit(Supply:D: $ex) {
        for self.tappers -> $t {
            my $f = $t.quit();
            $f($ex) if $f;
        }
        Nil;
    }

    method taps(Supply:D:) { +@!tappers }
    method live(Supply:D:) { True };

    method Supply(Supply:) { self }
    method Channel(Supply:D:) {
        my $c = Channel.new();
        self.tap( -> \val { $c.send(val) },
          done => { $c.close },
          quit => -> $ex { $c.quit($ex) });
        $c
    }

    method Promise(Supply:D:) {
        my $l = Lock.new;
        my $p = Promise.new;
        my $v = $p.vow;
        my $t = self.tap(
          -> \val {
              $l.protect( {
                  if $p.status == Planned {
                      $v.keep(val);
                      $t.close()
                  }
              } );
          },
          done => { $v.break("No value received") },
          quit => -> \ex {
              $l.protect( {
                  if $p.status == Planned {
                      $v.break(ex);
                      $t.close()
                  }
              } );
          },
        );
        $p
    }

    method wait(Supply:D:) {
        my $l = Lock.new;
        my $p = Promise.new;
        my $t = self.tap( -> \val {},
          done => {
              $l.protect( {
                  if $p.status == Planned {
                      $p.keep(True);
                      $t.close()
                  }
              } );
          },
          quit => -> \ex {
              $l.protect( {
                  if $p.status == Planned {
                      $p.break(ex);
                      $t.close()
                  }
              } );
          },
        );
        $p.result
    }

    method list(Supply:D:) {
        # Use a Channel to handle any asynchrony.
        self.Channel.list;
    }

    method on-demand(Supply:U: |c)       { SupplyOperations.on-demand(|c) }
    method from-list(Supply:U: |c)       { SupplyOperations.from-list(|c) }
    method interval(Supply:U: |c)        { SupplyOperations.interval(|c) }
    method flat(Supply:D: )              { SupplyOperations.flat(self) }
    method grep(Supply:D: Mu $test)      { SupplyOperations.grep(self, $test) }
    method map(Supply:D: &mapper)        { SupplyOperations.map(self, &mapper) }
    method schedule-on(Supply:D: Scheduler $scheduler) {
        SupplyOperations.schedule-on(self, $scheduler);
    }
    method start(Supply:D: &startee)     { SupplyOperations.start(self, &startee) }
    method stable(Supply:D: $time, :$scheduler = $*SCHEDULER) {
        SupplyOperations.stable(self, $time, :$scheduler);
    }
    method delay(Supply:D: $time, :$scheduler = $*SCHEDULER) {
        DEPRECATED('delayed', '2015.02', '2016.01');
        SupplyOperations.delayed(self, $time, :$scheduler);
    }
    method delayed(Supply:D: $time, :$scheduler = $*SCHEDULER) {
        SupplyOperations.delayed(self, $time, :$scheduler)
    }
    method migrate(Supply:D: )           { SupplyOperations.migrate(self) }

    multi method classify(Supply:D: &mapper )  {
        SupplyOperations.classify(self, &mapper);
    }
    multi method classify(Supply:D: %mapper )  {
        SupplyOperations.classify(self, { %mapper{$^a} });
    }
    multi method classify(Supply:D: @mapper )  {
        SupplyOperations.classify(self, { @mapper[$^a] });
    }

    proto method categorize (|) { * }
    multi method categorize(Supply:D: &mapper )  {
        SupplyOperations.classify(self, &mapper, :multi);
    }
    multi method categorize(Supply:D: %mapper )  {
        SupplyOperations.classify(self, { %mapper{$^a} }, :multi);
    }
    multi method categorize(Supply:D: @mapper )  {
        SupplyOperations.classify(self, { @mapper[$^a] }, :multi);
    }

    method act(Supply:D: &actor) {
        self.do(&actor).tap(|%_) # need "do" for serializing callbacks
    }

    method do(Supply:D $self: &side_effect) {
        on -> $res {
            $self => -> \val { side_effect(val); $res.emit(val) }
        }
    }

    method unique(Supply:D $self: :&as, :&with, :$expires) {
        on -> $res {
            $self => do {
                if $expires {
                    if &with and &with !=== &[===] {
                        my @seen;  # really Mu, but doesn't work in settings
                        my Mu $target;
                        &as
                          ?? -> \val {
                              my $now := now;
                              $target = &as(val);
                              my $index =
                                @seen.first-index({&with($target,$_[0])});
                              if $index.defined {
                                  if $now > @seen[$index][1] {  # expired
                                      @seen[$index][1] = $now+$expires;
                                      $res.emit(val);
                                  }
                              }
                              else {
                                  @seen.push: [$target, $now+$expires];
                                  $res.emit(val);
                              }
                          }
                          !! -> \val {
                              my $now := now;
                              my $index =
                                @seen.first-index({&with(val,$_[0])});
                              if $index.defined {
                                  if $now > @seen[$index][1] {  # expired
                                      @seen[$index][1] = $now+$expires;
                                      $res.emit(val);
                                  }
                              }
                              else {
                                  @seen.push: [val, $now+$expires];
                                  $res.emit(val);
                              }
                          };
                    }
                    else {
                        my $seen := nqp::hash();
                        my str $target;
                        &as
                          ?? -> \val {
                              my $now := now;
                              $target = nqp::unbox_s(&as(val).WHICH);
                              if !nqp::existskey($seen,$target) ||
                                $now > nqp::atkey($seen,$target) { #expired
                                  $res.emit(val);
                                  nqp::bindkey($seen,$target,$now+$expires);
                              }
                          }
                          !! -> \val {
                              my $now := now;
                              $target = nqp::unbox_s(val.WHICH);
                              if !nqp::existskey($seen,$target) ||
                                $now > nqp::atkey($seen,$target) { #expired
                                  $res.emit(val);
                                  nqp::bindkey($seen,$target,$now+$expires);
                              }
                          };
                    }
                }
                else { # !$!expires
                    if &with and &with !=== &[===] {
                        my @seen;  # really Mu, but doesn't work in settings
                        my Mu $target;
                        &as
                          ?? -> \val {
                              $target = &as(val);
                              if @seen.first({ &with($target,$_) } ) =:= Nil {
                                  @seen.push($target);
                                  $res.emit(val);
                              }
                          }
                          !! -> \val {
                              if @seen.first({ &with(val,$_) } ) =:= Nil {
                                  @seen.push(val);
                                  $res.emit(val);
                              }
                          };
                    }
                    else {
                        my $seen := nqp::hash();
                        my str $target;
                        &as
                          ?? -> \val {
                              $target = nqp::unbox_s(&as(val).WHICH);
                              unless nqp::existskey($seen, $target) {
                                  nqp::bindkey($seen, $target, 1);
                                  $res.emit(val);
                              }
                          }
                          !! -> \val {
                              $target = nqp::unbox_s(val.WHICH);
                              unless nqp::existskey($seen, $target) {
                                  nqp::bindkey($seen, $target, 1);
                                  $res.emit(val);
                              }
                          };
                    }
                }
            }
        }
    }

    method squish(Supply:D $self: :&as, :&with is copy) {
        &with //= &[===];
        on -> $res {
            my @secret;
            $self => do {
                my Mu $last = @secret;
                my Mu $target;
                &as
                  ?? -> \val {
                      $target = &as(val);
                      unless &with($target,$last) {
                          $last = $target;
                          $res.emit(val);
                      }
                  }
                  !! -> \val {
                      unless &with(val,$last) {
                          $last = val;
                          $res.emit(val);
                      }
                  };
            }
        }
    }

    method rotor(Supply:D $self: $elems? is copy, $overlap? is copy ) {

        $elems   //= 2;
        $overlap //= 1;
        return $self if $elems == 1 and $overlap == 0;  # nothing to do

        on -> $res {
            $self => do {
                my @batched;
                sub flush {
                    $res.emit( [@batched] );
                    @batched.splice( 0, +@batched - $overlap );
                }

                {
                    emit => -> \val {
                        @batched.push: val;
                        flush if @batched.elems == $elems;
                    },
                    done => {
                        flush if @batched;
                        $res.done;
                    }
                }
            }
        }
    }

    method batch(Supply:D $self: :$elems, :$seconds ) {

        return $self if (!$elems or $elems == 1) and !$seconds;  # nothing to do

        on -> $res {
            $self => do {
                my @batched;
                my $last_time;
                sub flush {
                    $res.emit([@batched]);
                    @batched = ();
                }

                {
                    emit => do {
                        if $seconds {
                            $last_time = time div $seconds;

                            $elems # and $seconds
                              ??  -> \val {
                                  my $this_time = time div $seconds;
                                  if $this_time != $last_time {
                                      flush if @batched;
                                      $last_time = $this_time;
                                      @batched.push: val;
                                  }
                                  else {
                                      @batched.push: val;
                                      flush if @batched.elems == $elems;
                                  }
                              }
                              !! -> \val {
                                  my $this_time = time div $seconds;
                                  if $this_time != $last_time {
                                      flush if @batched;
                                      $last_time = $this_time;
                                  }
                                  @batched.push: val;
                              }
                        }
                        else { # just $elems
                            -> \val {
                                @batched.push: val;
                                flush if @batched.elems == $elems;
                            }
                        }
                    },
                    done => {
                        flush if @batched;
                        $res.done;
                    }
                }
            }
        }
    }

    method lines(Supply:D $self: :$chomp = True ) {

        on -> $res {
            $self => do {
                my str $str;
                my int $chars;
                my int $left;
                my int $pos;
                my int $nextpos;
                my int $found;
                my int $cr;
                my int $crlf;

                {
                    emit => -> \val {
                        $str   = $str ~ nqp::unbox_s(val);
                        $chars = nqp::chars($str);
                        $pos   = 0;

                        while ($left = $chars - $pos) > 0 {
                            $nextpos = nqp::findcclass(
                              nqp::const::CCLASS_NEWLINE, $str, $pos, $left
                            );

                            # no trailing line delimiter, so go buffer
                            last unless nqp::iscclass(
                              nqp::const::CCLASS_NEWLINE, $str, $nextpos
                            );

                            # potentially broken CRLF, so go buffer
                            $cr = nqp::ordat($str, $nextpos) == 13;    # CR
                            last if $cr == 1 and $nextpos + 1 == $chars;

                            $crlf = $cr
                              && nqp::ordat($str, $nextpos + 1) == 10; # LF

                            if $chomp {
                                $res.emit( ($found = $nextpos - $pos)
                                  ?? nqp::box_s(
                                       nqp::substr($str, $pos, $found), Str)
                                  !! ''
                                );
                                $pos = $nextpos + 1 + $crlf;
                            }
                            else {
                                $found = $nextpos - $pos + 1 + $crlf;
                                $res.emit( nqp::box_s(
                                  nqp::substr($str, $pos, $found), Str)
                                );
                                $pos = $pos + $found;
                            }
                        }
                        $str = $pos < $chars
                          ?? nqp::substr($str,$pos)
                          !! '';
                    },
                    done => {
                        if $str {
                            $chars = nqp::chars($str);
                            $res.emit( $chomp
                              && nqp::ordat($str, $chars - 1) == 13    # CR
                              ?? nqp::box_s(nqp::substr($str,0,$chars - 1),Str)
                              !! nqp::box_s($str, Str)
                            );
                        }
                        $res.done;
                    }
                }
            }
        }
    }

    method words(Supply:D $self:) {

        on -> $res {
            $self => do {
                my str $str;
                my int $chars;
                my int $left;
                my int $pos;
                my int $nextpos;
                my int $found;
                my int $cr;
                my int $crlf;

                {
                    emit => -> \val {
                        $str   = $str ~ nqp::unbox_s(val);
                        $chars = nqp::chars($str);
                        $pos   = nqp::findnotcclass(
                          nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);

                        while ($left = $chars - $pos) > 0 {
                            $nextpos = nqp::findcclass(
                              nqp::const::CCLASS_WHITESPACE, $str, $pos, $left
                            );

                            last unless $left = $chars - $nextpos; # broken word

                            $res.emit( nqp::box_s(
                              nqp::substr( $str, $pos, $nextpos - $pos ), Str)
                            );

                            $pos = nqp::findnotcclass(
                              nqp::const::CCLASS_WHITESPACE,$str,$nextpos,$left);
                        }
                        $str = $pos < $chars
                          ?? nqp::substr($str,$pos)
                          !! '';
                    },
                    done => {
                        $res.emit( nqp::box_s($str, Str) ) if $str;
                        $res.done;
                    }
                }
            }
        }
    }

    method elems(Supply:D $self: $seconds? ) {

        on -> $res {
            $self => do {
                my $elems = 0;
                my $last_time;
                my $last_elems;

                {
                    emit => do {
                        if $seconds {
                            $last_time  = time div $seconds;
                            $last_elems = $elems;
                            -> \val {
                                  $last_elems = ++$elems;
                                  my $this_time = time div $seconds;
                                  if $this_time != $last_time {
                                      $res.emit($elems);
                                      $last_time = $this_time;
                                  }
                            }
                        }
                        else {
                            -> \val { $res.emit(++$elems) }
                        }
                    },
                    done => {
                        $res.emit($elems) if $seconds and $elems != $last_elems;
                        $res.done;
                    }
                }
            }
        }
    }

    method last(Supply:D $self: Int $number = 1) {  # should be Natural
        on -> $res {
            $self => do {
                my @seen;
                {
                    emit => $number == 1
                      ?? -> \val { @seen[0] = val }
                      !! -> \val {
                          @seen.shift if +@seen == $number;
                          @seen.push: val;
                      },
                    done => {
                        $res.emit($_) for @seen;
                        $res.done;
                    }
                }
            }
        }
    }

    method min(Supply:D $self: &by = &infix:<cmp>) {
        my &cmp = &by.arity == 2 ?? &by !! { by($^a) cmp by($^b) }
        on -> $res {
            $self => do {
                my $min;
                {
                    emit => -> \val {
                        if val.defined and !$min.defined || cmp(val,$min) < 0 {
                            $res.emit( $min = val );
                        }
                    },
                    done => { $res.done }
                }
            }
        }
    }

    method max(Supply:D $self: &by = &infix:<cmp>) {
        my &cmp = &by.arity == 2 ?? &by !! { by($^a) cmp by($^b) }
        on -> $res {
            $self => do {
                my $max;
                {
                    emit => -> \val {
                        if val.defined and !$max.defined || cmp(val,$max) > 0 {
                            $res.emit( $max = val );
                        }
                    },
                    done => { $res.done }
                }
            }
        }
    }

    method minmax(Supply:D $self: &by = &infix:<cmp>) {
        my &cmp = &by.arity == 2 ?? &by !! { by($^a) cmp by($^b) }
        on -> $res {
            $self => do {
                my $min;
                my $max;
                {
                    emit => -> \val {
                        if val.defined {
                            if !$min.defined {
                                $res.emit( Range.new($min = val, $max = val) );
                            }
                            elsif cmp(val,$min) < 0 {
                                $res.emit( Range.new( $min = val, $max ) );
                            }
                            elsif cmp(val,$max) > 0 {
                                $res.emit( Range.new( $min, $max = val ) );
                            }
                        }
                    },
                    done => { $res.done }
                }
            }
        }
    }

    method reduce(Supply:D $self: &with) {
        on -> $res {
            $self => do {
                my $notfirst;
                my $reduced;
                {
                    emit => -> \val {
                        $reduced = $notfirst ?? with($reduced,val) !! val;
                        $res.emit($reduced);
                        once $notfirst = True;
                    },
                    done => { $res.done }
                }
            }
        }
    }

    method grab(Supply:D $self: &when_done) {
        on -> $res {
            $self => do {
                my @seen;
                {
                    emit => -> \val { @seen.push: val },
                    done => {
                        $res.emit($_) for when_done(@seen);
                        $res.done;
                    }
                }
            }
        }
    }

    method reverse(Supply:D:)                 { self.grab( {.reverse} ) }
    method sort(Supply:D: &by = &infix:<cmp>) { self.grab( {.sort(&by)} ) }

    method merge(*@s) {
        @s.unshift(self) if self.DEFINITE;  # add if instance method
        return Supply unless +@s;           # nothing to be done

        X::Supply::Combinator.new(
           combinator => 'merge'
        ).throw if NOT_ALL_DEFINED_TYPE(@s,Supply);

        return @s[0]  if +@s == 1;          # nothing to be done

        my $dones = 0;
        on -> $res {
            @s => {
                emit => -> \val { $res.emit(val) },
                done => { $res.done() if ++$dones == +@s }
            },
        }
    }

    method zip(*@s, :&with is copy = &[,]) {
        @s.unshift(self) if self.DEFINITE;  # add if instance method
        return Supply unless +@s;           # nothing to be done

        X::Supply::Combinator.new(
           combinator => 'zip'
        ).throw if NOT_ALL_DEFINED_TYPE(@s,Supply);

        return @s[0]  if +@s == 1;          # nothing to be done

        my @values = ( [] xx +@s );
        on -> $res {
            @s => -> $val, $index {
                @values[$index].push($val);
                if all(@values) {
                    $res.emit( [[&with]] @values>>.shift );
                }
            }
        }
    }

    method zip-latest(*@s, :&with is copy = &[,], :$initial ) {
        @s.unshift(self) if self.DEFINITE;  # add if instance method
        return Supply unless +@s;           # nothing to do.

        X::Supply::Combinator.new(
           combinator => 'zip-latest'
        ).throw if NOT_ALL_DEFINED_TYPE(@s,Supply);

        return @s[0] if +@s == 1;           # nothing to do.

        my @values;

        my $uninitialised = +@s; # how many supplies have yet to emit until we
                                 # can start emitting, too?

        if $initial {
            @values = @$initial;
            $uninitialised = 0 max $uninitialised - @$initial;
        }

        my $dones = 0;

        on -> $res {
            @s => do {
                {
                emit => -> $val, $index {
                    if $uninitialised > 0 && not @values.EXISTS-POS($index) {
                        --$uninitialised;
                    }
                    @values[$index] = $val;
                    unless $uninitialised {
                        $res.emit( [[&with]] @values );
                    }
                },
                done => { $res.done() if ++$dones == +@s }
                }
            }
        }
    }

    method for(Supply:U: |c) {
        DEPRECATED('from-list',|<2015.01 2016.01>);
        SupplyOperations.from-list(|c);
    }
    method on_demand(Supply:U: |c)       {
        DEPRECATED('on-demand',|<2015.03 2016.03>);
        SupplyOperations.on-demand(|c);
    }
    method schedule_on(Supply:D: Scheduler $scheduler) {
        DEPRECATED('schedule-on',|<2015.03 2016.03>);
        SupplyOperations.schedule-on(self, $scheduler);
    }
    method uniq(Supply:D: |c) {
        DEPRECATED('unique', |<2014.11 2015.11>);
        self.unique(|c);
    }
}

my class X::Supply::On::BadSetup is Exception {
    method message() {
        "on requires a callable that returns a list of pairs with Supply keys"
    }
}
my class X::Supply::On::NoEmit is Exception {
    method message() {
        "on requires that emit be specified for each supply"
    }
}
sub on(&setup) {
    my class OnSupply does Supply {
        has &!setup;
        has Bool $!live = False;

        submethod BUILD(:&!setup) { }

        method !add_source(
          $source, $lock, $index, :&done is copy, :&quit is copy,
          :&emit is copy, :&more   # more deprecated, emit must be changeable
        ) {
            DEPRECATED('emit => {...}', |<2014.10 2015.10>) if &more;
            $!live ||= True if $source.live;
            &emit //= &more // X::Supply::On::NoEmit.new.throw;
            &done //= { self.done };
            &quit //= -> $ex { self.quit($ex) };

            my &tap_emit = &emit.arity == 2
              ?? -> \val {
                  $lock.protect({ emit(val,$index) });
                  CATCH { default { self.quit($_) } }
              }
              !!  -> \val {
                  $lock.protect({ emit(val) });
                  CATCH { default { self.quit($_) } }
              };

            my &tap_done = &done.arity == 1
              ?? {
                  $lock.protect({ done($index) });
                  CATCH { default { self.quit($_) } }
              }
              !! {
                  $lock.protect({ done() });
                  CATCH { default { self.quit($_) } }
              };

            my &tap_quit = &quit.arity == 2
              ?? -> $ex {
                  $lock.protect({ quit($ex,$index) });
                  CATCH { default { self.quit($_) } }
              }
              !! -> $ex {
                  $lock.protect({ quit($ex) });
                  CATCH { default { self.quit($_) } }
              };

            $source.tap( &tap_emit, done => &tap_done, quit => &tap_quit );
        }

        method live { $!live }
        method tap(|c) {
            my @to_close;
            my $sub = self.Supply::tap( |c, closing => {.close for @to_close});
            my @tappers = &!setup(self);
            my $lock    = Lock.new;

            sub add ($source, $what, $index?) {
                unless nqp::istype($source,Supply) {
                    X::Supply::On::BadSetup.new.throw;
                }
                given $what {
                    when EnumMap {
                        @to_close.push(self!add_source($source, $lock, $index, |$what));
                    }
                    when Callable {
                        @to_close.push(self!add_source($source, $lock, $index, emit => $what));
                    }
                    default {
                        X::Supply::On::BadSetup.new.throw;
                    }
                }
            }

            for @tappers -> $tap {
                unless nqp::istype($tap,Pair) {
                    X::Supply::On::BadSetup.new.throw;
                }
                given $tap.key {
                    when Positional {
                        my $todo := $tap.value;
                        for .list.kv -> $index, $supply {
                            add( $supply, $todo, $index );
                        }
                    }
                    when Supply {
                        add( $_, $tap.value );
                    }
                    default {
                        X::Supply::On::BadSetup.new.throw;
                    }
                }
            }
            $sub
        }

        method emit(\msg) {
            for self.tappers {
                .emit().(msg)
            }
            Nil;
        }

        method done() {
            for self.tappers {
                if .done -> $l { $l() }
            }
            Nil;
        }

        method quit($ex) {
            for self.tappers {
                if .quit -> $t { $t($ex) }
            }
            Nil;
        }
    }

    OnSupply.new(:&setup)
}

# From 'src/core/SupplyOperations.pm'


my class X::Supply::Migrate::Needs is Exception {
    method message() {
        ".migrate needs Supplies to be emitted"
    }
}

my class SupplyOperations is repr('Uninstantiable') {

    # Private versions of the methods to relay events to subscribers, used in
    # implementing various operations.
    my role PrivatePublishing {
        method !emit(\msg) {
            for self.tappers {
                .emit().(msg)
            }
            Nil;
        }

        method !done() {
            for self.tappers {
                if .done { .done().() }
            }
            Nil;
        }

        method !quit($ex) {
            for self.tappers {
                if .quit { .quit().($ex) }
            }
            Nil;
        }
    }

    method on-demand(&producer, :&closing, :$scheduler = CurrentThreadScheduler) {
        my class OnDemandSupply does Supply {
            has &!producer;
            has &!closing;
            has $!scheduler;

            submethod BUILD(:&!producer!, :&!closing!, :$!scheduler!) {}

            method live { False }
            method tap(|c) {
                my $closed = False;
                my $close_action;
                my $sub = self.Supply::tap(|c, closing => {
                    $closed = True;
                    &!closing && &!closing();
                });
                $!scheduler.cue(
                    {
                        my $s = Supply.new;
                        $s.tap(
                            -> \val { $sub.emit().(val) },
                            done => { if !$closed && $sub.done -> $t { $t() } },
                            quit => -> $ex { if !$closed && $sub.quit -> $t { $t($ex) } }
                        );
                        &!producer($s)
                    },
                    :catch(-> $ex { if !$closed && $sub.quit -> $t { $t($ex) } })
                );
                $sub
            }
        }
        OnDemandSupply.new(:&producer, :&closing, :$scheduler)
    }

    method from-list(*@values, :$scheduler = CurrentThreadScheduler) {
        my class FromListSupply does Supply {
            has @!values;
            has $!scheduler;

            submethod BUILD(:@!values, :$!scheduler) {}

            method live { False }
            method tap(|c) {
                my $closed = False;
                my $sub = self.Supply::tap(|c, closing => { $closed = True });
                $!scheduler.cue(
                    {
                        for @!values -> \val {
                            last if $closed;
                            $sub.emit().(val);
                        }
                        if !$closed && $sub.done -> $l { $l() }
                    },
                    :catch(-> $ex { if !$closed && $sub.quit -> $t { $t($ex) } })
                );
                $sub
            }
        }
        FromListSupply.new(:@values, :$scheduler)
    }

    method interval($interval, $delay = 0, :$scheduler = $*SCHEDULER) {
        my class IntervalSupply does Supply {
            has $!scheduler;
            has $!interval;
            has $!delay;

            submethod BUILD(:$!scheduler, :$!interval, :$!delay) {}

            method live { False }
            method tap(|c) {
                my $cancellation;
                my $sub = self.Supply::tap(|c, closing => { $cancellation.cancel() });
                $cancellation = $!scheduler.cue(
                    {
                        state $i = 0;
                        $sub.emit().($i++);
                    },
                    :every($!interval), :in($!delay)
                );
                $sub
            }
        }
        IntervalSupply.new(:$interval, :$delay, :$scheduler)
    }

    method flat(Supply $source) {
        my class FlatSupply does Supply does PrivatePublishing {
            has $!source;

            submethod BUILD(:$!source) { }

            method live { $source.live }
            method tap(|c) {
                my $source_tap;
                my $tap = self.Supply::tap(|c, closing => {$source_tap.close});
                $source_tap = $!source.tap( -> \val {
                      $tap.emit().(val.flat)
                  },
                  done => { if $tap.done { $tap.done().() } },
                  quit => -> $ex { if $tap.quit { $tap.quit().($ex) } });
                $tap
            }
        }
        FlatSupply.new(:$source)
    }

    method grep(Supply $source, Mu $test) {
        my class GrepSupply does Supply does PrivatePublishing {
            has $!source;
            has Mu $!test;

            submethod BUILD(:$!source, :$!test) { }

            method live { $source.live }
            method tap(|c) {
                my $source_tap;
                my $tap = self.Supply::tap(|c, closing => {$source_tap.close});
                $source_tap = $!source.tap( $!test.DEFINITE
                  ?? nqp::istype($!test,Callable)
                    ?? nqp::istype($!test,Regex)
                       ?? -> \val { $tap.emit().(val) if val.match($!test) }
                       !! -> \val { $tap.emit().(val) if $!test(val) }
                    !! -> \val { $tap.emit().(val) if val ~~ $!test }
                  !! -> \val { $tap.emit().(val) if val ~~ $!test },
                  done => { if $tap.done { $tap.done().() } },
                  quit => -> $ex { if $tap.quit { $tap.quit().($ex) } }
                );
                $tap
            }
        }
        GrepSupply.new(:$source, :$test)
    }

    method map(Supply $source, &mapper) {
        my class MapSupply does Supply does PrivatePublishing {
            has $!source;
            has &!mapper;

            submethod BUILD(:$!source, :&!mapper) { }

            method live { $source.live }
            method tap(|c) {
                my $source_tap;
                my $tap = self.Supply::tap(|c, closing => {$source_tap.close});
                $source_tap = $!source.tap( -> \val {
                      $tap.emit().(&!mapper(val))
                  },
                  done => { if $tap.done { $tap.done().() } },
                  quit => -> $ex { if $tap.quit { $tap.quit().($ex) } });
                $tap
            }
        }
        MapSupply.new(:$source, :&mapper)
    }

    method schedule-on(Supply $source, Scheduler $scheduler) {
        my class ScheduleSupply does Supply does PrivatePublishing {
            has $!source;
            has $!scheduler;

            submethod BUILD(:$!source, :$!scheduler) { }

            method live { $source.live }
            method tap(|c) {
                my $source_tap;
                my $tap = self.Supply::tap(|c, closing => {$source_tap.close});
                $source_tap = $!source.tap( -> \val {
                      $!scheduler.cue: { $tap.emit().(val) }
                  },
                  done => { $!scheduler.cue: { if $tap.done { $tap.done().() } } },
                  quit => -> $ex { if $tap.quit { $tap.quit().($ex) } });
                $tap
            }
        }
        ScheduleSupply.new(:$source, :$scheduler)
    }

    method start(Supply $s, &startee) {
        my class StartSupply does Supply does PrivatePublishing {
            has $!value;
            has &!startee;

            submethod BUILD(:$!value, :&!startee) { }

            method live { $s.live }
            method tap(|c) {
                my $sub = self.Supply::tap(|c);
                Promise.start({ &!startee($!value) }).then({
                    if .status == Kept {
                        self!emit(.result);
                        self!done();
                    }
                    else {
                        self!quit(.cause);
                    }
                });
                $sub
            }
        }
        self.map($s, -> \value {
            StartSupply.new(:value(value), :&startee)
        })
    }

    method stable(Supply $source, $time, :$scheduler = $*SCHEDULER) {

        return $source if !$time;  # nothing to do

        my class StableSupply does Supply does PrivatePublishing {
            has $!source;
            has $!time;
            has $!scheduler;
            has $!lock;
            has $!last_cancellation;

            submethod BUILD(:$!source, :$!time, :$!scheduler) {
                $!lock = Lock.new;
            }

            method live { $source.live }
            method tap(|c) {
                my $source_tap;
                my $tap = self.Supply::tap(|c, closing => {$source_tap.close});
                $source_tap = $!source.tap(
                    -> \val {
                        $!lock.protect({
                            if $!last_cancellation {
                                $!last_cancellation.cancel;
                            }
                            $!last_cancellation = $!scheduler.cue(
                                :in($time),
                                {
                                    $!lock.protect({
                                        $!last_cancellation = Nil;
                                    });
                                    $tap.emit().(val);
                                });
                        });
                    },
                    done => { if $tap.done { $tap.done().() } },
                    quit => -> $ex { if $tap.quit { $tap.quit().($ex) } });
                $tap
            }
        }
        StableSupply.new(:$source, :$time, :$scheduler);
    }

    method delayed(Supply $source, $time, :$scheduler = $*SCHEDULER) {

        return $source if !$time;  # nothing to do

        my class DelayedSupply does Supply does PrivatePublishing {
            has $!source;
            has $!time;
            has $!scheduler;

            submethod BUILD(:$!source, :$!time, :$!scheduler) { }

            method live { $source.live }
            method tap(|c) {
                my $source_tap;
                my $tap = self.Supply::tap(|c, closing => {$source_tap.close});
                $source_tap = $!source.tap(
                    -> \val {
                        $!scheduler.cue( { $tap.emit().(val) }, :in($time) );
                    },
                    done => {
                        $!scheduler.cue( { if $tap.done { $tap.done().() } }, :in($time) );
                    },
                    quit => -> $ex {
                        $!scheduler.cue( { if $tap.quit { $tap.quit().($ex) } }, :in($time) );
                    } );
                $tap
            }
        }
        DelayedSupply.new(:$source, :$time, :$scheduler);
    }

    method migrate(Supply $source) {
        my class MigrateSupply does Supply does PrivatePublishing {
            has $!source;
            has $!current;
            has $!lock;

            submethod BUILD(:$!source) {
                $!lock = Lock.new;
            }

            method live { $source.live }
            method tap(|c) {
                my $source_tap;
                my $tap = self.Supply::tap(|c, closing => {$source_tap.close});
                $source_tap = $!source.tap(
                    -> \inner_supply {
                        X::Supply::Migrate::Needs.new.throw
                          unless nqp::istype(inner_supply,Supply);
                        $!lock.protect({
                            $!current.close() if $!current;
                            $!current = inner_supply.tap(-> \val {
                                $tap.emit().(val);
                            });
                        });
                    },
                    done => { if $tap.done { $tap.done().() } },
                    quit => -> $ex { if $tap.quit { $tap.quit().($ex) } });
                $tap
            }
        }
        MigrateSupply.new(:$source)
    }

    method classify(Supply $source, &mapper, :$multi ) {
        my class ClassifySupply does Supply does PrivatePublishing {
            has $!source;
            has %!mapping;

            submethod BUILD(:$!source) { }
            submethod find_supply ($key) {
                %!mapping{ $key.WHICH } //= do {
                    my $s = Supply.new;
                    self!emit($key => $s);
                    $s;
                };
            }

            method !classify-done() {
                %!mapping.values>>.done;
                self!done;
            }

            method live { $source.live }
            method tap(|c) {
                my $source_tap;
                my $tap = self.Supply::tap(|c, closing => {$source_tap.close});
                $source_tap = $!source.tap( $multi
                  ?? -> \val {
                      for @(mapper(val)) -> $key {
                          self.find_supply($key).emit(val);
                      }
                  }
                  !! -> \val {
                      self.find_supply( mapper(val) ).emit(val);
                  },
                  done => { self!classify-done(); },
                  quit => -> $ex { self!quit($ex) });
                $tap
            }
        }
        ClassifySupply.new(:$source)
    }
}

# From 'src/vm/jvm/core/KeyReducer.pm'

my class X::KeyReducer::ResultObtained is Exception {
    method message() { "Cannot contribute to a KeyReducer after the result has been obtained" }
}
my class KeyReducer {
    has $!initializer;
    has $!reducer;
    has %!result;
    has Mu $!lock;
    has $!exception;
    has $!obtained;
    
    method new($initializer, $reducer) {
        self.bless(:$initializer, :$reducer)
    }
    
    my Mu $interop;
    my Mu $ReentrantLock;
    submethod BUILD(:$!initializer, :$!reducer) {
        unless nqp::isconcrete($interop) {
            $interop := nqp::jvmbootinterop();
            $ReentrantLock := $interop.typeForName('java.util.concurrent.locks.ReentrantLock');
        }
        $!lock := $ReentrantLock.'constructor/new/()V'();
        $!obtained = False;
    }
    
    proto method contribute(|) { * }
    multi method contribute(KeyReducer:D: %h) {
        $!lock.lock();
        if $!exception {
            $!lock.unlock();
            return False;
        }
        if $!obtained {
            $!lock.unlock();
            X::KeyReducer::ResultObtained.new.throw
        }
        try {
            for %h.kv -> $k, $v {
                %!result{$k} = %!result.exists($k)
                    ?? $!reducer(%!result{$k}, $v)
                    !! $!initializer($v)
            }
            CATCH { default { $!exception := $_ } }
        }
        $!lock.unlock();
        True
    }
    multi method contribute(KeyReducer:D: Pair $p) {
        $!lock.lock();
        if $!exception {
            $!lock.unlock();
            return False;
        }
        if $!obtained {
            $!lock.unlock();
            X::KeyReducer::ResultObtained.new.throw
        }
        try {
            %!result{$p.key} = %!result.exists($p.key)
                    ?? $!reducer(%!result{$p.key}, $p.value)
                    !! $!initializer($p.value);
            CATCH { default { $!exception := $_ } }
        }
        $!lock.unlock();
        True
    }
    
    method snapshot(KeyReducer:D:) {
        $!lock.lock();
        if $!exception {
            $!lock.unlock();
            $!exception.throw;
        }
        my %snapshot = %!result;
        $!lock.unlock();
        %snapshot
    }
    
    method result(KeyReducer:D:) {
        $!lock.lock();
        $!obtained = True;
        $!lock.unlock();
        $!exception ?? $!exception.throw !! %!result
    }
}
# From 'src/vm/jvm/core/IOAsyncFile.pm'

my class IO::Async::File {
    has $!PIO;
    has $.chomp = Bool::True;
    has $.path;
    
    proto method open(|) { * }
    multi method open($path? is copy, :$r, :$w, :$a, :$bin, :$chomp = Bool::True,
            :enc(:$encoding) = 'utf8') {
        $path //= $!path;
        my $mode = $w ?? 'w' !! ($a ?? 'wa' !! 'r' );
        nqp::bindattr(self, IO::Async::File, '$!PIO',
             nqp::openasync(nqp::unbox_s($path.Str), nqp::unbox_s($mode))
        );
        $!path = $path;
        $!chomp = $chomp;
        nqp::setencoding($!PIO, NORMALIZE_ENCODING($encoding)) unless $bin;
        self;
    }

    method close() {
        nqp::closefh($!PIO);
        Bool::True;
    }
    
    method opened() {
        nqp::p6bool(nqp::istrue($!PIO));
    }
    
    method slurp(IO::Async::File:D: :$bin, :enc($encoding)) {
        self.open(:r, :$bin) unless self.opened;
        self.encoding($encoding) if $encoding.defined;

        if $bin {
            die "Asynchronous binary file reading NYI"
        }
        else {
            my $p = Promise.new;
            nqp::slurpasync($!PIO, Str,
                -> $str { $p.keep($str); self.close(); },
                -> $msg { $p.break($msg); try self.close(); });
            $p
        }
    }
    
    method spurt(IO::Async::File:D: $data, :$bin, :enc($encoding)) {
        self.open(:w, :$bin) unless self.opened;
        self.encoding($encoding) if $encoding.defined;

        if $bin {
            die "Asynchronous binary file writing NYI"
        }
        else {
            my $p = Promise.new;
            nqp::spurtasync($!PIO, Str, $data,
                -> { $p.keep(1); self.close(); },
                -> $msg { $p.break($msg); try self.close(); });
            $p
        }
    }

    method lines(:enc($encoding)) {
        self.open(:r) unless self.opened;
        self.encoding($encoding) if $encoding.defined;

        my $c := Channel.new;
        nqp::linesasync($!PIO, Str, $.chomp ?? 1 !! 0,
            nqp::getattr($c, Channel, '$!queue'),
            -> { $c.close(); self.close() },
            -> $msg { $c.fail($msg); try self.close(); });
        $c
    }
}
# From 'src/core/asyncops.pm'


proto sub await(|) { * }
multi sub await(Promise:D $p) {
    $p.result
}
multi sub await(*@awaitables) {
    @awaitables.eager.map(&await)
}
multi sub await(Channel:D $c) {
    $c.receive
}

sub cas (\val,&code) { val = code(val) } # naive implementation of cas

sub INVOKE_KV(&block, $key, $value?) {

    my @names = map *.name, &block.signature.params;

    if @names eqv ['$k', '$v'] || @names eqv ['$v', '$k'] {
        return &block(:k($key), :v($value));
    }
    elsif @names eqv ['$_'] || (+@names == 1 && &block.signature.params[0].positional)  {
        return &block($value);
    }
    elsif @names eqv ['$k'] {
        return &block(:k($key));
    }
    elsif @names eqv ['$v'] {
        return &block(:v($value));
    }
    elsif +@names == 0 {
        return &block();
    }

    die "Couldn't figure out how to invoke {&block.signature().perl}";
}

sub EARLIEST(@earliest,*@other,:$wild_done,:$wild_more,:$wait,:$wait_time) {
    my Num $until = $wait ?? nqp::time_n() + $wait_time !! Nil;

    my constant $EARLIEST_KIND_DONE = 0;
    my constant $EARLIEST_KIND_MORE = 1;

    my @todo;
#       |-- [ ordinal, kind, contestant, block, alternate_block? ]
    my %distinct-channels;

    # sanity check and transmogrify possibly multiple channels into things to do
    while +@other {
        my $kind = @other.shift;
        if $kind != $EARLIEST_KIND_DONE && $kind != $EARLIEST_KIND_MORE {
            die "Got a {$kind.WHAT.perl}, but expected $EARLIEST_KIND_DONE or $EARLIEST_KIND_MORE";
        }

        my @contestant;
        while !nqp::istype(@other[0],Block) {
            my $next := @other.shift;
            if !nqp::istype($next,Channel) {
                die "Got a {$next.WHAT.perl}, but expected a Channel";
            }
            @contestant.push: $next;
        }
        my &block = @other.shift;

        for @contestant {
            %distinct-channels{$_.WHICH} = $_;
            @todo.push: [ +@todo, $kind, $_, &block ];
        }
    }

    # transmogrify any earliest spec if nothing to do so far
    if !@todo {
        for @earliest {
            when Channel {
                %distinct-channels{$_.WHICH} = $_;
                @todo.push: [ +@todo, $EARLIEST_KIND_MORE, $_, $wild_more, $wild_done ];
            }
            default {
                die "Got a {$_.WHAT.perl}, but expected a Channel";
            }
        }
    }

    if !@todo {
        die "Nothing todo for earliest";
    }

    my $action;

    CHECK:
    loop {  # until something to return
        for @todo.pick(*) -> $todo {
            my $kind       := $todo[1];
            my $contestant := $todo[2];

            if $kind == $EARLIEST_KIND_DONE {
                if $contestant.closed {
                    $action = { INVOKE_KV($todo[3], $todo[0]) };
                    last CHECK;
                }
            }

            else { # $kind == $EARLIEST_KIND_MORE
                if +%distinct-channels == 1 && !$wait {
                    try {
                        my $value := $contestant.receive;
                        $action = { INVOKE_KV($todo[3], $todo[0], $value) };
                        last CHECK;

                        CATCH {
                            when X::Channel::ReceiveOnClosed {
                                if $todo[4] {
                                    $action = { INVOKE_KV($todo[4], $todo[0]) };
                                    last CHECK;
                                }
                            }
                        }
                    }
                }
                else {
                    if !nqp::istype((my $value := $contestant.poll),Nil) {
                        $action = { INVOKE_KV($todo[3], $todo[0], $value) };
                        last CHECK;
                    }

                    elsif $contestant.closed && $todo[4] {
                        $action = { INVOKE_KV($todo[4], $todo[0]) };
                        last CHECK;
                    }
                }
            }
        }

        # we have to wait
        if $until && nqp::time_n() >= $until {  # we're done waiting
            $action = $wait;
            last CHECK;
        }

        # wait a bit
        Thread.yield()
    }

    # must do action outside above loop to make any "last" in block find the right loop
    $action();
}

sub WINNER(|c) {
    DEPRECATED('earliest', |<2014.10 2015.10>, :what<winner>);
    EARLIEST(|c);
}

# From 'src/core/IO/Notification.pm'

my enum FileChangeEvent (:FileChanged(1), :FileRenamed(2));

my class IO::Notification {
    my class FileWatchCancellation is repr('AsyncTask') { }

    class Change {
        has $.path;
        has $.event;
    }

    method watch_path(Str() $path, :$scheduler = $*SCHEDULER) {
        my $s = Supply.new;
        nqp::watchfile(
            $scheduler.queue,
            -> \path, \rename, \err {
                if err {
                    $s.quit(err);
                }
                else {
                    my $event = rename ?? FileRenamed !! FileChanged;
                    $s.emit(Change.new(:path(path // $path), :$event));
                }
            },
            $path, FileWatchCancellation);
        $s
    }
}
# From 'src/core/IO/Socket.pm'

my role IO::Socket does IO {
    has $!PIO;
    # JVM has a buffer here; Moar does enough buffering of its own
    # and gets it much more correct when bytes cross boundaries, so we use its.
    has $!buffer = buf8.new;

    # if bin is true, will return Buf, Str otherwise
    method recv (Cool $chars = Inf, :$bin? = False) {
        fail('Socket not available') unless $!PIO;

        if $!buffer.elems < $chars {
            my $r := nqp::readfh($!PIO, nqp::decont(buf8.new), 65536);
            $!buffer ~= $r;
        }

        if $bin {
            my $rec;
            if $!buffer.elems > $chars {
                $rec = $!buffer.subbuf(0, $chars);
                $!buffer = $!buffer.subbuf($chars);
            } else {
                $rec = $!buffer;
                $!buffer = buf8.new;
            }
            $rec;
        } else {
            my $rec = nqp::decode(nqp::decont($!buffer), 'utf8');
            if $rec.chars > $chars {
                $rec = substr($rec,0,$chars);
                my $used = $rec.encode('utf8').elems;
                $!buffer = $!buffer.subbuf($used)
            } else {
                $!buffer = buf8.new;
            }
            $rec;
        }
    }

    method read(IO::Socket:D: Int(Cool) $bufsize) {
        fail('Socket not available') unless $!PIO;
        my $res = buf8.new();
        my $buf;
        repeat {
            $buf := buf8.new();
            nqp::readfh($!PIO, $buf, nqp::unbox_i($bufsize - $res.elems));
            $res ~= $buf;
        } while $res.elems < $bufsize && $buf.elems;
        $res;
    }

    method poll(Int $bitmask, $seconds) {
        die 'Socket.poll is NYI'
    }

    method send (Str(Cool) $string) {
        fail("Not connected") unless $!PIO;
        nqp::printfh($!PIO, nqp::unbox_s($string));
        True
    }

    method write(Blob:D $buf) {
        fail('Socket not available') unless $!PIO;
        nqp::writefh($!PIO, nqp::decont($buf));
        True
    }

    method close () {
        fail("Not connected!") unless $!PIO;
        nqp::closefh($!PIO);
        $!PIO := Mu;
        True
    }
}

# From 'src/core/IO/Socket/Async.pm'

my class IO::Socket::Async {
    my class SocketCancellation is repr('AsyncTask') { }

    has $!VMIO;

    method new() {
        die "Cannot create an asynchronous socket directly; please use" ~
            "IO::Socket::Async.connect or IO::Socket::Async.listen.";
    }

    method send(IO::Socket::Async:D: Str() $str, :$scheduler = $*SCHEDULER) {
        my $p = Promise.new;
        my $v = $p.vow;
        nqp::asyncwritestr(
            $!VMIO,
            $scheduler.queue,
            -> Mu \bytes, Mu \err {
                if err {
                    $v.break(err);
                }
                else {
                    $v.keep(bytes);
                }
            },
            nqp::unbox_s($str), SocketCancellation);
        $p
    }

    method write(IO::Socket::Async:D: Blob $b, :$scheduler = $*SCHEDULER) {
        my $p = Promise.new;
        my $v = $p.vow;
        nqp::asyncwritebytes(
            $!VMIO,
            $scheduler.queue,
            -> Mu \bytes, Mu \err {
                if err {
                    $v.break(err);
                }
                else {
                    $v.keep(bytes);
                }
            },
            nqp::decont($b), SocketCancellation);
        $p
    }

    my sub capture(\supply) {

        my $lock = Lock.new;
        my int $emitting;
        my int $next_seq;
        my @buffer; # should be Mu, as data can be Mu

        -> Mu \seq, Mu \data, Mu \err {
            if err {
                supply.quit(err);
            }
            elsif seq < 0 {
                supply.done();
            }
            else {
                # cannot simply return out of here, so we need a flag
                my int $in_charge;

                $lock.protect( {
#say "seq = {seq} with {data}   in {$*THREAD}";
                    @buffer[ seq - $next_seq ] := data;
                    $in_charge = $emitting = 1 unless $emitting;
                } );

                if $in_charge {
                    my int $done;
                    while @buffer.EXISTS-POS($done) {
#say "emitting { $next_seq + $done }: {@buffer[$done]}";
                        supply.emit( @buffer[$done] );
                        $done = $done + 1;
                    }

                    $lock.protect( {
                        if $done {
#say "discarding from $next_seq for $done";
                            @buffer.splice(0,$done);
                            $next_seq = $next_seq + $done;
                        }
                        $emitting = 0;
                    } );
                }
            }
        };
    }

    method chars_supply(IO::Socket::Async:D: :$scheduler = $*SCHEDULER) {
        my $cancellation;
        Supply.on-demand( -> $supply {
            $cancellation := nqp::asyncreadchars(
              $!VMIO,
              $scheduler.queue,
              capture($supply),
              SocketCancellation
            );
          },
          closing => {
              $cancellation && nqp::cancel($cancellation)
          },
        );
    }

    method bytes_supply(IO::Socket::Async:D: :$scheduler = $*SCHEDULER, :$buf = buf8.new) {
        my $cancellation;
        Supply.on-demand( -> $supply {
            $cancellation := nqp::asyncreadbytes(
              $!VMIO,
              $scheduler.queue,
              capture($supply),
              nqp::decont($buf),
              SocketCancellation,
            );
          },
          closing => {
              $cancellation && nqp::cancel($cancellation)
          },
        );
    }

    method close(IO::Socket::Async:D:) {
        nqp::closefh($!VMIO);
        True;
    }

    method connect(IO::Socket::Async:U: Str() $host, Int() $port,
                   :$scheduler = $*SCHEDULER) {
        my $p = Promise.new;
        my $v = $p.vow;
        nqp::asyncconnect(
            $scheduler.queue,
            -> Mu \socket, Mu \err {
                if err {
                    $v.break(err);
                }
                else {
                    my $client_socket := nqp::create(self);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!VMIO', socket);
                    $v.keep($client_socket);
                }
            },
            $host, $port, SocketCancellation);
        $p
    }

    method listen(IO::Socket::Async:U: Str() $host, Int() $port,
                  :$scheduler = $*SCHEDULER) {
        my $cancellation;
        Supply.on-demand(-> $s {
            $cancellation := nqp::asynclisten(
                $scheduler.queue,
                -> Mu \socket, Mu \err {
                    if err {
                        $s.quit(err);
                    }
                    else {
                        my $client_socket := nqp::create(self);
                        nqp::bindattr($client_socket, IO::Socket::Async, '$!VMIO', socket);
                        $s.emit($client_socket);
                    }
                },
                $host, $port, SocketCancellation);
        },
        closing => {
            $cancellation && nqp::cancel($cancellation)
        });
    }
}
# From 'src/core/IO/Socket/INET.pm'

my class IO::Socket::INET does IO::Socket {
    my module PIO {
        constant PF_LOCAL       = 0;
        constant PF_UNIX        = 1;
        constant PF_INET        = 2;
        constant PF_INET6       = 3;
        constant PF_MAX         = 4;
        constant SOCK_PACKET    = 0;
        constant SOCK_STREAM    = 1;
        constant SOCK_DGRAM     = 2;
        constant SOCK_RAW       = 3;
        constant SOCK_RDM       = 4;
        constant SOCK_SEQPACKET = 5;
        constant SOCK_MAX       = 6;
        constant PROTO_TCP      = 6;
        constant PROTO_UDP      = 17;
    }

    has Str $.encoding = 'utf8';
    has Str $.host;
    has Int $.port = 80;
    has Str $.localhost;
    has Int $.localport;
    has Bool $.listen;
    has $.family = PIO::PF_INET;
    has $.proto = PIO::PROTO_TCP;
    has $.type = PIO::SOCK_STREAM;
    has Str $.input-line-separator is rw = "\n";
    has Int $.ins = 0;

    my sub v4-split($uri) {
        return $uri.split(':', 2);
    }

    my sub v6-split($uri) {
        my ($host, $port) = ($uri ~~ /^'[' (.+) ']' \: (\d+)$/)[0,1];
        return $host ?? ($host, $port) !! $uri;
    }

    method new (*%args is copy) {
        fail "Nothing given for new socket to connect or bind to" unless %args<host> || %args<listen>;

        if %args<host>  {
            my ($host, $port) = %args<family> && %args<family> == PIO::PF_INET6
                ?? v6-split(%args<host>)
                !! v4-split(%args<host>);
            if $port {
                %args<port> //= $port;
                %args<host> = $host;
            }
        }
        if %args<localhost> {
            my ($peer, $port) = %args<family> && %args<family> == PIO::PF_INET6
                ?? v6-split(%args<localhost>)
                !! v4-split(%args<localhost>);
            if $port {
                %args<localport> //= $port;
                %args<localhost> = $peer;
            }
        }

        %args<listen>.=Bool if %args.EXISTS-KEY('listen');

        #TODO: Learn what protocols map to which socket types and then determine which is needed.
        self.bless(|%args)!initialize()
    }

    method !initialize() {
        my $PIO := nqp::socket($.listen ?? 10 !! 0);
        #Quoting perl5's SIO::INET:
        #If Listen is defined then a listen socket is created, else if the socket type,
        #which is derived from the protocol, is SOCK_STREAM then connect() is called.
        if $.listen || $.localhost || $.localport {
            nqp::bindsock($PIO, nqp::unbox_s($.localhost || "0.0.0.0"),
                                 nqp::unbox_i($.localport || 0));
        }

        if $.listen {
        }
        elsif $.type == PIO::SOCK_STREAM {
            nqp::connect($PIO, nqp::unbox_s($.host), nqp::unbox_i($.port));
        }

        nqp::bindattr(self, $?CLASS, '$!PIO', $PIO);
        self;
    }

    method get() {
        my Mu $io       := nqp::getattr(self, $?CLASS, '$!PIO');
        my str $encoding = nqp::unbox_s(NORMALIZE_ENCODING($!encoding));
        nqp::setencoding($io, $encoding);
        my str $sep = nqp::unbox_s($!input-line-separator);
        nqp::setinputlinesep($io, $sep);
        my int $sep-len = nqp::chars($sep);
        my str $line    = nqp::readlinefh($io);
        my int $len     = nqp::chars($line);

        if $len == 0 { Str }
        else {
            ++$!ins;
            $len >= $sep-len && nqp::eqat($line, $sep, $len - $sep-len)
                ?? nqp::p6box_s(nqp::substr($line, 0, $len - $sep-len))
                !! nqp::p6box_s($line);
        }
    }

    method lines() {
        gather while (my $line = self.get()).defined {
            take $line;
        }
    }

    method accept() {
        ## A solution as proposed by moritz
        my $new_sock := $?CLASS.bless(:$!family, :$!proto, :$!type, :$!input-line-separator);
        nqp::getattr($new_sock, $?CLASS, '$!buffer') = buf8.new;
        nqp::bindattr($new_sock, $?CLASS, '$!PIO',
            nqp::accept(nqp::getattr(self, $?CLASS, '$!PIO'))
        );
        return $new_sock;
    }

    method remote_address() {
    }

    method local_address() {
    }
}

# From 'src/core/Systemic.pm'

role Systemic {
    has Str $.name;
    has Str $.auth;
    has Version $.version;
    has Blob $.signature;
    has Str $.desc;

    submethod BUILD (
      :$!name    = "unknown",
      :$!auth    = "unknown",
      :$!version = Version.new("unknown"),
    ) {}
    multi method gist(Systemic:D:) {
        $.name ~ (" ($!version)" if $.version.gist ne "vunknown")
    }
    method Str  { $.name }
}

role Universal {
    has Str $.name;
    has Str $.auth;
    has Version $.version;
    has Blob $.signature;

    submethod BUILD (
      :$!name    = "unknown",
      :$!auth    = "unknown",
      :$!version = Version.new("unknown"),
    ) {}
    multi method gist(Universal:D:) {
        $!name ~ (" ($!version)" if $!version.gist ne "vunknown")
    }
    method Str  { $!name }
}

# From 'src/core/VM.pm'

class VM does Systemic {
    has $.config;
    has $.properties;
    has $.precomp-ext;
    has $.precomp-target;
    has $.prefix;

    submethod BUILD (
      :$!config,
      :$!desc = Str,
      :$!properties,
    ) {
        $!name           = 'jvm';
        $!auth           = $!properties<java.vendor> // "unknown";
        $!version        = Version.new($!properties<java.specification.version> // "unknown");
        $!precomp-ext    = "jar";
        $!precomp-target = "jar";
        $!prefix         = $!properties<perl6.prefix>;
    }
}

multi sub postcircumfix:<{ }> (VM $d, "name" )   {
    DEPRECATED('$*VM.name', |<2014.05 2015.05>, :what('$*VM<name>') );
    $d.name
}
multi sub postcircumfix:<{ }> (VM $d, "config" ) {
    DEPRECATED('$*VM.config', |<2014.05 2015.05>, :what('$*VM<config>') );
    $d.config
}
multi sub postcircumfix:<{ }> (VM $d, "properties" ) {
    DEPRECATED('$*VM.properties', |<2014.05 2015.05>, :what('$*VM<properties>') );
    $d.properties
}

sub INITIALIZE-A-VM-NOW() {
    my $desc := DateTime.now.Str;
    my $config := do {
        my %CONFIG;
        my $jenv := nqp::backendconfig();
        my Mu $enviter := nqp::iterator($jenv);
        my $envelem;
        my $key;
        while $enviter {
            $envelem := nqp::shift($enviter);
            $key = nqp::p6box_s(nqp::iterkey_s($envelem));
            %CONFIG{$key} = nqp::p6box_s(nqp::iterval($envelem));
        }
        %CONFIG;
    }
    my $properties := do {
        my %PROPS;
        my $jenv := nqp::jvmgetproperties();
        my Mu $enviter := nqp::iterator($jenv);
        my $envelem;
        my $key;
        while $enviter {
            $envelem := nqp::shift($enviter);
            $key = nqp::p6box_s(nqp::iterkey_s($envelem));
            %PROPS{$key} = nqp::p6box_s(nqp::iterval($envelem));
        }
        %PROPS;
    }
    VM.new(:$config,:$desc,:$properties);
}

multi sub INITIALIZE_DYNAMIC('$*VM') {
    PROCESS::<$VM> := INITIALIZE-A-VM-NOW();
}

# From 'src/core/Distro.pm'


class Distro does Systemic {
    has Str $.release;
    has Bool $.is-win;
    has Str $.path-sep;

    submethod BUILD (
      :$name,
      :$version,
      :$!release,
      :$!auth,
      :$!path-sep,
      :$!signature  = Blob,
      :$!desc = Str,
    ) {
        $!name = $name.lc;    # lowercase
        $!name ~~ s:g/" "//;  # spaceless
        $!version = Version.new($version);
        $!is-win  = so $!name eq any <mswin32 mingw msys cygwin>;
    }
}

sub INITIALIZE-A-DISTRO-NOW() {
    my $properties := INITIALIZE-A-VM-NOW.properties;
    my $name       := $properties<os.name>;
    my $version    := $properties<os.version>;
    my $path-sep   := $properties<path.separator>;
    my Str $release := "unknown";
    my Str $auth    := "unknown";

    # darwin specific info
    if $name eq 'darwin' {
        if qx/sw_vers/ ~~ m/^
        ProductName\: \s+ (<[\w\ ]>+) \s+
        ProductVersion\: \s+ (<[\d\.]>+) \s+
        BuildVersion\: \s+ (<[\w\d]>+)
        / {
            $name    := ~$0;
            $version := ~$1;
            $release := ~$2;
        }
        else {
            $name    := 'Mac OS X'; # we assume
            $version := "unknown";
            $release := qx/uname -r/.chomp;
        }
        $auth := 'Apple Computer, Inc.'; # presumably
    }
    elsif '/etc/os-release'.IO.e {
        $_ := '/etc/os-release'.IO.slurp.subst(:g, /'"'/,'');
        $auth    := ~$0 if m/^^ HOME_URL   \= (\N*) /;
        $name    := ~$0 if m/^^ ID         \= (\N*) /;
        $version := ~$0 if m/^^ VERSION    \= (\N*) /;
        $release := ~$0 if m/^^ VERSION_ID \= (\N*) /;
    }
    elsif $name eq 'linux' {
        if qx{lsb_release -a 2> /dev/null} ~~ m/
            Distributor \s+ ID\: \s+ (<[\w\ ]>+) \s+
            Description\: \s+ (<[\w\ ]>+) \s+ (<[\d\.]>+) \s+
            Release\: \s+ (<[\d\.]>+)
        / {
            $auth    := ~$0;
            $name    := ~$1;
            $version := ~$2;
            $release := ~$3;
        }
    }
    my $desc := DateTime.now.Str;
    Distro.new(:$name, :$version, :$release, :$auth, :$path-sep, :$desc);
}

multi sub INITIALIZE_DYNAMIC('$*DISTRO') {
    PROCESS::<$DISTRO> := INITIALIZE-A-DISTRO-NOW();
}

multi sub INITIALIZE_DYNAMIC('$*OS') {
    PROCESS::<$OS> := Deprecation.obsolete(
      :name('$*OS'),
      :from<2014.09>,
      :removed<2015.09>,
      :value($*DISTRO.name),
      :instead('$*DISTRO.name'),
    );
}

multi sub INITIALIZE_DYNAMIC('$*OSVER') {
    PROCESS::<$OSVER> := Deprecation.obsolete(
      :name('$*OSVER'),
      :from<2014.09>,
      :removed<2015.09>,
      :value($*DISTRO.version),
      :instead('$*DISTRO.version'),
    );
}

# From 'src/core/Kernel.pm'


class Kernel does Systemic {
    has Str $.release;
    has Str $!hardware;
    has Str $!arch;
    has Int $!bits;

    sub uname($opt) {
        state $has_uname = "/bin/uname".IO.s || "/usr/bin/uname".IO.s;
        $has_uname ?? qqx/uname $opt/.chomp !! 'unknown';
    }

    submethod BUILD (:$!auth = "unknown") {}

    method name {
        $!name //= do {
            given $*DISTRO.name {
                when 'mswin32' {
                    'win32'
                }
                default {
                    lc uname '-s';
                }
            }
        }
    }

    method version {
        $!version //= Version.new( do {
            given $*DISTRO.name {
                when 'freebsd' {
                    uname '-r'; # -K -U not introduced until 10.0
                }
                when 'macosx' {
                    my $unamev = uname '-v';
                    $unamev ~~ m/^Darwin \s+ Kernel \s+ Version \s+ (<[\d\.]>+)/
                      ?? ~$0
                      !! $unamev.chomp;
                }
                default {
                    uname '-v';
                }
            }
        } );
    }

    method release {
        $!release //= do {
            given $*DISTRO.name {
                when any <openbsd netbsd> { # needs adapting
                    uname '-r';
                }
                default {
                    uname '-v';
                }
            }
        }
    }

    method hardware {
        $!hardware //= do {
            given $*DISTRO.name {
                default {
                    uname '-m';
                }
            }
        }
    }

    method arch {
        $!arch //= do {
            given $*DISTRO.name {
                when 'raspbian' {
                    uname '-m';
                }
                default {
                    uname '-p';
                }
            }
        }
    }

    method bits {
        $!bits //= $.hardware ~~ m/_64|w|amd64/ ?? 64 !! 32;  # naive approach
    }

}

multi sub INITIALIZE_DYNAMIC('$*KERNEL') {
    PROCESS::<$KERNEL> := Kernel.new;
}

# From 'src/core/Compiler.pm'

class Compiler does Systemic {
    has Str $.release;
    has DateTime $.build-date;
    has Str $.codename;

    submethod BUILD (
      :$!name      = 'rakudo',
      :$!auth      = 'The Perl Foundation',
      :$version,
      :$release,
      :$build-date,
      :$codename,
    ) {
        my Mu $compiler := nqp::getcurhllsym('$COMPILER_CONFIG');
        $!version = Version.new(
          $version // nqp::p6box_s(nqp::atkey($compiler, 'version')) );
        $!release =
          $release // nqp::p6box_s(nqp::atkey($compiler, 'release-number'));
        $!build-date = DateTime.new(
          $build-date // nqp::p6box_s(nqp::atkey($compiler, 'build-date')) );
        $!codename =
          $codename // nqp::p6box_s(nqp::atkey($compiler, 'codename'));
    }
}

multi sub postcircumfix:<{ }> (Compiler $d, "name" )   {
    DEPRECATED('$*PERL.compiler.name', |<2014.06 2015.06>, :what('$*PERL<compiler><name>') );
    $d.name
}
multi sub postcircumfix:<{ }> (Compiler $d, "ver" )   {
    DEPRECATED('$*PERL.compiler.version', |<2014.06 2015.06>, :what('$*PERL<compiler><ver>') );
    $d.version
}
multi sub postcircumfix:<{ }> (Compiler $d, "release-number" )   {
    DEPRECATED('$*PERL.compiler.release', |<2014.06 2015.06>, :what('$*PERL<compiler><release-number>') );
    $d.release
}
multi sub postcircumfix:<{ }> (Compiler $d, "build-date" )   {
    DEPRECATED('$*PERL.compiler.build-date', |<2014.06 2015.06>, :what('$*PERL<compiler><build-date>') );
    $d.build-date
}
multi sub postcircumfix:<{ }> (Compiler $d, "codename" )   {
    DEPRECATED('$*PERL.compiler.codename', |<2014.06 2015.06>, :what('$*PERL<compiler><codename>') );
    $d.build-date
}

# From 'src/core/Perl.pm'

class Perl does Systemic {
    has Compiler $.compiler;

    submethod BUILD (
      :$!name      = 'Perl 6',
      :$!auth      = "The Perl Foundation",
      :$!version   = Version.new("unknown"),
      :$!compiler  = Compiler.new,
    ) { }

    method VMnames { <moar jvm > }

    method DISTROnames {
        (
        <macosx linux freebsd mswin32 openbsd netbsd>
        )
    }

    method KERNELnames { <darwin linux freebsd openbsd netbsd win32> }
}

#multi sub INITIALIZE_DYNAMIC('$*PERL') {
    PROCESS::<$PERL> := Perl.new;
#}
multi sub postcircumfix:<{ }> (Perl $d, "name" )   {
    DEPRECATED('$*PERL.name', |<2014.06 2015.06>, :what('$*PERL<name>') );
    $d.name
}
multi sub postcircumfix:<{ }> (Perl $d, "compiler" )   {
    # allow this silently, as we will catch it on accessing the Compiler object
    $d.compiler
}

# From 'src/core/OS.pm'

sub gethostname( --> Str){
    return nqp::p6box_s(nqp::gethostname());
}

my class Proc::Status {
    has $.exit;
    has $.pid;
    has $.signal;

    #~ method exit()   { $!exit   }
    #~ method pid()    { $!pid    }
    #~ method signal() { $!signal }

    proto method status(|) { * }
    multi method status($new_status) {
        $!exit   = $new_status +> 8;
        $!signal = $new_status +& 0xFF;
    }
    multi method status(Proc::Status:D:)  { ($!exit +< 8) +| $!signal }
    multi method Numeric(Proc::Status:D:) { $!exit }
    multi method Bool(Proc::Status:D:)    { $!exit == 0 }
}

# From 'src/core/JSON/Pretty.pm'

my class JSONPrettyActions {
    method TOP($/) {
        make $/.values.[0].ast;
    };
    method object($/) {
        make $<pairlist>.ast.hash.item;
    }

    method pairlist($/) {
        make $<pair>>>.ast.flat;
    }

    method pair($/) {
        make $<string>.ast => $<value>.ast;
    }

    method array($/) {
        make $<arraylist>.ast.item;
    }

    method arraylist($/) {
        make [$<value>>>.ast];
    }

    method string($/) {
        make $0.elems == 1
            ?? ($0[0].<str> || $0[0].<str_escape>).ast
            !! join '', $0.list.map({ (.<str> || .<str_escape>).ast });
    }
    method value:sym<number>($/) { make +$/.Str }
    method value:sym<string>($/) { make $<string>.ast }
    method value:sym<true>($/)   { make Bool::True  }
    method value:sym<false>($/)  { make Bool::False }
    method value:sym<null>($/)   { make Any }
    method value:sym<object>($/) { make $<object>.ast }
    method value:sym<array>($/)  { make $<array>.ast }

    method str($/)               { make ~$/ }

    method str_escape($/) {
        if $<xdigit> {
            make chr(:16($<xdigit>.join));
        } else {
            my %h = '\\' => "\\",
                    '/'  => "/",
                    'b'  => "\b",
                    'n'  => "\n",
                    't'  => "\t",
                    'f'  => "\f",
                    'r'  => "\r",
                    '"'  => "\"";
            make %h{~$/};
        }
    }
}

my grammar JSONPrettyGrammar {
    token TOP       { ^ \s* [ <object> | <array> ] \s* $ }
    rule object     { '{' ~ '}' <pairlist>     }
    rule pairlist   { <pair> * % \,            }
    rule pair       { <string> ':' <value>     }
    rule array      { '[' ~ ']' <arraylist>    }
    rule arraylist  {  <value> * % [ \, ]        }

    proto token value {*};
    token value:sym<number> {
        '-'?
        [ 0 | <[1..9]> <[0..9]>* ]
        [ \. <[0..9]>+ ]?
        [ <[eE]> [\+|\-]? <[0..9]>+ ]?
    }
    token value:sym<true>    { <sym>    };
    token value:sym<false>   { <sym>    };
    token value:sym<null>    { <sym>    };
    token value:sym<object>  { <object> };
    token value:sym<array>   { <array>  };
    token value:sym<string>  { <string> }

    token string {
        \" ~ \" ( <str> | \\ <str_escape> )*
    }

    token str {
        <-["\\\t\n]>+
    }

    token str_escape {
        <["\\/bfnrt]> | u <xdigit>**4
    }
}

proto sub to-json($, :$indent = 0, :$first = 0) {*}

multi sub to-json(Version:D $v, :$indent = 0, :$first = 0) { to-json(~$v, :$indent, :$first) }
multi sub to-json(Real:D $d, :$indent = 0, :$first = 0) { (' ' x $first) ~ ~$d }
multi sub to-json(Bool:D $d, :$indent = 0, :$first = 0) { (' ' x $first) ~ ($d ?? 'true' !! 'false') }
multi sub to-json(Str:D $d, :$indent = 0, :$first = 0) {
    (' ' x $first) ~ '"'
    ~ $d.trans(['"', '\\', "\b", "\f", "\n", "\r", "\t"]
            => ['\"', '\\\\', '\b', '\f', '\n', '\r', '\t'])\
            .subst(/<-[\c32..\c126]>/, { ord(~$_).fmt('\u%04x') }, :g)
    ~ '"'
}
multi sub to-json(Positional:D $d, :$indent = 0, :$first = 0) {
    return (' ' x $first) ~ "\["
            ~ ($d ?? $d.map({ "\n" ~ to-json($_, :indent($indent + 2), :first($indent + 2)) }).join(",") ~ "\n" ~ (' ' x $indent) !! ' ')
            ~ ']';
}
multi sub to-json(Associative:D $d, :$indent = 0, :$first = 0) {
    return (' ' x $first) ~ "\{"
            ~ ($d ?? $d.map({ "\n" ~ to-json(.key, :first($indent + 2)) ~ ' : ' ~ to-json(.value, :indent($indent + 2)) }).join(",") ~ "\n" ~ (' ' x $indent) !! ' ')
            ~ '}';
}

multi sub to-json(Mu:U $, :$indent = 0, :$first = 0) { 'null' }
multi sub to-json(Mu:D $s, :$indent = 0, :$first = 0) {
    die "Can't serialize an object of type " ~ $s.WHAT.perl
}

sub from-json($text) {
    my $a = JSONPrettyActions.new();
    my $o = JSONPrettyGrammar.parse($text, :actions($a));
    return $o.ast;
}
# From 'src/core/Distribution.pm'

class Distribution {
    has $.id is rw;
    has $.name;
    has $.auth;
    has $.author;
    has $.authority;
    has $.ver;
    has $.version;
    has $.description;
    has @.depends;
    has %.provides;
    has %.files;
    has $.source-url;
    method auth { $!auth // $!author // $!authority }
    method ver  { $!ver // $!version }
    method hash {
        {
            :$!id,
            :$!name,
            :$.auth,
            :$.ver,
            :$!description,
            :@!depends,
            :%!provides,
            :%!files,
            :$!source-url,
        }
    }
}

class CompUnitRepo::Distribution is Distribution {
    method Hash { self.hash }
}
# From 'src/core/CompUnit.pm'

class CompUnit {
    has Lock     $!lock;
    has Str      $.from;
    has Str      $.name;
    has Str      $.extension;
    has Str      $.precomp-ext;
    has IO::Path $.path;
    has Str      $!WHICH;
    has Bool     $.has-source;
    has Bool     $.has-precomp;
    has Bool     $.is-loaded;

    my Lock $global = Lock.new;
    my $default-from = 'Perl6';
    my %instances;

    method new(CompUnit:U:
      $path,
      :$name is copy,
      :$extension is copy,
      :$from = $default-from,
      :$has-source is copy,
      :$has-precomp is copy,
    ) {

        # set name / extension if not already given
        if !$name or !$extension.defined {
            my IO::Spec $SPEC := $*SPEC;
            $name      ||= $SPEC.basename($path);
            $extension ||= $SPEC.extension($name);
        }

        # sanity test
        my $precomp-ext = $*VM.precomp-ext;
        $has-source  //= ?$path.IO.f;
        $has-precomp //= ?"$path.$precomp-ext".IO.f;
        return Nil unless $has-source or $has-precomp;

        $global.protect( { %instances{$path} //= self.bless(
          :path(IO::Path.new-from-absolute-path($path)),
          :lock(Lock.new),
          :$name,
          :$extension,
          :$precomp-ext,
          :$from,
          :$has-source,
          :$has-precomp,
          :!is-loaded,
        ) } );
    }

    multi method WHICH(CompUnit:D:) { $!WHICH //= "{self.^name}|$!path.abspath()" }
    multi method Str(CompUnit:D: --> Str)  { $!path.abspath }
    multi method gist(CompUnit:D: --> Str) { "{self.name}:{$!path.abspath}" }

    method key(CompUnit:D: --> Str) {
        $!has-precomp ?? $!precomp-ext !! $!extension;
    }

    # same magic I'm not sure we need
    my Mu $p6ml := nqp::gethllsym('perl6', 'ModuleLoader');
    method p6ml() { $p6ml }
    method ctxsave() { $p6ml.ctxsave() }
    method absolute_path($path) { $p6ml.absolute_path($path) }
    method load_setting($setting_name) { $p6ml.load_setting($setting_name) }
    method resolve_repossession_conflicts(@conflicts) {
        $p6ml.resolve_repossession_conflicts(
          nqp::findmethod(@conflicts, 'FLATTENABLE_LIST')(@conflicts)
        );
    }

    # do the actual work
    method load(CompUnit:D:
      $module_name,
      %opts,
      *@GLOBALish is rw,
      :$line,
      :$file
    ) {
        $!lock.protect( {

            # nothing to do
            return $!is-loaded if $!is-loaded;

            my $candi = self.candidates($module_name, :auth(%opts<auth>), :ver(%opts<ver>))[0];
            my %chosen;
            if $candi {
                %chosen<pm>   :=
                  $candi<provides>{$module_name}<pm><file>;
                %chosen<pm>   := ~%chosen<pm> if %chosen<pm>.DEFINITE;
                %chosen<load> :=
                  $candi<provides>{$module_name}{$!precomp-ext}<file>;
                %chosen<key>  := %chosen<pm> // %chosen<load>;
            }
            $p6ml.load_module(
              $module_name,
              %opts,
              |@GLOBALish,
              :$line,
              :$file,
              :%chosen
            );
        } );
    }

    method precomp-path(CompUnit:D: --> Str) { "$!path.$!precomp-ext" }

    method precomp(CompUnit:D:
      $out  = self.precomp-path,
      :$INC = @*INC,
      :$force,
      --> Bool) {
        die "Cannot pre-compile over an existing file: $out"
          if !$force and $out.IO.e;
        my Mu $opts := nqp::atkey(%*COMPILING, '%?OPTIONS');
        my $lle = !nqp::isnull($opts) && !nqp::isnull(nqp::atkey($opts, 'll-exception'))
          ?? ' --ll-exception'
          !! '';
        %*ENV<RAKUDO_PRECOMP_WITH> = CREATE-INCLUDE-SPEC(@$INC);
        my Bool $result = ?shell(
          "$*EXECUTABLE$lle --target={$*VM.precomp-target} --output=$out $!path"
        );
        %*ENV<RAKUDO_PRECOMP_WITH>:delete;

        $!has-precomp = $result if $out eq self.precomp-path;
        $result;
    }
}

multi sub postcircumfix:<{ }> (CompUnit:D \c, "provides" ) {
    my % = (
      c.name => {
        pm => {
          file => c.path
        },
        c.key => {
          file => c.has-precomp ?? c.precomp-path !! c.path
        }
      }
    );
}
multi sub postcircumfix:<{ }> (CompUnit:D \c, "key" ) {
    c.key;
}
multi sub postcircumfix:<{ }> (CompUnit:D \c, "ver" ) {
    Version.new('0');
}
# From 'src/core/CompUnitRepo.pm'

role  CompUnitRepo::Locally             { ... }
class CompUnitRepo::Local::File         { ... }
class CompUnitRepo::Local::Installation { ... }

class CompUnitRepo {
    my Mu $p6ml := nqp::gethllsym('perl6', 'ModuleLoader');
    my $lock     = Lock.new;

    method files($file, :$name, :$auth, :$ver) {
        for @*INC {
            if nqp::istype($_,Str) ?? CompUnitRepo::Local::File.new($_) !! $_ -> $cur {
                if $cur.files($file, :$name,:$auth,:$ver).list -> @candi {
                    return @candi;
                }
            }
        }
        ();
    }

    method candidates($name, :$file, :$auth, :$ver) {
        for @*INC {
            if nqp::istype($_,Str) ?? CompUnitRepo::Local::File.new($_) !! $_ -> $cur {
                if $cur.candidates($name, :$file,:$auth,:$ver).list -> @candi {
                    return @candi;
                }
            }
        }
        ();
    }

    method p6ml { $p6ml }

    method load_module($module_name, %opts, *@GLOBALish is rw, :$line, :$file, :%chosen) {
        $lock.protect( {
        my $candi = self.candidates($module_name, :auth(%opts<auth>), :ver(%opts<ver>))[0];
        if $candi {
            %chosen<pm>   :=
              $candi<provides>{$module_name}<pm><file> //
              $candi<provides>{$module_name}<pm6><file>;
            %chosen<pm>   := ~%chosen<pm> if %chosen<pm>.DEFINITE;
            %chosen<load> :=
              $candi<provides>{$module_name}{$*VM.precomp-ext}<file>;
            %chosen<key>  := %chosen<pm> // %chosen<load>;
        }
        $p6ml.load_module($module_name, %opts, |@GLOBALish, :$line, :$file, :%chosen);
    } ) }

    method ctxsave() { $p6ml.ctxsave() }
    method absolute_path($path) { $p6ml.absolute_path($path) }
    method load_setting($setting_name) { $p6ml.load_setting($setting_name) }
    method resolve_repossession_conflicts(@conflicts) {
        $p6ml.resolve_repossession_conflicts( nqp::findmethod(@conflicts, 'FLATTENABLE_LIST')(@conflicts) )
    }
}

my %CURLID2CLASS = (
  file => CompUnitRepo::Local::File,
  inst => CompUnitRepo::Local::Installation,
);

sub PARSE-INCLUDE-SPEC(Str $specs) {
    my @found;
    my $class = %CURLID2CLASS<file>;

    # for all possible specs
    for $specs.split(/ \s* ',' \s* /) -> $spec {
        my %options;

        # something we understand
        if $spec ~~ /^
          [
            $<type>=[ <.ident>+ % '::' ]
            [ ':' $<n>=\w+
              <[ < ( [ { ]> $<v>=<[\w-]>+ <[ > ) \] } ]>
              { %options{$<n>} = ~$<v> }
            ]*
            ':'
          ]?
          $<path>=.+
        $/ {

            # a type (short-id or class name) was specified
            if $<type> -> $this {
                for %CURLID2CLASS{ $class = ~$this }:v -> $type {
                    $class = $type;
                }
            }

            # still don't have a type object
            if nqp::istype($class,Str) {
                my $type = ::($class);

                # alas, no a known class
                if nqp::istype($type,Failure) {

                    # it's a short-id
                    if %CURLID2CLASS.EXISTS-KEY($class) {
                        $class = %CURLID2CLASS{$class}
                    }

                    # give up
                    else {
                        die $class ~~ m/\:/
                          ?? "Must load class '$class' first"
                          !! "Unknown short-id '$class'";
                    }
                }

                # successfully converted string to type
                else {
                    $class = $type;
                    %CURLID2CLASS{$class.short-id} //= $class;
                }
            }

            # keep this one
            @found.push: $(my $ = $class, ~$<path>, %options);
        }

        # huh?
        elsif $spec ~~ m/\w+/ {
            die "Don't know what to do with '$spec'";
        }
    }
    @found;
}

sub CREATE-INCLUDE-SPEC(@INC) {
    my $root = $*CWD ~ '/';
    @INC.map( {
        (nqp::istype($_,CompUnitRepo::Locally) ?? .short-id !! .^name)
         ~ ':' ~ REMOVE-ROOT($root,.IO.abspath);
    } ).join(',');
}

# From 'src/core/CompUnitRepo/Locally.pm'

role CompUnitRepo::Locally {
    has Lock     $!lock;
    has IO::Path $.IO;
    has Str      $.WHICH;

    my %instances;

    method new(CompUnitRepo::Locally: $dir) {
        my $abspath := $*SPEC.rel2abs($dir);
        try mkdir $abspath;
        my $IO      := IO::Path.new-from-absolute-path($abspath);
        return Nil unless $IO.d and $IO.r;

        %instances{$abspath} //=
          self.bless(:$IO,:lock(Lock.new),:WHICH(self.^name ~ '|' ~ $abspath));
    }

    multi method Str(CompUnitRepo::Locally:D:) { $!IO.abspath }
    multi method gist(CompUnitRepo::Locally:D:) {
        "{self.short-id}:$!IO.abspath()";
    }
    multi method perl(CompUnitRepo::Locally:D:) {
        $?CLASS.^name ~ ".new('$!IO.abspath()')";
    }

    method path(CompUnitRepo::Locally:D:) {
        DEPRECATED( 'IO', |<2014.11 2015.11> );
        $!IO;
    }

    multi method WHICH(CompUnitRepo::Locally:D:) { $!WHICH }

    method path-spec(CompUnitRepo::Locally:D:) {
        self.short-id ~ ':' ~ $!IO.abspath;
    }

    # stubs
    method install(CompUnitRepo::Locally:D: $source, $from? )             {...}
    method files(CompUnitRepo::Locally:D: $file, :$name, :$auth, :$ver)   {...}
    method candidates(CompUnitRepo::Locally:D: $name,:$file,:$auth,:$ver) {...}
    method short-id(CompUnitRepo::Locally:D:)                             {...}
}
# From 'src/core/CompUnitRepo/Local/File.pm'

class CompUnitRepo::Local::File does CompUnitRepo::Locally {

    my %extensions =
      Perl6 => <pm6 pm>,
      Perl5 => <pm5 pm>,
      NQP   => <nqp>,
      JVM   => ();

    # global cache of files seen
    my %seen;

    method install($source, $from?) { ... }
    method files($file, :$name, :$auth, :$ver) {
        my $base := $file.IO;
        $base.f
         ?? { files => { $file => $base.path }, ver => Version.new('0') }
         !! ();
    }

    method candidates(
      $name,
      :$from = 'Perl6',
      :$file,           # not used here (yet)
      :$auth,           # not used here (yet)
      :$ver,            # not used here (yet)
      ) {

        # sorry, cannot handle this one
        return () unless %extensions.EXISTS-KEY($from);

        my $dir-sep := $*SPEC.dir-sep;
        my $base := $!IO.abspath ~ $dir-sep ~ $name.subst(:g, "::", $dir-sep) ~ '.';
        if %seen{$base} -> $found {
            return $found;
        }

        state Str $precomp-ext = $*VM.precomp-ext;  # should be $?VM probably

        # have extensions to check
        if %extensions{$from} -> @extensions {
            for @extensions -> $extension {
                my $path = $base ~ $extension;
                return %seen{$base} = CompUnit.new(
                  $path, :$name, :$extension, :has-source
                ) if IO::Path.new-from-absolute-path($path).f;
                return %seen{$base} = CompUnit.new(
                  $path, :$name, :$extension, :!has-source, :has-precomp
                ) if IO::Path.new-from-absolute-path($path ~ '.' ~ $precomp-ext).f;
            }
        }

        # no extensions to check, just check compiled version
        elsif $base ~ $precomp-ext -> $path {
            return %seen{$base} = CompUnit.new(
              $path, :$name, :extension(''), :!has-source, :has-precomp
            ) if IO::Path.new-from-absolute-path($path).f;
        }

        # alas
        ();
    }

    method short-id() { 'file' }
}
# From 'src/core/CompUnitRepo/Local/Installation.pm'

class CompUnitRepo::Local::Installation does CompUnitRepo::Locally {
    has %!dists;
    has $!cver = nqp::hllize(nqp::atkey(nqp::gethllsym('perl6', '$COMPILER_CONFIG'), 'version'));

    method BUILD(:$!IO, :$!lock, :$!WHICH) {
        my $manifest := $!IO.child("MANIFEST");
        my $abspath  := $!IO.abspath;
        %!dists{$abspath} = $manifest.e
          ?? from-json($manifest.slurp)
          !! {};
        %!dists{$abspath}<file-count> //= 0;
        %!dists{$abspath}<dist-count> //= 0;
        %!dists{$abspath}<dists>      //= [ ];
    }

    method writeable-path {
        %!dists.keys.first( *.IO.w )
    }

    my $windows_wrapper = '@rem = \'--*-Perl-*--
@echo off
if "%OS%" == "Windows_NT" goto WinNT
#perl# "%~dpn0" %1 %2 %3 %4 %5 %6 %7 %8 %9
goto endofperl
:WinNT
#perl# "%~dpn0" %*
if NOT "%COMSPEC%" == "%SystemRoot%\system32\cmd.exe" goto endofperl
if %errorlevel% == 9009 echo You do not have Perl in your PATH.
if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
goto endofperl
@rem \';
__END__
:endofperl
';
    my $perl_wrapper = '#!/usr/bin/env #perl#
sub MAIN(:$name, :$auth, :$ver, *@, *%) {
    shift @*ARGS if $name;
    shift @*ARGS if $auth;
    shift @*ARGS if $ver;
    my @installations = @*INC.grep(CompUnitRepo::Local::Installation);
    my @binaries = @installations>>.files(\'bin/#name#\', :$name, :$auth, :$ver);
    unless +@binaries {
        @binaries = @installations>>.files(\'bin/#name#\');
        if +@binaries {
            note q:to/SORRY/;
                ===SORRY!===
                No candidate found for \'#name#\' that match your criteria.
                Did you perhaps mean one of these?
                SORRY
            my %caps = :name([\'Distribution\', 12]), :auth([\'Author(ity)\', 11]), :ver([\'Version\', 7]);
            for @binaries -> $dist {
                for %caps.kv -> $caption, @opts is rw {
                    @opts[1] = max @opts[1], ($dist{$caption} // \'\').Str.chars
                }
            }
            note \'  \' ~ %caps.values.map({ sprintf(\'%-*s\', .[1], .[0]) }).join(\' | \');
            for @binaries -> $dist {
                note \'  \' ~ %caps.kv.map( -> $k, $v { sprintf(\'%-*s\', $v.[1], $dist{$k} // \'\') } ).join(\' | \')
            }
        }
        else {
            note "===SORRY!===\nNo candidate found for \'#name#\'.\n";
        }
        exit 1;
    }

    exit shell("$*EXECUTABLE_NAME {@binaries[0]<files><bin/#name#>} @*ARGS[]").exit
}';

    method install(:$dist!, *@files) {
        $!lock.protect( {
        my $path     = self.writeable-path or die "No writeable path found";
        my $repo     = %!dists{$path};
        my $file-id := $repo<file-count>;
        my $d        = CompUnitRepo::Distribution.new( |$dist.metainfo );
        state $is-win //= $*DISTRO.is-win; # only look up once
        if $repo<dists>.first({ ($_<name> // '') eq  ($d.name // '') &&
                                ($_<auth> // '') eq  ($d.auth // '') &&
                               ~($_<ver>  //  0) eq ~($d.ver  //  0) }) -> $installed {
            $d.id = $installed<id>
        }
        else {
            $d.id = $repo<dist-count>++
        }

        # Build patterns to choose what goes into "provides" section.
        my $ext = regex { [pm|pm6|pir|pbc|jar|moarvm] };
        my @provides;
        for %($d.provides).kv -> $k, $v is copy {
            $v = $v.subst('\\', '/', :g);
            $v.=subst(/ [pm|pm6]? \.<$ext>$/, '.');
            @provides.push: regex { $v [ [pm|pm6] \. ]? <ext=.$ext> { make $k } }
        }

        # Initialize "provides" section.
        for %($d.provides).kv -> $k, $v is rw {
            # when we do not use .kv, we error out when trying to store into Pairs
            $v = {};
        }

        # Walk the to be installed files, decide whether we put them into
        # "provides" or just "files".
        my $has-provides;
        for @files -> $file is copy {
            $file = $is-win ?? ~$file.subst('\\', '/', :g) !! ~$file;
            if [||] @provides>>.ACCEPTS($file) -> $/ {
                $has-provides = True;
                $d.provides{ $/.ast }{ $<ext> } = {
                    :file($file-id),
                    :time(try $file.IO.modified.Num),
                    :$!cver
                }
            }
            else {
                if $file ~~ /^bin<[\\\/]>/ {
                    mkdir "$path/bin" unless "$path/bin".IO.d;
                    my $basename   = $file.IO.basename;
                    my $withoutext = $basename;
                    $withoutext.=subst(/\.[exe|bat]$/, '');
                    for '', < -p -j -m > -> $be {
                        "$path/bin/$withoutext$be".IO.spurt:
                            $perl_wrapper.subst('#name#', $basename, :g).subst('#perl#', "perl6$be");
                        if $is-win {
                            "$path/bin/$withoutext$be.bat".IO.spurt:
                                $windows_wrapper.subst('#perl#', "perl6$be", :g);
                        }
                        else {
                            "$path/bin/$withoutext$be".IO.chmod(0o755);
                        }
                    }
                }
                $d.files{$file} = $file-id
            }
            copy($file, $path ~ '/' ~ $file-id);
            $file-id++;
        }

        if !$has-provides && $d.files.keys.first(/^blib\W/) {
            my $color = %*ENV<RAKUDO_ERROR_COLOR> // !$is-win;
            my ($red, $green, $yellow, $clear) = $color
                ?? ("\e[31m", "\e[32m", "\e[33m", "\e[0m")
                !! ("", "", "", "");
            my $eject = $is-win ?? "<HERE>" !! "\x[23CF]";

            note "$red==={$clear}WARNING!$red===$clear
The distribution $d.name() does not seem to have a \"provides\" section in its META.info file,
and so the packages will not be installed in the correct location.
Please ask the author to add a \"provides\" section, mapping every exposed namespace to a
file location in the distribution.
See http://design.perl6.org/S22.html#provides for more information.\n";
        }

        $repo<dists>[$d.id] = $d.Hash;

        # XXX Create path if needed.
        "$path/MANIFEST".IO.spurt: to-json( $repo )
    } ) }

    method files($file, :$name, :$auth, :$ver) {
        my @candi;
        for %!dists.kv -> $path, $repo {
            for @($repo<dists>) -> $dist {
                my $dver = $dist<ver>
                        ?? nqp::istype($dist<ver>,Version)
                            ?? $dist<ver>
                            !! Version.new( $dist<ver> )
                        !! Version.new('0');

                if (!$name || $dist<name> ~~ $name)
                && (!$auth || $dist<auth> ~~ $auth)
                && (!$ver  || $dver ~~ $ver)
                && $dist<files>{$file} {
                    my $candi   = %$dist;
                    $candi<ver> = $dver;
                    $candi<files>{$file} = $path ~ '/' ~ $candi<files>{$file}
                        unless $candi<files>{$file} ~~ /^$path/;
                    @candi.push: $candi;
                }
            }
        }
        @candi
    }

    method candidates($name, :$file, :$auth, :$ver) {
        my @candi;
        for %!dists.kv -> $path, $repo {
            for @($repo<dists>) -> $dist {
                my $dver = $dist<ver>
                        ?? nqp::istype($dist<ver>,Version)
                            ?? $dist<ver>
                            !! Version.new( ~$dist<ver> )
                        !! Version.new('0');

                if (!$auth || $dist<auth> ~~ $auth)
                && (!$ver  || $dver ~~ $ver)
                && $dist<provides>{$name} {
                    my $candi   = %$dist;
                    $candi<ver> = $dver;
                    for $candi<provides>.kv -> $ln, $files {
                        for $files.kv -> $type, $file {
                            $candi<provides>{$ln}{$type}<file> = $path ~ '/' ~ $file<file>
                                unless $candi<provides>{$ln}{$type}<file> ~~ /^$path/
                        }
                    }
                    @candi.push: $candi;
                }
            }
        }
        @candi
    }

    method short-id() { 'inst' }
}
# From 'src/core/Argfiles.pm'

{
    my @ARGS;
    my Mu $argiter := nqp::getcurhllsym('$!ARGITER');
    @ARGS.push(nqp::p6box_s(nqp::shift($argiter))) while $argiter;
    nqp::bindkey(nqp::who(PROCESS), '@ARGS', @ARGS);
    PROCESS::<$ARGFILES> = IO::ArgFiles.new(:args(@ARGS));
}

# From 'src/core/Inc.pm'

{
    my @INC;
    my %CUSTOM_LIB;

    my @all_paths;
    sub make-cur($class, $path) {
        @all_paths.push: $path;
        if nqp::istype($class,CompUnitRepo::Locally) {
            $class.new($path);
        }
        elsif $class eq 'CompUnitRepo::Local::File' {
            CompUnitRepo::Local::File.new($path);
        }
        elsif $class eq 'CompUnitRepo::Local::Installation' {
            CompUnitRepo::Local::Installation.new($path);
        }
        else {
            my $name = 'lib/' ~ $class.split('::').join('/') ~ '.pm';
            for @all_paths -> $previous_path {
                if "$previous_path/$name".IO.e {
                    require "$previous_path/$name";
                    return ::($class).new($path);
                }
            }
        }
    }

    # Add CompUnitRepos to @*INC and also to %*CUSTOM_LIB if they have a name.
    sub add-curs($line, $sep = ',') {
        my %options;
        if $line && $line ~~ /^
            [ $<class>=[ <.ident>+ % '::' ]
              [ ':'
                $<n>=\w+
                  <[ < ( [ ]> $<v>=<[\w-]>+ <[ > ) \] ]>
                { %options{$<n>} = $<v> }
              ]*
              '='
            ]?
            $<path>=.+
        $/ {
            my $class = $<class> ?? ~$<class> !! 'CompUnitRepo::Local::File';
            my @paths = $<path>.split($sep);
            for @paths -> $path {
                if make-cur($class, $path) -> $cur {
                    %CUSTOM_LIB{~%options<name>} = $cur if %options<name>;
                    @INC.push: $cur
                }
                elsif %options<name> {
                    %CUSTOM_LIB{~%options<name>} = $path; # prime it
                }
            }
        }
    }

    # starting up for creating precomp
    if %*ENV<RAKUDO_PRECOMP_WITH> -> \specs {
        for PARSE-INCLUDE-SPEC(specs) -> \spec {
            @INC.push: make-cur(spec[0],spec[1]);
        }
        $*VM;  # apparently we need $*VM to be populated for valid precomps
    }

    # normal start up
    else {
        my %ENV := %*ENV; # only look up environment once
        my $I := nqp::atkey(nqp::atkey(%*COMPILING, '%?OPTIONS'), 'I');
        if nqp::defined($I) {
            if nqp::islist($I) {
                my Mu $iter := nqp::iterator($I);
                add-curs(nqp::p6box_s(nqp::shift($iter))) while $iter;
            }
            else {
                add-curs(nqp::p6box_s($I));
            }
        }

        my $path-sep := $*DISTRO.path-sep;
        if %ENV<RAKUDOLIB> || %ENV<PERL6LIB> {
            add-curs(%ENV<RAKUDOLIB>, $path-sep) if %ENV<RAKUDOLIB>;
            add-curs(%ENV<PERL6LIB>, $path-sep)  if %ENV<PERL6LIB>;
        }
        for nqp::jvmclasspaths() -> $path {
            add-curs($path, $path-sep)
              if nqp::stat($path, nqp::const::STAT_ISDIR);
        }

        my $prefix  := $*VM.prefix ~ '/share/perl6';
        my $abspath := "$prefix/share/libraries.json";
        if IO::Path.new-from-absolute-path($abspath).e {
            my $config = from-json( slurp $abspath );

            for $config.list -> @group {
                for @group>>.kv -> $class, $props {
                    for $props.list -> $prop {
                        if nqp::istype($prop,Associative) {
                            for $prop.value.flat -> $path {
                                if make-cur($class, $path) -> $cur {
                                    @INC.push: $cur;
                                    %CUSTOM_LIB{$prop.key} = $cur;
                                }
                                else {
                                    %CUSTOM_LIB{$prop.key} = $path; # prime it
                                }
                            }
                        }
                        else {
                            for $prop.flat -> $path {
                                if make-cur($class, $path) -> $cur {
                                    @INC.push: $cur;
                                }
                            }
                        }
                    }
                }
            }
        }
        # There is no config file, so pick sane defaults.
        else {
            # XXX Various issues with this stuff on JVM
            my Mu $compiler := nqp::getcurhllsym('$COMPILER_CONFIG');  # TEMPORARY
            try {
                if %ENV<HOME>
                  // (%ENV<HOMEDRIVE> // '') ~ (%ENV<HOMEPATH> // '') -> $home {
                    my $ver := nqp::p6box_s(nqp::atkey($compiler, 'version'));
                    if CompUnitRepo::Local::File.new("$home/.perl6/$ver/lib") -> $cur {
                        @INC.push: $cur;
                    }
                    if CompUnitRepo::Local::Installation.new("$home/.perl6/$ver") -> $cur {
                        @INC.push: %CUSTOM_LIB<home> = $cur;
                    }
                    else {
                        %CUSTOM_LIB<home> = "$home/.perl6/$ver";  # prime it
                    }
                }
            }
            if CompUnitRepo::Local::File.new("$prefix/lib") -> $cur {
                @INC.push: $cur;
            }
            if CompUnitRepo::Local::File.new("$prefix/vendor/lib") -> $cur {
                @INC.push: $cur;
            }
            if CompUnitRepo::Local::File.new("$prefix/site/lib") -> $cur {
                @INC.push: $cur;
            }
            if CompUnitRepo::Local::Installation.new($prefix) -> $cur {
                @INC.push: %CUSTOM_LIB<perl> = $cur;
            }
            else {
                %CUSTOM_LIB<perl> = $prefix;  # prime it
            }
            if CompUnitRepo::Local::Installation.new("$prefix/vendor") -> $cur {
                @INC.push: %CUSTOM_LIB<vendor> = $cur;
            }
            else {
                %CUSTOM_LIB<vendor> = "$prefix/vendor";  # prime it
            }
            if CompUnitRepo::Local::Installation.new("$prefix/site") -> $cur {
                @INC.push: %CUSTOM_LIB<site> = $cur;
            }
            else {
                %CUSTOM_LIB<site> = "$prefix/site";  # prime it
            }
        }
    }

    PROCESS::<@INC>        := @INC;
    PROCESS::<%CUSTOM_LIB> := %CUSTOM_LIB;

    nqp::bindhllsym('perl6', 'ModuleLoader', CompUnitRepo);
}

# From 'src/core/Process.pm'

multi sub INITIALIZE_DYNAMIC('$*PID') {
    PROCESS::<$PID> := nqp::p6box_i(nqp::getpid());
}

multi sub INITIALIZE_DYNAMIC('$*EXECUTABLE') {
    my $EXECUTABLE =
        $*VM.properties<perl6.execname>
        // $*VM.properties<perl6.prefix> ~ '/bin/perl6-j';
    $EXECUTABLE := IO::Path.new-from-absolute-path($EXECUTABLE);
    PROCESS::<$EXECUTABLE_NAME> := $EXECUTABLE.basename;
    PROCESS::<$EXECUTABLE>      := $EXECUTABLE;
}

multi sub INITIALIZE_DYNAMIC('$*EXECUTABLE_NAME') {
    PROCESS::<$EXECUTABLE_NAME> := $*EXECUTABLE.basename;
}

multi sub INITIALIZE_DYNAMIC('$*PROGRAM_NAME') {
    my Mu $comp := nqp::getcomp('perl6');
    my $PROGRAM_NAME = $comp.user-progname();
    PROCESS::<$PROGRAM>      := IO::Path.new($PROGRAM_NAME);
    PROCESS::<$PROGRAM_NAME> := $PROGRAM_NAME;
}

multi sub INITIALIZE_DYNAMIC('$*PROGRAM') {
    PROCESS::<$PROGRAM> := IO::Path.new($*PROGRAM_NAME);
}

multi sub INITIALIZE_DYNAMIC('$*TMPDIR') {
    PROCESS::<$TMPDIR> = $*SPEC.tmpdir;
}

{
    class IdName {
        has Int $!id;
        has Str $!name;

        submethod BUILD (:$!id, :$!name) { }

        method Numeric { $!id }
        method Str     { $!name }
        method gist    { "$!name ($!id)" }
    }

    class IdFetch {
        has Str $!name;

        submethod BUILD (:$!name) { PROCESS::{$!name} := self }

        sub fetch {
            once if !$*DISTRO.is-win && try { qx/id/ } -> $id {
                if $id ~~ m/^
                  [ uid "=" $<uid>=(\d+) ]
                  [ "(" $<user>=(<-[ ) ]>+) ")" ]
                  \s+
                  [ gid "=" $<gid>=(\d+) ]
                  [ "(" $<group>=(<-[ ) ]>+) ")" ]
                / {
                    PROCESS::<$USER> :=
                      IdName.new( :id(+$<uid>), :name(~$<user>) );
                    PROCESS::<$GROUP> :=
                      IdName.new( :id(+$<gid>), :name(~$<group>) );
                }

                # alas, no support yet
                else {
                    PROCESS::<$USER>  := Nil;
                    PROCESS::<$GROUP> := Nil;
                }
            }
        }

        method Numeric { return Nil unless fetch(); +PROCESS::{$!name} }
        method Str     { return Nil unless fetch(); ~PROCESS::{$!name} }
        method gist    {
            return Nil unless fetch();
            PROCESS::{$!name} ~ ' (' ~ +PROCESS::{$!name} ~ ')';
        }
    }

    IdFetch.new( :name<$USER> );
    IdFetch.new( :name<$GROUP> );
}

# From 'src/core/StrDistance.pm'

my class StrDistance is Cool {
    has Str $.before;
    has Str $.after;
    has Int $!distance;

    multi method Bool(StrDistance:D:)    { $.before ne $.after }
    multi method Numeric(StrDistance:D:) { self.Int }

    multi method Int(StrDistance:D:) {
        $!distance //= do {
            my @s = *, $.before.comb;
            my @t = *, $.after.comb;
            my @d;
            @d[$_][ 0] = $_ for ^@s.end;
            @d[ 0][$_] = $_ for ^@t.end;

            for 1..@s.end X 1..@t.end -> $i, $j {
                @d[$i][$j] = @s[$i] eq @t[$j]
                    ??   @d[$i-1][$j-1]    # No operation required when eq
                    !! ( @d[$i-1][$j  ],   # Deletion
                         @d[$i  ][$j-1],   # Insertion
                         @d[$i-1][$j-1],   # Substitution
                       ).min + 1;
            }

            @d[*-1][*-1];
        }
    }
}
# From 'src/core/Slang.pm'

class Slang {
    has $.grammar;
    has $.actions;
    multi method gist(Slang:D:) {
        # Handle NQP objects like Perl6::Grammar
        'Slang.new('
            ~ (':grammar(' ~ $!grammar.^name ~ ')',
               ':actions(' ~ $!actions.^name ~ ')').join(', ')
            ~ ')'
    }
    method parse (|c) {
        $!grammar.parse(:$!actions, |c);
    }
}
# From 'src/core/Metamodel/Primitives.pm'

my class Metamodel::Primitives {
    method create_type(Mu $how, $repr = 'P6opaque') {
        nqp::newtype($how, $repr.Str)
    }

    method set_package(Mu $type, $package) {
        nqp::setwho(nqp::decont($type), nqp::decont($package));
        $type
    }

    method install_method_cache(Mu $type, %cache, :$authoritative = True) {
        my Mu $cache := nqp::hash();
        for %cache.kv -> $name, $meth {
            nqp::bindkey($cache, $name, nqp::decont($meth));
        }
        nqp::setmethcache($type, $cache);
        nqp::setmethcacheauth($type, $authoritative ?? 1 !! 0);
        $type
    }

    method configure_type_checking(Mu $type, @cache, :$authoritative = True, :$call_accepts = False) {
        my Mu $cache := nqp::list();
        for @cache {
            nqp::push($cache, nqp::decont($_));
        }
        nqp::settypecache($type, $cache);
        nqp::settypecheckmode($type,
            ($authoritative ?? 0 !! 1) + ($call_accepts ?? 2 !! 0));
        $type
    }

    method configure_destroy(Mu $type, $destroy) {
        nqp::settypefinalize($type, $destroy ?? 1 !! 0);
        $type
    }

    method compose_type(Mu $type, $configuration) {
        multi sub to_vm_types(@array) {
            my Mu $list := nqp::list();
            for @array {
                nqp::push($list, to_vm_types($_));
            }
            $list
        }
        multi sub to_vm_types(%hash) {
            my Mu $hash := nqp::hash();
            for %hash.kv -> $k, $v {
                nqp::bindkey($hash, $k, to_vm_types($v));
            }
            $hash
        }
        multi sub to_vm_types($other) {
            nqp::decont($other)
        }
        nqp::composetype(nqp::decont($type), to_vm_types($configuration));
        $type
    }

    method rebless(Mu $obj, Mu $type) {
        nqp::rebless($obj, $type)
    }

    method is_type(Mu \obj, Mu \type) {
        nqp::p6bool(nqp::istype(obj, type))
    }
}
# From 'src/core/core_epilogue.pm'

BEGIN {
    Perl6::Metamodel::ClassHOW.HOW.reparent(Perl6::Metamodel::ClassHOW, Any);
    Perl6::Metamodel::ConcreteRoleHOW.HOW.reparent(Perl6::Metamodel::ConcreteRoleHOW, Any);
    Perl6::Metamodel::CurriedRoleHOW.HOW.reparent(Perl6::Metamodel::CurriedRoleHOW, Any);
    Perl6::Metamodel::EnumHOW.HOW.reparent(Perl6::Metamodel::EnumHOW, Any);
    Perl6::Metamodel::GenericHOW.HOW.reparent(Perl6::Metamodel::GenericHOW, Any);
    Perl6::Metamodel::ModuleHOW.HOW.reparent(Perl6::Metamodel::ModuleHOW, Any);
    Perl6::Metamodel::NativeHOW.HOW.reparent(Perl6::Metamodel::NativeHOW, Any);
    Perl6::Metamodel::PackageHOW.HOW.reparent(Perl6::Metamodel::PackageHOW, Any);
    Perl6::Metamodel::ParametricRoleGroupHOW.HOW.reparent(Perl6::Metamodel::ParametricRoleGroupHOW, Any);
    Perl6::Metamodel::ParametricRoleHOW.HOW.reparent(Perl6::Metamodel::ParametricRoleHOW, Any);
    Perl6::Metamodel::SubsetHOW.HOW.reparent(Perl6::Metamodel::SubsetHOW, Any);
    Perl6::Metamodel::GrammarHOW.HOW.compose(Perl6::Metamodel::GrammarHOW);
}

{YOU_ARE_HERE}


# vim: set ft=perl6 nomodifiable :
